{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hephaestus Toolkit Docs","text":"<p>Hephaestus streamlines refactoring and quality operations. These docs collect everything you need to plan rollouts, run the CLI, and keep automation evergreen.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Tutorials: Getting Started</li> <li>How-to guides: Install from a Wheelhouse, Configure Your Editor</li> <li>Explanation: Architecture Overview, Lifecycle Playbook</li> <li>Reference: CLI Reference, CLI Autocompletion, Pre-Release Checklist</li> <li>Appendix: ADR Template</li> <li>Toolkit Playbooks: Refactoring Toolkit docs</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install dependencies with <code>uv sync --extra dev --extra qa</code>.</li> <li>Explore the CLI with <code>uv run hephaestus --help</code> and the workflows in <code>README.md</code>.</li> <li>Follow the lifecycle playbook to move from discovery to delivery without surprises.</li> <li>To bootstrap the toolkit anywhere\u2014even without PyPI access\u2014run <code>uv run hephaestus release install</code>    to fetch and install the latest wheelhouse archive.</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md for branching, testing, and release guidance. The docs are built with MkDocs Material\u2014use <code>uv run mkdocs serve</code> for a live preview or <code>uv run mkdocs build</code> to render static assets.</p>"},{"location":"cli-completions/","title":"CLI Autocompletion","text":"<p>Hephaestus is built with Typer (Click under the hood) and ships native shell completion scripts. The steps below install completions once per machine so subcommands and options appear automatically.</p>"},{"location":"cli-completions/#quick-install","title":"Quick Install","text":"<pre><code>uv run hephaestus --install-completion\n</code></pre> <p>Typer detects your current shell and prints the install location. Follow the on-screen guidance to source the generated file (usually by appending a line to your shell profile).</p>"},{"location":"cli-completions/#manual-installation","title":"Manual Installation","text":"<p>If you prefer explicit control, generate the completion script and point your shell at it manually. Replace <code>$SHELL</code> with <code>bash</code>, <code>zsh</code>, or <code>fish</code> as appropriate.</p> <pre><code>uv run hephaestus --show-completion $SHELL &gt; ~/.config/hephaestus/completions.$SHELL\n</code></pre> <p>Add the following lines to your shell profile:</p> <ul> <li>Bash (<code>~/.bashrc</code> or <code>~/.bash_profile</code>):</li> </ul> <pre><code>source ~/.config/hephaestus/completions.bash\n</code></pre> <ul> <li>Zsh (<code>~/.zshrc</code>):</li> </ul> <pre><code>autoload -U compinit &amp;&amp; compinit\nsource ~/.config/hephaestus/completions.zsh\n</code></pre> <ul> <li>Fish (<code>~/.config/fish/config.fish</code>):</li> </ul> <pre><code>source ~/.config/hephaestus/completions.fish\n</code></pre>"},{"location":"cli-completions/#keeping-completions-fresh","title":"Keeping Completions Fresh","text":"<p>Regenerate the scripts whenever the CLI gains new commands:</p> <pre><code>uv run hephaestus --show-completion $SHELL &gt; ~/.config/hephaestus/completions.$SHELL\n</code></pre> <p>For contributors using the dev container, completions are pre-wired (see <code>.devcontainer</code> notes) so no additional setup is required.</p>"},{"location":"editor-setup/","title":"Editor Setup","text":"<p>Use these quick steps to align your editor with the tooling that ships in Hephaestus. The configuration keeps formatting, linting, and typing feedback consistent with CI so contributors see issues locally before they reach a pull request.</p>"},{"location":"editor-setup/#universal-settings","title":"Universal Settings","text":"<p>Hephaestus includes a project-wide <code>.editorconfig</code>. Most modern editors respect it automatically. If yours does not, install an EditorConfig plugin so indentation and whitespace behaviour match the repository defaults.</p> <p>Key defaults:</p> <ul> <li>UTF-8 encoding and LF line endings</li> <li>Four-space indentation for Python</li> <li>Two-space indentation for YAML, JSON, Markdown, shell scripts, and web assets</li> <li>Trailing whitespace trimmed on save and final newlines ensured</li> </ul>"},{"location":"editor-setup/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install the recommended extensions (VS Code prompts automatically when opening the workspace).</li> <li>Python (<code>ms-python.python</code>)</li> <li>Black Formatter (<code>ms-python.black-formatter</code>)</li> <li>Ruff (<code>charliermarsh.ruff</code>)</li> <li>Ruff Format (<code>charliermarsh.ruff-format</code>)</li> <li>Pylance (<code>ms-python.vscode-pylance</code>)</li> <li>UV (<code>astral-sh.uv</code>)</li> <li>Reload VS Code so the extensions activate, then run <code>uv sync --extra dev --extra qa</code> to install    tool dependencies.</li> <li>Enable the \"Format on Save\" option or add the following snippet to your user settings:</li> </ol> <pre><code>{\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.ruff\": \"explicit\"\n  }\n}\n</code></pre> <ol> <li>Install pre-commit hooks with <code>uv run pre-commit install</code> to keep linting and typing feedback in    sync with CI.</li> </ol>"},{"location":"editor-setup/#pycharm-intellij-idea","title":"PyCharm / IntelliJ IDEA","text":"<ul> <li>Install the EditorConfig plugin (bundled by default) and ensure \"Use tab character\" is   disabled for Python projects.</li> <li>Configure Black as the formatter and Ruff as an external tool or via the Ruff plugin to mirror the   command line experience.</li> <li>Point the interpreter at the UV-managed virtual environment (<code>.venv</code>) so type checking and pytest   discovery use the same dependencies as CI.</li> </ul>"},{"location":"editor-setup/#neovim","title":"Neovim","text":"<ul> <li>Install <code>editorconfig.nvim</code> (or equivalent) to honour the shared configuration.</li> <li>Use <code>null-ls</code> or <code>conform.nvim</code> to wire Black and Ruff formatters, and configure the <code>mypy</code> linter   through <code>nvim-lint</code> or <code>ALE</code> for inline typing diagnostics.</li> <li>Consider the <code>astral-sh/uv.nvim</code> plugin to manage environments with UV commands directly from   Neovim.</li> </ul>"},{"location":"editor-setup/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If Ruff or Black appear to conflict, run <code>uv run pre-commit run ruff-format --all-files</code> to reset   the workspace.</li> <li>If your editor cannot locate the virtual environment, create one with <code>uv sync --extra dev</code> and   reselect it in your IDE settings.</li> <li>For CI parity, always finish a feature branch by running the quickstart commands listed in   <code>README.md</code> or the pre-release checklist in <code>docs/pre-release-checklist.md</code>.</li> <li>Need the tooling without PyPI access? Run <code>uv run hephaestus release install</code> to download and   install the latest wheelhouse from GitHub Releases directly into your current environment.</li> </ul>"},{"location":"lifecycle/","title":"Evergreen Lifecycle Playbook","text":"<p>This guide maps the Hephaestus toolkit to the full software development lifecycle and highlights the upgrades we now ship to keep the project evergreen from discovery through long-term operations. Each phase lists the core intent, the tooling we rely on, and practical tips for maximising developer experience (DX), user experience (UX), and code quality (CQ).</p>"},{"location":"lifecycle/#overview-matrix","title":"Overview Matrix","text":"Stage Purpose Tooling &amp; Techniques Outcomes Discovery Capture product and technical context Architecture Decision Records (ADRs), <code>hephaestus plan</code> Shared understanding of the refactor mission Planning Align scope, owners, and guard rails Rich-rendered execution plans, Di\u00e1taxis documentation, roadmap issues Clear backlog and review cadence Development Implement changes with fast feedback <code>pre-commit</code>, Ruff, Black, PyUpgrade, Typer CLI workflows, type-driven toolbox, automated <code>hephaestus cleanup</code> hook Consistent codebase with ergonomic CLI flows Testing Safeguard behaviour and coverage Pytest with coverage gating, cleanup pre-flight for CI, characterization harness templates Confident refactors with measurable coverage Security &amp; Quality Gates Catch regressions early Mypy, Pip Audit, QA profiles, coverage thresholds, repo cleanup sweeps Automated quality floor with actionable reports Release Publish and document change Automated Release Tagging workflow, semantic version policy, deep-clean stage Repeatable, traceable releases Deployment Package and ship artefacts <code>uv</code> environments, pip-installable package, cleanup script Predictable install and clean substrate Operations Observe, upgrade, and respond TurboRepo Release Monitor, Dependabot, Ops README Proactive dependency hygiene and response triggers Feedback Bake learnings back in Issue templates, ADR rollups, docs updates Continuous improvement loop"},{"location":"lifecycle/#stage-details","title":"Stage Details","text":""},{"location":"lifecycle/#1-discovery","title":"1. Discovery","text":"<ul> <li>ADRs: Capture the why behind large decisions using the <code>docs/adr</code> directory (start with   <code>adr-template.md</code>). The template keeps reviews light-weight while providing auditability.</li> <li>Toolkit Plan Command: <code>uv run hephaestus plan</code> produces vibrant terminals that help workshop   the phases, highlight blocked work, and onboard new collaborators quickly.</li> </ul>"},{"location":"lifecycle/#2-planning","title":"2. Planning","text":"<ul> <li>Di\u00e1taxis-Aligned Docs: The refactoring playbooks and the new lifecycle guide document both   tutorials and explanations so teams can move from theory to execution rapidly.</li> <li>Backlog Hygiene: Use GitHub Project boards or Issues linked from plan steps. The optional   <code>ops/roadmap.md</code> template (see below) can be copied per initiative.</li> </ul>"},{"location":"lifecycle/#3-development","title":"3. Development","text":"<ul> <li>Pre-Commit: Install the hooks one time with <code>uv run pre-commit install</code> to ensure Ruff, Black,   PyUpgrade, Mypy, and Pip Audit run before every commit.</li> <li>Cleanup Guard Rail: The pre-commit configuration now runs <code>uv run hephaestus cleanup</code> on commit   and push stages so macOS metadata never lands in history.</li> <li>Type-Driven Helpers: The toolbox exposes typed dataclasses (<code>Hotspot</code>, <code>CoverageGap</code>,   <code>RefactorOpportunity</code>) so IDEs and editors surface completions automatically.</li> <li>CLI Ergonomics: New README coverage showcases how to drive hotspot triage, QA profile   inspection, and execution plans straight from the command line.</li> </ul>"},{"location":"lifecycle/#4-testing","title":"4. Testing","text":"<ul> <li>Coverage Gates: Pytest defaults now emit XML + terminal reports and fail when coverage drops   below 85%.</li> <li>CI Pre-Flight Cleanup: The main CI workflow executes <code>uv run hephaestus cleanup</code> immediately   after syncing dependencies so linting, typing, and tests always start from a pristine tree.</li> <li>Characterisation Harnesses: The toolkit scripts provide scaffolding for protecting behaviour   during refactors\u2014extend them with targeted regression tests as you modernise modules.</li> <li>Matrix CI: Tests execute across Python 3.12 and 3.13 ensuring future compatibility.</li> </ul>"},{"location":"lifecycle/#5-security-quality-gates","title":"5. Security &amp; Quality Gates","text":"<ul> <li>Static Typing: <code>uv run mypy</code> guards the toolbox and CLI for contract drift; the CI workflow   fails fast on new typing issues.</li> <li>Security Audits: Pip Audit runs on every mainline CI sweep (and locally via pre-commit) so   vulnerable dependencies never linger.</li> <li>Coverage + QA Profiles: Tight coupling between toolkit settings and QA profiles keeps rollouts   honest about the guard rails they promise.</li> </ul>"},{"location":"lifecycle/#6-release","title":"6. Release","text":"<ul> <li>Automated Release Tagging: Pushes to <code>main</code> automatically tag new versions based on   <code>pyproject.toml</code> and publish GitHub Releases with changelog-ready artefacts.</li> <li>Wheelhouse Distribution: The <code>Build Wheelhouse</code> workflow assembles wheels and sdists via   <code>uv build</code>, stores them as a downloadable GitHub Actions artefact, and attaches the bundle to each   GitHub Release so consumers can install without a PyPI publish.</li> <li>Wheelhouse Consumption: Run <code>uv run hephaestus release install --tag &lt;tag&gt;</code> from any project to   download the matching release archive, install its wheels into the active environment, and keep the   toolkit versions aligned even before PyPI publication.</li> <li>Deep-Clean Stage: The release workflow installs <code>uv</code> and performs <code>uv run hephaestus cleanup --deep-clean</code>   before version detection so archives and tags never include workspace cruft.</li> <li>Semantic Version Discipline: Bump the <code>version</code> field using semver semantics\u2014patch for safety   fixes, minor for new features, major for breaking changes.</li> <li>Pre-Release Checklist: Run through <code>docs/pre-release-checklist.md</code> before pushing the final   changes to confirm automation parity, forcing a local cleanup sweep and re-running guard rails.</li> </ul>"},{"location":"lifecycle/#7-deployment","title":"7. Deployment","text":"<ul> <li><code>uv</code> Environments: A locked dependency graph (<code>uv.lock</code>) plus the CI sync step make runtime   parity trivial.</li> <li>Packaging: The project remains pip-installable (<code>pip install hephaestus</code>) and ready for PyPI   or internal indices; consider enabling the publishing workflow in <code>.github/workflows</code> when the   first release candidate is ready.</li> <li>Cleanup Script: <code>./cleanup-macos-cruft.sh --deep-clean</code> keeps artefacts out of release   archives and ensures reproducible builds, and the automation hooks ensure those commands run   automatically during CI, releases, and pre-commit flows.</li> </ul>"},{"location":"lifecycle/#8-operations","title":"8. Operations","text":"<ul> <li>TurboRepo Monitor: Nightly checks compare the pinned version with upstream and open issues if   an upgrade is available.</li> <li>Dependabot: Weekly dependency nudges cover both Python packages and GitHub Actions.</li> <li>Operational Docs: <code>ops/README.md</code> documents the release observation flow. Extend with runbooks   for environment-specific steps as deployment needs grow.</li> </ul>"},{"location":"lifecycle/#9-feedback-continuous-improvement","title":"9. Feedback &amp; Continuous Improvement","text":"<ul> <li>Issue Templates &amp; Labels: Combine ADR updates with labelled issues (<code>dx</code>, <code>ux</code>, <code>quality</code>) to   track improvement work explicitly.</li> <li>Metrics Dashboards: Export coverage artefacts and hotspot scans to dashboards for trend   analysis and to celebrate improvements with the wider org.</li> </ul>"},{"location":"lifecycle/#quickstart-commands","title":"Quickstart Commands","text":"<pre><code>uv sync --extra dev --extra qa\nuv run pre-commit install\nuv run pre-commit run --all-files\nuv run hephaestus guard-rails\nuv run ruff check .\nuv run mypy src tests\nuv run pytest\nuv run pip-audit --strict\n</code></pre>"},{"location":"lifecycle/#completed-enhancements","title":"Completed Enhancements","text":"<p>The following enhancements have been successfully delivered:</p> <ol> <li>\u2705 Docs Site: MkDocs Material site is fully operational with Di\u00e1taxis-structured documentation,    comprehensive navigation, and search capabilities. Run <code>uv run mkdocs serve</code> for local preview.</li> <li>\u2705 CodeQL Security Scans: GitHub's CodeQL workflow runs on every push, pull request, and weekly    schedule, providing deep static analysis beyond pip-audit.</li> <li>\u2705 Structured Logging: JSON/text logging with run IDs and telemetry events across all CLI    operations (ADR-0003 foundation complete).</li> </ol>"},{"location":"lifecycle/#future-enhancements-roadmap","title":"Future Enhancements (Roadmap)","text":"<p>The following enhancements are planned for future releases:</p> <ol> <li>OpenTelemetry Spans (Sprint 2-3): Full distributed tracing with span instrumentation across CLI    commands for observability and performance monitoring. See ADR-0003    for implementation plan.</li> <li>Plugin Architecture (Sprint 2-4): Extensible quality gate system allowing custom checks and    third-party integrations. See ADR-0002 for design details.</li> <li>REST/gRPC API (Sprint 2-4): Remote invocation capabilities for AI agents, CI/CD orchestration,    and centralized dashboards. See ADR-0004 for architecture.</li> <li>Publish to PyPI (Sprint 2): Wire the release workflow to publish tagged versions directly to PyPI with    automated release notes using <code>git-cliff</code>.</li> </ol> <p>Staying evergreen is a journey. This playbook keeps the loop tight so engineering teams can refactor confidently, deliver delightful experiences, and maintain uncompromising quality.</p>"},{"location":"pre-release-checklist/","title":"Pre-Release Automation Checklist","text":"<p>Use this quick checklist before cutting a release to ensure the repository is pristine and all automation hooks have run:</p> <ol> <li>Confirm automation parity</li> <li> <code>uv sync --extra dev --extra qa</code></li> <li> <code>uv run pre-commit run --all-files</code></li> <li> <p> <code>uv run hephaestus cleanup --deep-clean</code></p> </li> <li> <p>Verify quality gates locally</p> </li> <li> <code>uv run ruff check .</code></li> <li> <code>uv run mypy src tests</code></li> <li> <p> <code>uv run pytest</code></p> </li> <li> <p>Run packaging sanity checks</p> </li> <li> <code>uv run hephaestus cleanup --deep-clean</code> (repeat to confirm clean tree)</li> <li> Remove temporary artefacts (<code>dist/</code>, <code>build/</code>, coverage caches) if present\u2014these          directories are <code>.gitignore</code>d but cleaning them locally keeps release diffs obvious</li> <li> Confirm the latest release will have a wheelhouse by spot-checking the <code>Build Wheelhouse</code>          workflow and ensuring the zipped artefact downloads successfully</li> <li> <p> Dry-run the installer with <code>uv run hephaestus release install --cleanup --remove-archive</code>          against the latest tag to verify the wheelhouse installs cleanly from GitHub Releases</p> </li> <li> <p>Review documentation</p> </li> <li> Update <code>docs/lifecycle.md</code> and <code>README.md</code> if automation changed</li> <li> <p> Record release notes / changelog summary</p> </li> <li> <p>Tag and release</p> </li> <li>When ready, push to <code>main</code>\u2014the release workflow will perform the final cleanup sweep and tag automatically.</li> </ol>"},{"location":"pre-release-checklist/#rollback-procedures","title":"Rollback Procedures","text":"<p>If a release is found to be broken or contains security vulnerabilities, follow these steps to roll back safely.</p>"},{"location":"pre-release-checklist/#immediate-actions","title":"Immediate Actions","text":"<ol> <li>Stop the Bleeding</li> <li> Document the issue with reproduction steps</li> <li> Determine severity (Critical, High, Medium, Low)</li> <li> <p> Notify stakeholders immediately if severity is High or Critical</p> </li> <li> <p>Identify Last Known Good Version</p> </li> </ol> <pre><code># List recent releases\ngh release list --repo IAmJonoBo/Hephaestus --limit 10\n\n# Review specific release\ngh release view v0.1.0 --repo IAmJonoBo/Hephaestus\n</code></pre> <ol> <li>Advise Users to Pin to Safe Version</li> <li>Create a pinned GitHub issue announcing the problem</li> <li>Update README.md with warning banner</li> <li>Send notification through established channels</li> </ol> <pre><code># Users should pin to last known good version\nhephaestus release install --tag v0.0.9\n</code></pre>"},{"location":"pre-release-checklist/#release-revocation","title":"Release Revocation","text":"<ol> <li>Delete Bad Release (if necessary)</li> </ol> <pre><code># Delete the problematic release\ngh release delete v0.1.0 --repo IAmJonoBo/Hephaestus --yes\n\n# Delete the tag\ngit tag -d v0.1.0\ngit push origin :refs/tags/v0.1.0\n</code></pre> <ol> <li>Publish Security Advisory (for security issues)</li> <li>Navigate to Repository \u2192 Security \u2192 Advisories</li> <li>Click \"New draft security advisory\"</li> <li>Fill in:<ul> <li>Title: Clear description of the issue</li> <li>Description: Impact, affected versions, workarounds</li> <li>Severity: Use CVSS calculator</li> <li>Affected versions: Specify version range</li> </ul> </li> <li>Publish when fix is ready</li> </ol>"},{"location":"pre-release-checklist/#fix-and-recovery","title":"Fix and Recovery","text":"<ol> <li>Prepare Fixed Version</li> <li> Identify root cause of the issue</li> <li> Implement fix on <code>main</code> branch</li> <li> Add regression test to prevent recurrence</li> <li> Update CHANGELOG.md with fix details</li> <li> <p> Bump version (use patch version for hotfixes)</p> </li> <li> <p>Release Hotfix</p> </li> <li> Run full pre-release checklist above</li> <li> Tag new release (e.g., v0.1.1)</li> <li> Verify wheelhouse builds successfully</li> <li> <p> Test installation from new release</p> </li> <li> <p>Announce Resolution</p> </li> <li> Update pinned issue with resolution</li> <li> Remove warning banner from README.md</li> <li> Publish security advisory (if applicable)</li> <li> Send \"all clear\" notification to users</li> </ol>"},{"location":"pre-release-checklist/#post-incident-review","title":"Post-Incident Review","text":"<ol> <li>Document Learnings</li> <li> Write post-mortem in <code>docs/incidents/YYYY-MM-DD-description.md</code></li> <li> Identify gaps in testing, automation, or monitoring</li> <li> Update ADRs if architectural changes needed</li> <li> <p> Schedule preventive improvements</p> </li> <li> <p>Improve Processes</p> <ul> <li> Add automated checks to prevent recurrence</li> <li> Update pre-release checklist with new items</li> <li> Enhance CI/CD gates if needed</li> <li> Train team on lessons learned</li> </ul> </li> </ol>"},{"location":"pre-release-checklist/#rollback-decision-matrix","title":"Rollback Decision Matrix","text":"Severity Issue Type Action Timeline Critical Remote code execution, data loss, security breach Immediate revocation + security advisory &lt; 1 hour High Broken core functionality, dependency CVE Fast-track hotfix + pin advisory &lt; 4 hours Medium Non-critical bugs, performance degradation Scheduled hotfix in next release &lt; 48 hours Low Cosmetic issues, documentation errors Fix in next regular release Next sprint"},{"location":"pre-release-checklist/#automation-opportunities","title":"Automation Opportunities","text":"<p>Future enhancements to streamline rollback:</p> <ul> <li> <code>hephaestus release revoke</code> command to automate deletion</li> <li> CI workflow to test rollback procedures</li> <li> Automated security advisory creation from template</li> <li> Slack/email integration for incident notifications</li> <li> Rollback smoke test suite</li> </ul>"},{"location":"pre-release-checklist/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Policy - Vulnerability disclosure process</li> <li>STRIDE Threat Model - Risk analysis</li> <li>Operating Safely - Safe usage practices</li> </ul> <p>Remember: A smooth rollback process requires practice. Consider running rollback drills quarterly to ensure the team is prepared.</p>"},{"location":"refactoring-toolkit/","title":"Refactoring Toolkit","text":"<p>The refactoring toolkit ships alongside the CLI to streamline codebase upgrades. Dive into the resources within <code>hephaestus-toolkit/refactoring/</code> for configuration, scripts, and playbooks.</p>"},{"location":"refactoring-toolkit/#directory-map","title":"Directory Map","text":"<ul> <li><code>config/</code> \u2014 Baseline configuration (<code>refactor.config.yaml</code>) that you can extend for your repo.</li> <li><code>docs/</code> \u2014 Playbooks and implementation notes; start with <code>README.md</code> and <code>PLAYBOOK.md</code>.</li> <li><code>scripts/</code> \u2014 Automation helpers for hotspot scans, codemods, and verification harnesses.</li> <li><code>ci/</code> \u2014 Workflow fragments and presets for integrating the toolkit into existing pipelines.</li> </ul>"},{"location":"refactoring-toolkit/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Refactoring Toolkit README   for a conceptual overview.</li> <li>Tailor <code>config/refactor.config.yaml</code> to your project layout.</li> <li>Use the CLI commands under <code>tools refactor</code> to rank hotspots and identify opportunity clusters.</li> <li>When you're ready to consume wheelhouse artefacts, rely on <code>hephaestus release install</code> or the   helpers in <code>hephaestus.release</code> to download and install the latest toolkit bundles from GitHub   releases without needing PyPI access.</li> </ul>"},{"location":"adr/","title":"Architecture Decision Records (ADRs)","text":"<p>This directory contains Architecture Decision Records documenting significant technical decisions made in the Hephaestus project.</p>"},{"location":"adr/#adr-index","title":"ADR Index","text":""},{"location":"adr/#accepted-implemented","title":"Accepted &amp; Implemented","text":"<ul> <li>ADR-0001: STRIDE Threat Model</li> <li>Status: Accepted (2025-01-11)</li> <li>Implementation: Phases 1-2 complete, Phase 3 partially complete</li> <li> <p>Summary: Comprehensive security analysis and threat mitigation strategies for Hephaestus CLI and release pipeline</p> </li> <li> <p>ADR-0002: Plugin Architecture</p> </li> <li>Status: Phase 1 Implemented (2025-01-15)</li> <li>Implementation: Phase 1 (Foundation) complete - API specification and base classes</li> <li> <p>Summary: Extensible plugin system for custom quality gates</p> </li> <li> <p>ADR-0003: OpenTelemetry Integration</p> </li> <li>Status: Phase 1 Implemented (2025-01-15)</li> <li>Implementation: Phase 1 (Foundation) complete - Optional telemetry module with no-op fallback</li> <li> <p>Summary: Integrate OpenTelemetry for distributed tracing, metrics, and observability</p> </li> <li> <p>ADR-0004: REST/gRPC API</p> </li> <li>Status: Phase 1 Implemented (2025-01-15)</li> <li>Implementation: Phase 1 (Foundation) complete - OpenAPI specification and module structure</li> <li> <p>Summary: Dual-protocol API for remote invocation and AI agent integration</p> </li> <li> <p>ADR-0006: Sigstore Bundle Backfill</p> </li> <li>Status: Phase 1 Implemented (2025-01-15)</li> <li>Implementation: Phase 1 (Preparation) complete - Metadata schema defined</li> <li>Summary: Backfill Sigstore attestations for historical releases to close supply chain security gap</li> </ul>"},{"location":"adr/#proposed-sprint-2","title":"Proposed - Sprint 2","text":"<ul> <li>ADR-0005: PyPI Publication Automation</li> <li>Status: Proposed (2025-01-15)</li> <li>Target: Next release (Sprint 1-2)</li> <li>Summary: Automated publication to PyPI using GitHub Actions and Trusted Publishers for improved discoverability and standard installation</li> </ul>"},{"location":"adr/#adr-lifecycle","title":"ADR Lifecycle","text":"<pre><code>Proposed \u2192 Accepted \u2192 Implemented \u2192 Superseded/Deprecated\n</code></pre>"},{"location":"adr/#status-definitions","title":"Status Definitions","text":"<ul> <li>Proposed: Decision documented, awaiting review and acceptance</li> <li>Accepted: Decision approved, implementation scheduled</li> <li>Implemented: Decision fully implemented in codebase</li> <li>Superseded: Decision replaced by a newer ADR</li> <li>Deprecated: Decision no longer applicable</li> </ul>"},{"location":"adr/#creating-a-new-adr","title":"Creating a New ADR","text":"<ol> <li>Copy <code>0000-template.md</code> to <code>NNNN-title.md</code> (use next sequential number)</li> <li>Fill in the template sections:</li> <li>Context: Why this decision is needed</li> <li>Decision: What we're deciding to do</li> <li>Consequences: Positive, negative, and risks</li> <li>Alternatives: What else we considered</li> <li>Implementation Plan: Phased rollout timeline</li> <li>Submit as PR for review</li> <li>Update this index when accepted</li> </ol>"},{"location":"adr/#adr-format","title":"ADR Format","text":"<p>All ADRs follow a consistent structure:</p> <ul> <li>Metadata: Status, date, relationships</li> <li>Context: Problem statement and motivating forces</li> <li>Decision: The architectural decision being made</li> <li>Consequences: Positive, negative, risks, and mitigations</li> <li>Alternatives Considered: Other approaches evaluated</li> <li>Implementation Plan: Phased rollout with milestones</li> <li>Follow-up Actions: Specific tasks with owners and dates</li> <li>References: Related documentation and resources</li> </ul>"},{"location":"adr/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - System architecture and component interactions</li> <li>STRIDE Threat Model Details - Complete security analysis</li> <li>Operating Safely Guide - Safety features and best practices</li> <li>Next Steps Tracker - Implementation status and roadmap</li> </ul>"},{"location":"adr/#decision-framework","title":"Decision Framework","text":"<p>When prioritizing ADR implementation, consider:</p> <ul> <li>Impact: How many users/workflows benefit?</li> <li>Effort: Implementation complexity and maintenance burden</li> <li>Dependencies: What foundational work is required?</li> <li>Community: Is there external demand or contribution interest?</li> <li>Security: Does this address threat model findings?</li> <li>Stability: Is the technical landscape mature enough?</li> </ul>"},{"location":"adr/#timeline-overview","title":"Timeline Overview","text":"<pre><code>Sprint 1 (Foundation - Complete)\n\u251c\u2500\u2500 ADR-0002: Plugin Architecture - API specification\n\u251c\u2500\u2500 ADR-0003: OpenTelemetry - Basic setup\n\u251c\u2500\u2500 ADR-0004: REST API - OpenAPI spec\n\u2514\u2500\u2500 ADR-0006: Sigstore Backfill - Metadata schema\n\nSprint 2 (Core Features)\n\u251c\u2500\u2500 ADR-0005: PyPI Publication - Registration &amp; automation\n\u251c\u2500\u2500 ADR-0006: Sigstore Backfill - Execution\n\u251c\u2500\u2500 ADR-0003: OpenTelemetry - Instrumentation\n\u2514\u2500\u2500 ADR-0002: Plugin Architecture - Discovery &amp; migration\n\nSprint 3 (Advanced Features)\n\u251c\u2500\u2500 ADR-0003: OpenTelemetry - Advanced features\n\u251c\u2500\u2500 ADR-0002: Plugin Architecture - Ecosystem\n\u251c\u2500\u2500 ADR-0004: REST API - Async &amp; gRPC\n\u2514\u2500\u2500 ADR-0006: Sigstore Backfill - Enforcement\n\nSprint 4 (Production Ready)\n\u251c\u2500\u2500 ADR-0003: OpenTelemetry - Production optimization\n\u251c\u2500\u2500 ADR-0002: Plugin Architecture - Marketplace\n\u251c\u2500\u2500 ADR-0004: REST API - Security &amp; deployment\n\u2514\u2500\u2500 ADR-0005: PyPI Publication - Optimization\n</code></pre>"},{"location":"adr/#maintenance","title":"Maintenance","text":"<p>ADRs should be reviewed:</p> <ul> <li>After each sprint completion</li> <li>After major feature additions</li> <li>When technical assumptions change</li> <li>When community feedback suggests changes</li> </ul> <p>Next scheduled review: Sprint 2 retrospective</p>"},{"location":"adr/0000-template/","title":"ADR 0000: Title","text":"<ul> <li>Status: Proposed</li> <li>Date: 2025-10-07</li> </ul>"},{"location":"adr/0000-template/#context","title":"Context","text":"<p>Explain the motivating forces behind the decision. Link to churn reports, hotspot scans, or stakeholder notes that triggered the exploration.</p>"},{"location":"adr/0000-template/#decision","title":"Decision","text":"<p>Record the decision in a single paragraph. Keep it action-oriented.</p>"},{"location":"adr/0000-template/#consequences","title":"Consequences","text":"<ul> <li>Positive: List the advantages or opportunities gained.</li> <li>Negative: List downsides, costs, or follow-up work required.</li> </ul>"},{"location":"adr/0000-template/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Alternative A \u2014 Summary and why it was not chosen.</li> <li>Alternative B \u2014 Summary and why it was not chosen.</li> </ol>"},{"location":"adr/0000-template/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Owner/Date \u2014 Implement supporting tasks.</li> <li> Owner/Date \u2014 Update documentation, roadmaps, or tooling as needed.</li> </ul>"},{"location":"adr/0001-stride-threat-model/","title":"ADR-001: STRIDE Threat Model for Hephaestus CLI and Release Pipeline","text":"<p>Status: Accepted Date: 2025-01-08 Last Updated: 2025-01-XX Authors: Security Review Team Reviewers: Platform Engineering</p>"},{"location":"adr/0001-stride-threat-model/#context","title":"Context","text":"<p>Hephaestus is a developer toolkit that provides CLI commands for code quality, refactoring, workspace cleanup, and release management. The tool has access to:</p> <ul> <li>Local filesystem (with potential for destructive operations)</li> <li>Network resources (GitHub API, release downloads)</li> <li>Subprocess execution (external tools like ruff, mypy, pytest)</li> <li>Sensitive credentials (GitHub tokens)</li> </ul> <p>This document applies the STRIDE threat modeling framework to identify security risks and recommend mitigations.</p>"},{"location":"adr/0001-stride-threat-model/#stride-analysis","title":"STRIDE Analysis","text":""},{"location":"adr/0001-stride-threat-model/#spoofing-identity","title":"Spoofing Identity","text":"<p>Threat: Attacker impersonates a legitimate release source or GitHub API endpoint</p> <p>Attack Scenarios:</p> <ol> <li>DNS spoofing redirects release downloads to malicious servers</li> <li>Man-in-the-middle attack intercepts GitHub API calls</li> <li>Compromised GitHub account publishes malicious releases</li> </ol> <p>Existing Mitigations:</p> <ul> <li>HTTPS for all network communications</li> <li>GitHub token authentication</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Implement SHA-256 checksum verification for wheelhouse downloads</li> <li>\u2705 Add Sigstore attestation for cryptographic proof of provenance</li> <li>\u2705 Pin expected repository patterns</li> <li>Consider certificate pinning for critical endpoints</li> </ul> <p>Priority: High</p>"},{"location":"adr/0001-stride-threat-model/#tampering-with-data","title":"Tampering with Data","text":"<p>Threat: Attacker modifies release artifacts, configuration files, or code during transit or at rest</p> <p>Attack Scenarios:</p> <ol> <li>Wheelhouse archive modified during download (network MITM)</li> <li>Release assets replaced on compromised GitHub account</li> <li>Configuration files (pyproject.toml, .pre-commit-config.yaml) tampered with</li> <li>Source code modifications not caught by guard rails</li> </ol> <p>Existing Mitigations:</p> <ul> <li>HTTPS encryption in transit</li> <li>Pre-commit hooks enforce code quality</li> <li>Guard rails pipeline validates code before commit</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Implement SHA-256 checksum verification with published manifests</li> <li>\u2705 Add Sigstore signatures for releases</li> <li>Consider read-only configuration defaults</li> <li>Implement file integrity monitoring for critical configs</li> </ul> <p>Priority: High</p>"},{"location":"adr/0001-stride-threat-model/#repudiation","title":"Repudiation","text":"<p>Threat: Actions are performed without audit trail, making it impossible to prove who did what</p> <p>Attack Scenarios:</p> <ol> <li>Cleanup command deletes files without logging what was removed</li> <li>Release installation happens without record of which version was installed</li> <li>Guard rails failures don't persist logs for review</li> </ol> <p>Existing Mitigations:</p> <ul> <li>CLI outputs actions to stdout with Rich formatting</li> <li>Git history tracks code changes</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Implement structured JSON logging with timestamps and user context</li> <li>Add optional audit log file for destructive operations</li> <li>Include release installation history in metadata file</li> <li>Emit cleanup manifests before deletion</li> </ul> <p>Priority: Medium</p>"},{"location":"adr/0001-stride-threat-model/#information-disclosure","title":"Information Disclosure","text":"<p>Threat: Sensitive information is exposed through logs, error messages, or telemetry</p> <p>Attack Scenarios:</p> <ol> <li>GitHub tokens appear in error messages or debug output</li> <li>File paths expose sensitive directory structure</li> <li>Telemetry inadvertently collects PII or sensitive data</li> <li>Cached release archives contain sensitive build information</li> </ol> <p>Existing Mitigations:</p> <ul> <li>Tokens read from environment variables</li> <li>No telemetry currently implemented</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Sanitize all error messages to remove tokens</li> <li>Implement token redaction in logs (show only first/last 4 chars)</li> <li>Make telemetry opt-in with clear privacy policy</li> <li>Document what data is collected and why</li> <li>Add <code>--redact-paths</code> option for sensitive directory names</li> </ul> <p>Priority: Medium</p>"},{"location":"adr/0001-stride-threat-model/#denial-of-service","title":"Denial of Service","text":"<p>Threat: Resource exhaustion or hanging operations prevent legitimate use</p> <p>Attack Scenarios:</p> <ol> <li>Slow or malicious HTTP endpoint causes indefinite hang during release download</li> <li>Infinite retry loop exhausts network resources</li> <li>Cleanup command recursively processes massive directory trees</li> <li>Guard rails subprocess hangs indefinitely</li> </ol> <p>Existing Mitigations:</p> <ul> <li>Configurable timeout for release downloads (DEFAULT_TIMEOUT)</li> <li>Max retries limit (DEFAULT_MAX_RETRIES)</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Implement exponential backoff with jitter for retries</li> <li>\u2705 Add circuit breaker pattern for repeated failures</li> <li>Set maximum depth for directory traversal in cleanup</li> <li>Add timeout for each guard rail subprocess</li> <li>Implement progress indicators for long-running operations</li> </ul> <p>Priority: Medium</p>"},{"location":"adr/0001-stride-threat-model/#elevation-of-privilege","title":"Elevation of Privilege","text":"<p>Threat: Attacker gains unauthorized access or executes code with elevated permissions</p> <p>Attack Scenarios:</p> <ol> <li>Cleanup command with <code>--extra-path /</code> deletes system files</li> <li>Command injection through unsafe subprocess calls</li> <li>Path traversal in release asset extraction</li> <li>Privilege escalation through setuid binaries in cleanup target</li> </ol> <p>Existing Mitigations:</p> <ul> <li>Git repository root detection limits scope</li> <li>Subprocess uses list form (not shell=True)</li> </ul> <p>Recommended Mitigations:</p> <ul> <li>\u2705 Refuse cleanup on dangerous paths (/, /home, /usr, /etc) unless <code>--allow-outside-root</code></li> <li>\u2705 Validate all subprocess arguments (no shell injection)</li> <li>\u2705 Sanitize release asset filenames (strip .., /, path separators)</li> <li>Add confirmation prompt for operations outside repository</li> <li>Implement dry-run mode for previewing destructive operations</li> <li>Drop privileges when possible (run as non-root)</li> </ul> <p>Priority: High</p>"},{"location":"adr/0001-stride-threat-model/#attack-surface-analysis","title":"Attack Surface Analysis","text":""},{"location":"adr/0001-stride-threat-model/#1-cli-entry-points","title":"1. CLI Entry Points","text":"<p>Surface:</p> <ul> <li>User-provided arguments (paths, URLs, tokens)</li> <li>Environment variables (GITHUB_TOKEN)</li> <li>Configuration files (pyproject.toml, refactor.config.yaml)</li> </ul> <p>Risks:</p> <ul> <li>Command injection via unsanitized arguments</li> <li>Path traversal via user-provided paths</li> <li>Token leakage through error messages</li> </ul> <p>Mitigations:</p> <ul> <li>\u2705 Use typer type validation for all inputs</li> <li>\u2705 Sanitize and validate all file paths</li> <li>\u2705 Redact tokens in all output</li> </ul>"},{"location":"adr/0001-stride-threat-model/#2-network-operations","title":"2. Network Operations","text":"<p>Surface:</p> <ul> <li>GitHub API calls</li> <li>Release asset downloads</li> <li>CDN requests</li> </ul> <p>Risks:</p> <ul> <li>Man-in-the-middle attacks</li> <li>Compromised CDN nodes</li> <li>Slow/malicious endpoints (DoS)</li> </ul> <p>Mitigations:</p> <ul> <li>\u2705 HTTPS only, no HTTP fallback</li> <li>\u2705 Timeout and retry with backoff</li> <li>\u2705 Checksum verification</li> <li>Consider certificate pinning</li> </ul>"},{"location":"adr/0001-stride-threat-model/#3-filesystem-operations","title":"3. Filesystem Operations","text":"<p>Surface:</p> <ul> <li>Cleanup deletion operations</li> <li>Release extraction</li> <li>Log file writes</li> <li>Configuration file reads</li> </ul> <p>Risks:</p> <ul> <li>Accidental data loss</li> <li>Path traversal</li> <li>Symlink attacks</li> <li>Permission issues</li> </ul> <p>Mitigations:</p> <ul> <li>\u2705 Path validation and sanitization</li> <li>\u2705 Dangerous path blocklist</li> <li>\u2705 Dry-run mode</li> <li>Check for symlinks before deletion</li> <li>Validate extracted file paths</li> </ul>"},{"location":"adr/0001-stride-threat-model/#4-subprocess-execution","title":"4. Subprocess Execution","text":"<p>Surface:</p> <ul> <li>ruff, mypy, pytest, pip-audit invocations</li> <li>git commands</li> <li>poetry/uv commands</li> </ul> <p>Risks:</p> <ul> <li>Command injection</li> <li>Unexpected tool behavior</li> <li>Tool vulnerabilities</li> <li>Resource exhaustion</li> </ul> <p>Mitigations:</p> <ul> <li>\u2705 Use list form for subprocess.run (not shell=True)</li> <li>\u2705 Validate tool availability before execution</li> <li>\u2705 Set timeout for all subprocesses</li> <li>Pin tool versions in development</li> <li>Audit subprocess output for sensitive data</li> </ul>"},{"location":"adr/0001-stride-threat-model/#security-requirements","title":"Security Requirements","text":""},{"location":"adr/0001-stride-threat-model/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<ul> <li> Token validation before GitHub API calls</li> <li> Fine-grained token permissions documentation</li> <li> Token expiration handling</li> </ul>"},{"location":"adr/0001-stride-threat-model/#data-protection","title":"Data Protection","text":"<ul> <li> HTTPS for all network traffic</li> <li> SHA-256 checksum verification for downloads</li> <li> Sigstore attestation validation</li> <li> Token redaction in logs</li> </ul>"},{"location":"adr/0001-stride-threat-model/#input-validation","title":"Input Validation","text":"<ul> <li> Type validation via typer</li> <li> Path sanitization and validation</li> <li> URL validation (scheme, domain allowlist)</li> <li> Asset filename sanitization</li> </ul>"},{"location":"adr/0001-stride-threat-model/#audit-monitoring","title":"Audit &amp; Monitoring","text":"<ul> <li> Structured logging (JSON format)</li> <li> Audit trail for destructive operations</li> <li> Release installation history</li> <li> Telemetry with privacy controls (planned Sprint 2-3, ADR-0003)</li> </ul>"},{"location":"adr/0001-stride-threat-model/#error-handling","title":"Error Handling","text":"<ul> <li> User-friendly error messages</li> <li> No sensitive data in errors</li> <li> Graceful degradation on failures</li> <li> Circuit breaker for repeated failures</li> </ul>"},{"location":"adr/0001-stride-threat-model/#secure-coding-practices","title":"Secure Coding Practices","text":"<ol> <li>Least Privilege: Run with minimum required permissions</li> <li>Defense in Depth: Multiple layers of validation</li> <li>Fail Secure: Default to safe behavior on errors</li> <li>Privacy by Design: Opt-in telemetry, minimal data collection</li> <li>Secure Defaults: Conservative settings out of the box</li> </ol>"},{"location":"adr/0001-stride-threat-model/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"adr/0001-stride-threat-model/#phase-1-critical-security-high-priority-complete","title":"Phase 1: Critical Security (High Priority) \u2705 COMPLETE","text":"<ul> <li> Implement checksum verification for releases</li> <li> Add dangerous path blocklist for cleanup</li> <li> Sanitize release asset filenames</li> <li> Add token redaction in logs</li> </ul>"},{"location":"adr/0001-stride-threat-model/#phase-2-hardening-medium-priority-complete","title":"Phase 2: Hardening (Medium Priority) \u2705 COMPLETE","text":"<ul> <li> Implement structured JSON logging</li> <li> Add exponential backoff and circuit breakers</li> <li> Create dry-run mode for cleanup</li> <li> Add confirmation prompts for risky operations</li> </ul>"},{"location":"adr/0001-stride-threat-model/#phase-3-advanced-features-low-priority","title":"Phase 3: Advanced Features (Low Priority)","text":"<ul> <li> Sigstore attestation validation</li> <li> Certificate pinning (deferred - not required for current threat model)</li> <li> Privacy-preserving telemetry (planned Sprint 2-3, see ADR-0003)</li> <li> Automated security testing in CI (CodeQL implemented)</li> </ul>"},{"location":"adr/0001-stride-threat-model/#review-updates","title":"Review &amp; Updates","text":"<p>This threat model should be reviewed:</p> <ul> <li>Quarterly by the security team</li> <li>After major feature additions</li> <li>After security incidents</li> <li>When new attack vectors are discovered</li> </ul> <p>Next Review: Sprint 3 retrospective</p>"},{"location":"adr/0001-stride-threat-model/#references","title":"References","text":"<ul> <li>OWASP Threat Modeling</li> <li>Microsoft STRIDE</li> <li>NIST SP 800-154: Guide to Data-Centric System Threat Modeling</li> </ul>"},{"location":"adr/0001-stride-threat-model/#conclusion","title":"Conclusion","text":"<p>Hephaestus has a moderate attack surface due to its filesystem operations, network access, and subprocess execution. The highest priority threats are:</p> <ol> <li>Tampering/Spoofing: Compromised releases (needs checksum verification)</li> <li>Elevation of Privilege: Dangerous cleanup operations (needs path validation)</li> <li>Denial of Service: Hanging network calls (needs timeouts/backoff)</li> </ol> <p>Implementing the recommended mitigations will significantly improve the security posture. The roadmap provides a phased approach to addressing threats based on risk and priority.</p>"},{"location":"adr/0001-stride-threat-model/#status-history","title":"Status History","text":"<ul> <li>2025-01-08: Draft - Initial STRIDE threat model completed</li> <li>2025-01-11: Accepted - All high-priority mitigations implemented:</li> <li>\u2705 SHA-256 checksum verification for releases</li> <li>\u2705 Sigstore attestation support</li> <li>\u2705 Dangerous path protection in cleanup</li> <li>\u2705 Network timeouts and exponential backoff</li> <li>\u2705 SECURITY.md published with disclosure process</li> <li>2025-01-XX: Updated - Authentication &amp; Authorization hardening complete:</li> <li>\u2705 Token validation before GitHub API calls</li> <li>\u2705 Token expiration handling with clear error messages</li> <li>\u2705 Support for all GitHub token formats (classic, fine-grained, PAT)</li> </ul>"},{"location":"adr/0002-plugin-architecture/","title":"ADR 0002: Plugin Architecture for Extensible Quality Gates","text":"<ul> <li>Status: Phase 1 Implemented</li> <li>Date: 2025-01-11</li> <li>Supersedes: N/A</li> <li>Superseded by: N/A</li> </ul>"},{"location":"adr/0002-plugin-architecture/#context","title":"Context","text":"<p>Hephaestus currently has a fixed set of quality gates (linting, formatting, type checking, testing, security audit) hard-coded into the <code>guard-rails</code> command and validation scripts. Different projects have different needs:</p> <ul> <li>Some teams want to add custom checks (e.g., SAST tools, contract testing, performance benchmarks)</li> <li>Others want to disable certain checks for specific workflows</li> <li>Integration with proprietary or organization-specific tooling is currently impossible</li> <li>The current approach requires code changes to add new quality gates</li> </ul> <p>This limits Hephaestus's applicability across diverse projects and prevents teams from tailoring quality enforcement to their specific needs without forking the project.</p>"},{"location":"adr/0002-plugin-architecture/#motivating-use-cases","title":"Motivating Use Cases","text":"<ol> <li>Custom Security Scanning: Teams want to integrate tools like Bandit, Safety, or proprietary security scanners</li> <li>Contract Testing: API teams want to validate OpenAPI specs or GraphQL schemas as quality gates</li> <li>Performance Gates: Some teams need performance regression detection in their quality pipeline</li> <li>Documentation Checks: Teams want to enforce documentation standards (Markdown linting, spell checking)</li> <li>Custom Metrics: Organizations want to enforce custom quality metrics (complexity thresholds, dependency rules)</li> </ol>"},{"location":"adr/0002-plugin-architecture/#current-limitations","title":"Current Limitations","text":"<ul> <li>Adding a new quality gate requires modifying <code>validate_quality_gates.py</code> or <code>cli.py</code></li> <li>No way to disable gates conditionally</li> <li>No extension points for custom logic</li> <li>Configuration is limited to command-line flags</li> <li>No way to share custom gates across projects</li> </ul>"},{"location":"adr/0002-plugin-architecture/#decision","title":"Decision","text":"<p>We will implement a plugin architecture that allows declarative registration of custom quality gates through a combination of:</p> <ol> <li>Plugin Discovery System: Plugins discovered via entry points or configuration files</li> <li>Plugin API: Well-defined interface for quality gates with lifecycle hooks</li> <li>Configuration Schema: YAML/TOML-based plugin configuration with validation</li> <li>Plugin Manifest: Metadata about requirements, dependencies, and execution order</li> </ol>"},{"location":"adr/0002-plugin-architecture/#architecture","title":"Architecture","text":"<pre><code>hephaestus/\n\u251c\u2500\u2500 src/hephaestus/\n\u2502   \u251c\u2500\u2500 plugins/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py           # Plugin loader and registry\n\u2502   \u2502   \u251c\u2500\u2500 base.py                # QualityGatePlugin base class\n\u2502   \u2502   \u251c\u2500\u2500 builtin/               # Built-in plugins\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ruff_plugin.py     # Ruff linting\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mypy_plugin.py     # Type checking\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pytest_plugin.py   # Testing\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 discovery.py           # Plugin discovery mechanism\n\u2502   \u2514\u2500\u2500 cli.py                     # Uses plugin registry\n\nplugins/                           # External plugins directory\n\u251c\u2500\u2500 bandit_plugin.py               # Example custom plugin\n\u2514\u2500\u2500 docs_plugin.py                 # Example docs plugin\n</code></pre>"},{"location":"adr/0002-plugin-architecture/#plugin-interface","title":"Plugin Interface","text":"<pre><code>from abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass PluginMetadata:\n    \"\"\"Metadata about a quality gate plugin.\"\"\"\n    name: str\n    version: str\n    description: str\n    author: str\n    category: str  # \"linting\", \"testing\", \"security\", \"custom\"\n    requires: list[str]  # Dependencies\n    order: int = 100  # Execution order (lower = earlier)\n\n@dataclass\nclass PluginResult:\n    \"\"\"Result of running a plugin.\"\"\"\n    success: bool\n    message: str\n    details: Optional[dict] = None\n    exit_code: int = 0\n\nclass QualityGatePlugin(ABC):\n    \"\"\"Base class for quality gate plugins.\"\"\"\n\n    @property\n    @abstractmethod\n    def metadata(self) -&gt; PluginMetadata:\n        \"\"\"Return plugin metadata.\"\"\"\n        pass\n\n    @abstractmethod\n    def validate_config(self, config: dict) -&gt; bool:\n        \"\"\"Validate plugin configuration.\"\"\"\n        pass\n\n    @abstractmethod\n    def run(self, config: dict) -&gt; PluginResult:\n        \"\"\"Execute the quality gate check.\"\"\"\n        pass\n\n    def setup(self) -&gt; None:\n        \"\"\"Optional: Setup before running.\"\"\"\n        pass\n\n    def teardown(self) -&gt; None:\n        \"\"\"Optional: Cleanup after running.\"\"\"\n        pass\n</code></pre>"},{"location":"adr/0002-plugin-architecture/#configuration-format","title":"Configuration Format","text":"<pre><code># .hephaestus/plugins.yaml\nplugins:\n  # Built-in plugins (always available)\n  builtin:\n    - name: ruff\n      enabled: true\n      config:\n        args: [\"check\", \".\"]\n\n    - name: mypy\n      enabled: true\n      config:\n        args: [\"src\", \"tests\"]\n\n    - name: pytest\n      enabled: true\n      config:\n        args: [\"--cov=src\", \"--cov-report=xml\"]\n\n  # External plugins\n  external:\n    - name: bandit\n      path: plugins/bandit_plugin.py\n      enabled: true\n      config:\n        severity: medium\n        confidence: high\n\n    - name: docs-check\n      package: hephaestus-docs-plugin\n      enabled: true\n      config:\n        spell_check: true\n        broken_links: true\n</code></pre>"},{"location":"adr/0002-plugin-architecture/#plugin-discovery","title":"Plugin Discovery","text":"<ol> <li>Entry Points: Plugins can register via setuptools entry points</li> <li>Configuration File: Plugins defined in <code>.hephaestus/plugins.yaml</code></li> <li>Environment Variable: <code>HEPHAESTUS_PLUGIN_PATH</code> for custom plugin directories</li> </ol>"},{"location":"adr/0002-plugin-architecture/#execution-flow","title":"Execution Flow","text":"<pre><code># Simplified example\ndef run_quality_gates(config_path: str) -&gt; bool:\n    # Load configuration\n    config = load_plugin_config(config_path)\n\n    # Discover and load plugins\n    plugins = discover_plugins(config)\n\n    # Validate plugins\n    for plugin in plugins:\n        if not plugin.validate_config(config.get(plugin.name, {})):\n            raise ValueError(f\"Invalid config for {plugin.name}\")\n\n    # Sort by execution order\n    plugins.sort(key=lambda p: p.metadata.order)\n\n    # Execute plugins\n    results = []\n    for plugin in plugins:\n        if not config.is_enabled(plugin.name):\n            continue\n\n        plugin.setup()\n        result = plugin.run(config.get(plugin.name, {}))\n        plugin.teardown()\n        results.append(result)\n\n    # Aggregate results\n    return all(r.success for r in results)\n</code></pre>"},{"location":"adr/0002-plugin-architecture/#consequences","title":"Consequences","text":""},{"location":"adr/0002-plugin-architecture/#positive","title":"Positive","text":"<ol> <li>Extensibility: Teams can add custom quality gates without modifying Hephaestus</li> <li>Reusability: Plugins can be shared across projects and organizations</li> <li>Flexibility: Each project can enable/disable gates as needed</li> <li>Standardization: Common interface encourages consistent quality gate implementations</li> <li>Backward Compatibility: Existing functionality becomes built-in plugins</li> <li>Ecosystem Growth: Third-party plugins can extend Hephaestus capabilities</li> </ol>"},{"location":"adr/0002-plugin-architecture/#negative","title":"Negative","text":"<ol> <li>Complexity: Plugin system adds architectural complexity</li> <li>Maintenance Burden: Need to maintain stable plugin API across versions</li> <li>Documentation: Requires comprehensive plugin development guide</li> <li>Testing: Need to test plugin discovery, loading, and execution</li> <li>Migration: Existing code needs refactoring to plugin architecture</li> <li>Security: Plugins execute arbitrary code, need sandboxing/review process</li> </ol>"},{"location":"adr/0002-plugin-architecture/#risks","title":"Risks","text":"<ul> <li>Breaking Changes: Plugin API changes could break third-party plugins</li> <li>Performance: Plugin discovery and loading adds overhead</li> <li>Security: Malicious plugins could compromise security</li> <li>Compatibility: Plugin dependencies might conflict with Hephaestus dependencies</li> </ul>"},{"location":"adr/0002-plugin-architecture/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>API Versioning: Use semantic versioning for plugin API, maintain compatibility</li> <li>Plugin Validation: Validate plugins before execution (checksums, signatures)</li> <li>Sandboxing: Run plugins in isolated environments (future enhancement)</li> <li>Documentation: Comprehensive plugin development guide and examples</li> <li>Testing: Extensive test suite for plugin system</li> <li>Review Process: Guidelines for reviewing third-party plugins</li> </ol>"},{"location":"adr/0002-plugin-architecture/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/0002-plugin-architecture/#1-configuration-only-approach","title":"1. Configuration-Only Approach","text":"<p>Description: Allow custom commands via YAML configuration without Python plugins.</p> <p>Pros:</p> <ul> <li>Simpler to implement</li> <li>No security concerns with arbitrary code execution</li> <li>Easier to configure</li> </ul> <p>Cons:</p> <ul> <li>Limited to shell commands</li> <li>No access to Hephaestus internals</li> <li>Difficult to implement complex logic</li> </ul> <p>Why not chosen: Too limiting for complex use cases requiring programmatic access.</p>"},{"location":"adr/0002-plugin-architecture/#2-git-hooks-only","title":"2. Git Hooks Only","text":"<p>Description: Let teams use git hooks for custom quality gates.</p> <p>Pros:</p> <ul> <li>No changes needed to Hephaestus</li> <li>Standard mechanism</li> </ul> <p>Cons:</p> <ul> <li>Not integrated with guard-rails workflow</li> <li>No unified reporting</li> <li>Harder to share across projects</li> </ul> <p>Why not chosen: Doesn't solve the integration problem, just pushes it elsewhere.</p>"},{"location":"adr/0002-plugin-architecture/#3-fork-and-customize","title":"3. Fork and Customize","text":"<p>Description: Let teams fork Hephaestus and add custom gates.</p> <p>Pros:</p> <ul> <li>Full control</li> <li>No plugin complexity</li> </ul> <p>Cons:</p> <ul> <li>Maintenance burden</li> <li>Difficult to merge upstream changes</li> <li>Not reusable</li> </ul> <p>Why not chosen: Doesn't scale, contradicts open-source best practices.</p>"},{"location":"adr/0002-plugin-architecture/#4-webhook-based-extension","title":"4. Webhook-Based Extension","text":"<p>Description: Call out to HTTP endpoints for custom checks.</p> <p>Pros:</p> <ul> <li>Language agnostic</li> <li>Network-based isolation</li> </ul> <p>Cons:</p> <ul> <li>Requires running services</li> <li>Network overhead</li> <li>Complex setup</li> </ul> <p>Why not chosen: Too heavyweight for simple use cases, adds operational complexity.</p>"},{"location":"adr/0002-plugin-architecture/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr/0002-plugin-architecture/#sprint-1-foundation-complete","title":"Sprint 1: Foundation (Complete)","text":"<ul> <li> Design plugin API interface</li> <li> Implement plugin base class</li> <li> Create plugin registry</li> <li> Add configuration schema</li> <li> Write comprehensive tests</li> </ul>"},{"location":"adr/0002-plugin-architecture/#sprint-2-migration-discovery","title":"Sprint 2: Migration &amp; Discovery","text":"<ul> <li> Refactor existing gates to plugins</li> <li> Implement plugin discovery</li> <li> Add plugin validation</li> <li> Update guard-rails to use plugin system</li> <li> Maintain backward compatibility</li> </ul>"},{"location":"adr/0002-plugin-architecture/#sprint-3-ecosystem-development","title":"Sprint 3: Ecosystem Development","text":"<ul> <li> Document plugin development</li> <li> Create example plugins</li> <li> Publish plugin template</li> <li> Build plugin catalog</li> <li> Establish review process</li> </ul>"},{"location":"adr/0002-plugin-architecture/#sprint-4-advanced-features","title":"Sprint 4: Advanced Features","text":"<ul> <li> Add plugin dependency resolution</li> <li> Implement plugin versioning</li> <li> Add plugin marketplace/registry</li> <li> Sandbox plugin execution</li> <li> Add telemetry for plugin usage</li> </ul>"},{"location":"adr/0002-plugin-architecture/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Create plugin API design document</li> <li> Implement plugin base class and registry</li> <li> Refactor existing gates to plugins</li> <li> Write plugin development guide</li> <li> Create example plugins and template</li> </ul>"},{"location":"adr/0002-plugin-architecture/#references","title":"References","text":"<ul> <li>Hephaestus Architecture</li> <li>Quality Gates Guide</li> <li>Plugin Development Guide (future)</li> <li>pytest plugin architecture</li> <li>pre-commit hooks architecture</li> </ul>"},{"location":"adr/0002-plugin-architecture/#appendix-example-plugin","title":"Appendix: Example Plugin","text":"<pre><code># plugins/bandit_plugin.py\nfrom hephaestus.plugins.base import QualityGatePlugin, PluginMetadata, PluginResult\nimport subprocess\n\nclass BanditPlugin(QualityGatePlugin):\n    \"\"\"Security linting with Bandit.\"\"\"\n\n    @property\n    def metadata(self) -&gt; PluginMetadata:\n        return PluginMetadata(\n            name=\"bandit\",\n            version=\"1.0.0\",\n            description=\"Security linting for Python code\",\n            author=\"Hephaestus Team\",\n            category=\"security\",\n            requires=[\"bandit&gt;=1.7.0\"],\n            order=150,  # Run after linting\n        )\n\n    def validate_config(self, config: dict) -&gt; bool:\n        # Validate configuration\n        severity = config.get(\"severity\", \"low\")\n        return severity in [\"low\", \"medium\", \"high\"]\n\n    def run(self, config: dict) -&gt; PluginResult:\n        # Run bandit\n        cmd = [\"bandit\", \"-r\", \"src\"]\n\n        if \"severity\" in config:\n            cmd.extend([\"-ll\", config[\"severity\"]])\n\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                check=False,\n            )\n\n            return PluginResult(\n                success=result.returncode == 0,\n                message=f\"Bandit: {result.returncode == 0 and 'passed' or 'failed'}\",\n                details={\"stdout\": result.stdout, \"stderr\": result.stderr},\n                exit_code=result.returncode,\n            )\n        except FileNotFoundError:\n            return PluginResult(\n                success=False,\n                message=\"Bandit not installed\",\n                exit_code=127,\n            )\n</code></pre>"},{"location":"adr/0002-plugin-architecture/#status-history","title":"Status History","text":"<ul> <li>2025-01-11: Proposed (documented in ADR)</li> <li>Future: Accepted/Rejected based on community feedback</li> <li>Future: Implemented in vX.Y.Z</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/","title":"ADR 0003: OpenTelemetry Integration for Observability","text":"<ul> <li>Status: Phase 1 Implemented</li> <li>Date: 2025-01-11</li> <li>Supersedes: N/A</li> <li>Superseded by: N/A</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#context","title":"Context","text":"<p>Hephaestus currently has structured logging with JSON output and run IDs for correlation, but lacks comprehensive observability for:</p> <ul> <li>Understanding performance bottlenecks in quality pipelines</li> <li>Tracking success/failure rates across different environments</li> <li>Debugging issues in remote/CI environments</li> <li>Measuring adoption and usage patterns</li> <li>Identifying slow or failing quality gates</li> </ul> <p>Current logging approach provides:</p> <ul> <li>Structured JSON logs with context</li> <li>Run IDs for operation correlation</li> <li>Event definitions in telemetry module</li> </ul> <p>But lacks:</p> <ul> <li>Distributed tracing across operations</li> <li>Metrics collection and aggregation</li> <li>Service health monitoring</li> <li>Performance profiling</li> <li>Real-time dashboards</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#motivating-use-cases","title":"Motivating Use Cases","text":"<ol> <li>CI Pipeline Optimization: Teams want to know which quality gates are slowest in CI</li> <li>Debugging Remote Failures: Need to trace execution across distributed systems</li> <li>Usage Analytics: Understanding which features are used most</li> <li>Performance Monitoring: Track regression in guard-rails execution time</li> <li>Error Tracking: Aggregate errors across all installations for pattern detection</li> <li>Capacity Planning: Understand resource usage for infrastructure planning</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#requirements","title":"Requirements","text":"<ul> <li>Privacy: Must be opt-in, anonymize sensitive data</li> <li>Minimal Overhead: &lt;5% performance impact when enabled</li> <li>Standard Format: Use OpenTelemetry standard for interoperability</li> <li>Flexible Backend: Support multiple exporters (Jaeger, Prometheus, cloud services)</li> <li>Graceful Degradation: Failures in telemetry should not break functionality</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#decision","title":"Decision","text":"<p>We will integrate OpenTelemetry (OTel) as our observability framework, providing:</p> <ol> <li>Distributed Tracing: Trace execution across CLI commands and operations</li> <li>Metrics Collection: Track counts, durations, and resource usage</li> <li>Structured Attributes: Rich context on spans and metrics</li> <li>Multiple Exporters: Support for various backends</li> <li>Privacy Controls: Opt-in with data anonymization</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#architecture","title":"Architecture","text":"<pre><code>hephaestus/\n\u251c\u2500\u2500 src/hephaestus/\n\u2502   \u251c\u2500\u2500 telemetry/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py           # Telemetry configuration\n\u2502   \u2502   \u251c\u2500\u2500 tracing.py             # Tracing setup and utilities\n\u2502   \u2502   \u251c\u2500\u2500 metrics.py             # Metrics collection\n\u2502   \u2502   \u251c\u2500\u2500 exporters.py           # Exporter configuration\n\u2502   \u2502   \u2514\u2500\u2500 privacy.py             # Data anonymization\n\u2502   \u2514\u2500\u2500 cli.py                     # Instrumented commands\n\npyproject.toml                     # OTel dependencies (optional)\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#telemetry-configuration","title":"Telemetry Configuration","text":"<pre><code># Enable telemetry\nexport HEPHAESTUS_TELEMETRY_ENABLED=true\n\n# Configure exporter\nexport OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318\n\n# Set service name\nexport OTEL_SERVICE_NAME=hephaestus\n\n# Configure sampling (1.0 = 100%)\nexport OTEL_TRACES_SAMPLER=parentbased_traceidratio\nexport OTEL_TRACES_SAMPLER_ARG=0.1  # 10% sampling\n\n# Privacy mode (anonymize paths, usernames)\nexport HEPHAESTUS_TELEMETRY_PRIVACY=strict\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#instrumentation-example","title":"Instrumentation Example","text":"<pre><code>from opentelemetry import trace\nfrom hephaestus.telemetry import get_tracer, record_metric\n\ntracer = get_tracer(__name__)\n\n@tracer.start_as_current_span(\"guard_rails\")\ndef guard_rails(no_format: bool = False) -&gt; int:\n    \"\"\"Run comprehensive quality pipeline with tracing.\"\"\"\n    with tracer.start_as_current_span(\"cleanup\"):\n        cleanup_result = run_cleanup()\n        record_metric(\"cleanup.files_deleted\", cleanup_result.count)\n\n    with tracer.start_as_current_span(\"lint\"):\n        lint_result = run_lint()\n        record_metric(\"lint.violations\", lint_result.violations)\n\n    # ... more operations ...\n\n    return 0 if all_passed else 1\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#trace-structure","title":"Trace Structure","text":"<pre><code>Trace: guard-rails-execution\n\u251c\u2500\u2500 Span: cleanup (duration: 2.3s)\n\u2502   \u251c\u2500\u2500 Attribute: files.deleted = 142\n\u2502   \u251c\u2500\u2500 Attribute: size.freed = 15.2MB\n\u2502   \u2514\u2500\u2500 Event: cleanup.completed\n\u251c\u2500\u2500 Span: lint (duration: 5.1s)\n\u2502   \u251c\u2500\u2500 Attribute: violations.found = 0\n\u2502   \u251c\u2500\u2500 Attribute: files.checked = 45\n\u2502   \u2514\u2500\u2500 Event: lint.completed\n\u251c\u2500\u2500 Span: format (duration: 3.8s)\n\u2502   \u2514\u2500\u2500 Event: format.completed\n\u251c\u2500\u2500 Span: typecheck (duration: 12.4s)\n\u2502   \u2514\u2500\u2500 Attribute: files.checked = 45\n\u251c\u2500\u2500 Span: test (duration: 32.1s)\n\u2502   \u251c\u2500\u2500 Attribute: tests.passed = 85\n\u2502   \u251c\u2500\u2500 Attribute: coverage = 87.29\n\u2502   \u2514\u2500\u2500 Event: test.completed\n\u2514\u2500\u2500 Span: audit (duration: 8.2s)\n    \u251c\u2500\u2500 Attribute: vulnerabilities = 0\n    \u2514\u2500\u2500 Event: audit.completed\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#metrics-to-collect","title":"Metrics to Collect","text":"<p>Counters:</p> <ul> <li><code>hephaestus.commands.executed</code> - Total commands run</li> <li><code>hephaestus.commands.failed</code> - Failed commands</li> <li><code>hephaestus.quality_gates.passed</code> - Quality gates passed</li> <li><code>hephaestus.quality_gates.failed</code> - Quality gates failed</li> </ul> <p>Gauges:</p> <ul> <li><code>hephaestus.test_coverage</code> - Current test coverage percentage</li> <li><code>hephaestus.files_cleaned</code> - Files removed by cleanup</li> </ul> <p>Histograms:</p> <ul> <li><code>hephaestus.command.duration</code> - Command execution time</li> <li><code>hephaestus.quality_gate.duration</code> - Individual gate duration</li> <li><code>hephaestus.cleanup.size_freed</code> - Disk space freed</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#privacy-protection","title":"Privacy Protection","text":"<pre><code>def anonymize_path(path: Path) -&gt; str:\n    \"\"\"Anonymize file paths for privacy.\"\"\"\n    if privacy_mode == \"strict\":\n        # Replace username and sensitive parts\n        return str(path).replace(os.path.expanduser(\"~\"), \"~\")\n    return str(path)\n\ndef sanitize_attributes(attrs: dict) -&gt; dict:\n    \"\"\"Remove or anonymize sensitive attributes.\"\"\"\n    sanitized = {}\n    for key, value in attrs.items():\n        if key in SENSITIVE_KEYS:\n            sanitized[key] = \"[REDACTED]\"\n        elif isinstance(value, Path):\n            sanitized[key] = anonymize_path(value)\n        else:\n            sanitized[key] = value\n    return sanitized\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#exporter-support","title":"Exporter Support","text":"<ol> <li>Console: Debug output to stdout</li> <li>OTLP: Standard protocol (Jaeger, Tempo, etc.)</li> <li>Prometheus: Metrics export</li> <li>Zipkin: Distributed tracing</li> <li>Cloud Services: AWS X-Ray, GCP Cloud Trace, Azure Monitor</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#consequences","title":"Consequences","text":""},{"location":"adr/0003-opentelemetry-integration/#positive","title":"Positive","text":"<ol> <li>Visibility: Deep insight into system behavior and performance</li> <li>Debugging: Easier troubleshooting with distributed traces</li> <li>Optimization: Data-driven performance improvements</li> <li>Reliability: Early detection of issues and regressions</li> <li>Adoption Tracking: Understanding how features are used</li> <li>Standard Format: Industry-standard observability</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#negative","title":"Negative","text":"<ol> <li>Complexity: Additional dependency and configuration</li> <li>Performance: Small overhead (typically &lt;5%)</li> <li>Privacy Concerns: Need careful handling of sensitive data</li> <li>Infrastructure: Requires backend services for storage</li> <li>Maintenance: Need to maintain instrumentation code</li> <li>Optional Dependency: Adds optional dependencies</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#risks","title":"Risks","text":"<ul> <li>Data Leakage: Accidental exposure of sensitive information</li> <li>Performance Impact: Overhead in hot paths</li> <li>Backend Dependency: Requires external services</li> <li>Complexity: Additional troubleshooting surface</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Opt-In: Disabled by default, explicit enablement required</li> <li>Sampling: Configurable sampling to reduce overhead</li> <li>Privacy: Built-in data anonymization</li> <li>Graceful Degradation: Continue working if telemetry fails</li> <li>Documentation: Clear privacy policy and configuration guide</li> </ol>"},{"location":"adr/0003-opentelemetry-integration/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/0003-opentelemetry-integration/#1-custom-telemetry-system","title":"1. Custom Telemetry System","text":"<p>Description: Build our own telemetry system tailored to Hephaestus.</p> <p>Pros:</p> <ul> <li>Full control over data format</li> <li>No external dependencies</li> <li>Simpler implementation</li> </ul> <p>Cons:</p> <ul> <li>Reinventing the wheel</li> <li>No standard format</li> <li>Limited tool ecosystem</li> <li>More maintenance burden</li> </ul> <p>Why not chosen: OpenTelemetry is industry standard with rich ecosystem.</p>"},{"location":"adr/0003-opentelemetry-integration/#2-simple-metrics-only","title":"2. Simple Metrics Only","text":"<p>Description: Just collect basic metrics without tracing.</p> <p>Pros:</p> <ul> <li>Simpler to implement</li> <li>Lower overhead</li> <li>Easier to understand</li> </ul> <p>Cons:</p> <ul> <li>No distributed tracing</li> <li>Limited debugging capability</li> <li>Can't see operation flow</li> </ul> <p>Why not chosen: Tracing provides significant value for debugging complex workflows.</p>"},{"location":"adr/0003-opentelemetry-integration/#3-logging-only","title":"3. Logging Only","text":"<p>Description: Continue with structured logging only.</p> <p>Pros:</p> <ul> <li>Already implemented</li> <li>No new dependencies</li> <li>Simple to understand</li> </ul> <p>Cons:</p> <ul> <li>Hard to aggregate</li> <li>No metrics</li> <li>Manual correlation</li> <li>Poor for real-time monitoring</li> </ul> <p>Why not chosen: Current approach, but insufficient for production observability needs.</p>"},{"location":"adr/0003-opentelemetry-integration/#4-third-party-service-integration","title":"4. Third-Party Service Integration","text":"<p>Description: Integrate directly with Datadog, New Relic, etc.</p> <p>Pros:</p> <ul> <li>Turnkey solution</li> <li>Rich features</li> <li>Managed service</li> </ul> <p>Cons:</p> <ul> <li>Vendor lock-in</li> <li>Cost implications</li> <li>Not flexible</li> </ul> <p>Why not chosen: OpenTelemetry allows using any backend, avoiding lock-in.</p>"},{"location":"adr/0003-opentelemetry-integration/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr/0003-opentelemetry-integration/#sprint-1-foundation-complete","title":"Sprint 1: Foundation (Complete)","text":"<ul> <li> Add OpenTelemetry dependencies (optional)</li> <li> Implement basic tracing setup</li> <li> Instrument guard-rails command (API only, integration pending)</li> <li> Add console exporter for testing</li> <li> Document configuration</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#sprint-2-core-instrumentation","title":"Sprint 2: Core Instrumentation","text":"<ul> <li> Instrument all CLI commands</li> <li> Add metrics collection</li> <li> Implement privacy controls</li> <li> Add OTLP exporter support</li> <li> Create example dashboards</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#sprint-3-advanced-features","title":"Sprint 3: Advanced Features","text":"<ul> <li> Implement sampling strategies</li> <li> Add custom metrics for analytics</li> <li> Instrument plugin system</li> <li> Add Prometheus exporter</li> <li> Create monitoring guide</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#sprint-4-production-ready","title":"Sprint 4: Production Ready","text":"<ul> <li> Performance optimization</li> <li> Advanced privacy features</li> <li> Cloud exporter support</li> <li> Telemetry analytics dashboard</li> <li> Usage reports and insights</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Design telemetry architecture</li> <li> Implement basic tracing</li> <li> Add privacy controls</li> <li> Create example dashboards</li> <li> Write observability guide</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#references","title":"References","text":"<ul> <li>OpenTelemetry Documentation</li> <li>OpenTelemetry Python</li> <li>Hephaestus Telemetry Module</li> <li>Privacy Policy (future)</li> <li>Observability Guide (future)</li> </ul>"},{"location":"adr/0003-opentelemetry-integration/#appendix-example-configuration","title":"Appendix: Example Configuration","text":"<pre><code># .hephaestus/telemetry.yaml\ntelemetry:\n  enabled: true\n\n  # Tracing configuration\n  tracing:\n    enabled: true\n    sampler:\n      type: parentbased_traceidratio\n      rate: 0.1 # 10% sampling\n    exporter:\n      type: otlp\n      endpoint: http://localhost:4318\n\n  # Metrics configuration\n  metrics:\n    enabled: true\n    exporter:\n      type: prometheus\n      port: 9090\n\n  # Privacy controls\n  privacy:\n    mode: strict # strict, balanced, minimal\n    anonymize_paths: true\n    anonymize_usernames: true\n    redact_env_vars: true\n    allowed_attributes:\n      - command\n      - exit_code\n      - duration\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#appendix-dashboard-queries","title":"Appendix: Dashboard Queries","text":"<p>Grafana Dashboard Examples:</p> <pre><code># Average guard-rails duration\navg(hephaestus_command_duration_seconds{command=\"guard-rails\"})\n\n# Success rate by command\nsum(rate(hephaestus_commands_executed[5m])) by (command)\n/\nsum(rate(hephaestus_commands_failed[5m])) by (command)\n\n# Quality gate pass rate\nsum(rate(hephaestus_quality_gates_passed[5m]))\n/\n(sum(rate(hephaestus_quality_gates_passed[5m])) + sum(rate(hephaestus_quality_gates_failed[5m])))\n</code></pre>"},{"location":"adr/0003-opentelemetry-integration/#status-history","title":"Status History","text":"<ul> <li>2025-01-11: Proposed (documented in ADR)</li> <li>Future: Accepted/Rejected based on community feedback</li> <li>Future: Implemented in future release</li> </ul>"},{"location":"adr/0004-rest-grpc-api/","title":"ADR 0004: REST/gRPC API for Remote Invocation","text":"<ul> <li>Status: Phase 1 Implemented</li> <li>Date: 2025-01-11</li> <li>Supersedes: N/A</li> <li>Superseded by: N/A</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#context","title":"Context","text":"<p>Hephaestus is currently a command-line tool that runs locally. However, several use cases require remote invocation:</p> <ul> <li>CI/CD Orchestration: Build systems need to invoke Hephaestus programmatically</li> <li>AI Agent Integration: AI assistants need structured API access beyond CLI</li> <li>Centralized Quality Dashboard: Teams want aggregated quality metrics across projects</li> <li>Remote Development: Developers want to trigger quality checks on remote environments</li> <li>Integration Testing: Test frameworks need programmatic access to quality gates</li> <li>Webhook Triggers: External systems want to trigger quality checks on events</li> </ul> <p>Current limitations:</p> <ul> <li>CLI-only interface requires subprocess execution</li> <li>No structured request/response beyond exit codes</li> <li>No real-time progress updates</li> <li>No concurrent execution tracking</li> <li>Difficult to integrate with non-Python systems</li> </ul> <p>The <code>schema</code> command provides structured metadata, but doesn't enable remote execution.</p>"},{"location":"adr/0004-rest-grpc-api/#motivating-use-cases","title":"Motivating Use Cases","text":"<ol> <li>AI Agents: GitHub Copilot wants to invoke <code>guard-rails</code> and get structured results</li> <li>CI Dashboard: Engineering teams want a web dashboard showing quality across all repos</li> <li>Automated Remediation: Systems want to trigger cleanup when disk space is low</li> <li>Code Review Bots: PR bots want to run quality checks and comment results</li> <li>Remote Debugging: Developers want to trigger drift detection on production systems</li> <li>Multi-Repo Workflows: Monorepo tools want to orchestrate quality checks across repos</li> </ol>"},{"location":"adr/0004-rest-grpc-api/#requirements","title":"Requirements","text":"<ul> <li>Backward Compatible: CLI must remain primary interface</li> <li>Stateless: API should not require server-side state</li> <li>Secure: Authentication and authorization required</li> <li>Observable: Integrated with OpenTelemetry (ADR-0003)</li> <li>Async: Support long-running operations with progress tracking</li> <li>Multiple Protocols: Support both REST (HTTP) and gRPC</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#decision","title":"Decision","text":"<p>We will implement dual-protocol API with both REST and gRPC endpoints:</p> <ol> <li>REST API: For web clients, AI agents, and HTTP-based integrations</li> <li>gRPC API: For high-performance, strongly-typed integrations</li> <li>Unified Implementation: Shared business logic with protocol adapters</li> <li>OpenAPI Spec: Machine-readable REST API specification</li> <li>Protocol Buffers: gRPC service definitions</li> </ol>"},{"location":"adr/0004-rest-grpc-api/#architecture","title":"Architecture","text":"<pre><code>hephaestus/\n\u251c\u2500\u2500 src/hephaestus/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 server.py              # API server implementation\n\u2502   \u2502   \u251c\u2500\u2500 rest/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 app.py              # FastAPI application\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 routes/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 quality.py      # Quality gates endpoints\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 cleanup.py      # Cleanup endpoints\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 analytics.py    # Analytics endpoints\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 schema.py       # Schema endpoints\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 models.py           # Pydantic models\n\u2502   \u2502   \u251c\u2500\u2500 grpc/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 server.py           # gRPC server\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 quality.py      # Quality service\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 cleanup.py      # Cleanup service\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 analytics.py    # Analytics service\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 protos/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 hephaestus.proto # Protocol definitions\n\u2502   \u2502   \u251c\u2500\u2500 auth.py                 # Authentication/authorization\n\u2502   \u2502   \u251c\u2500\u2500 middleware.py           # Logging, telemetry, etc.\n\u2502   \u2502   \u2514\u2500\u2500 tasks.py                # Async task management\n\u2502   \u2514\u2500\u2500 cli.py                      # CLI optionally starts API server\n\ndocs/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 openapi.yaml                # OpenAPI 3.0 spec\n\u2502   \u251c\u2500\u2500 rest-examples.md            # REST API examples\n\u2502   \u2514\u2500\u2500 grpc-examples.md            # gRPC examples\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#rest-api-design","title":"REST API Design","text":"<p>Base URL: <code>http://localhost:8000/api/v1</code></p> <p>Core Endpoints:</p> <pre><code>paths:\n  /quality/guard-rails:\n    post:\n      summary: Run comprehensive quality pipeline\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                no_format:\n                  type: boolean\n                workspace:\n                  type: string\n                drift_check:\n                  type: boolean\n      responses:\n        200:\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success: boolean\n                  gates: array\n                  duration: number\n                  task_id: string\n\n  /cleanup:\n    post:\n      summary: Clean workspace artifacts\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                root: string\n                deep_clean: boolean\n                dry_run: boolean\n      responses:\n        200:\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  files_deleted: integer\n                  size_freed: integer\n                  manifest: object\n\n  /analytics/rankings:\n    get:\n      summary: Get refactoring rankings\n      parameters:\n        - name: strategy\n          in: query\n          schema:\n            type: string\n            enum: [risk_weighted, coverage_first, churn_based, composite]\n        - name: limit\n          in: query\n          schema:\n            type: integer\n      responses:\n        200:\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  rankings: array\n                  strategy: string\n\n  /tasks/{task_id}:\n    get:\n      summary: Get async task status\n      responses:\n        200:\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  task_id: string\n                  status: string\n                  progress: number\n                  result: object\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#grpc-service-definition","title":"gRPC Service Definition","text":"<pre><code>syntax = \"proto3\";\n\npackage hephaestus.v1;\n\nservice QualityService {\n  rpc RunGuardRails(GuardRailsRequest) returns (GuardRailsResponse);\n  rpc RunGuardRailsStream(GuardRailsRequest) returns (stream GuardRailsProgress);\n  rpc CheckDrift(DriftRequest) returns (DriftResponse);\n}\n\nservice CleanupService {\n  rpc Clean(CleanupRequest) returns (CleanupResponse);\n  rpc PreviewCleanup(CleanupRequest) returns (CleanupPreview);\n}\n\nservice AnalyticsService {\n  rpc GetRankings(RankingsRequest) returns (RankingsResponse);\n  rpc GetHotspots(HotspotsRequest) returns (HotspotsResponse);\n}\n\nmessage GuardRailsRequest {\n  bool no_format = 1;\n  string workspace = 2;\n  bool drift_check = 3;\n  map&lt;string, string&gt; env = 4;\n}\n\nmessage GuardRailsResponse {\n  bool success = 1;\n  repeated QualityGateResult gates = 2;\n  double duration = 3;\n  string task_id = 4;\n}\n\nmessage GuardRailsProgress {\n  string stage = 1;\n  int32 progress = 2;\n  string message = 3;\n  bool completed = 4;\n}\n\nmessage QualityGateResult {\n  string name = 1;\n  bool passed = 2;\n  string message = 3;\n  double duration = 4;\n  map&lt;string, string&gt; metadata = 5;\n}\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#authentication","title":"Authentication","text":"<pre><code># API Key authentication\nfrom fastapi import Security, HTTPException\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\nsecurity = HTTPBearer()\n\nasync def verify_api_key(credentials: HTTPAuthorizationCredentials = Security(security)):\n    \"\"\"Verify API key from header.\"\"\"\n    api_key = credentials.credentials\n    if not validate_api_key(api_key):\n        raise HTTPException(status_code=403, detail=\"Invalid API key\")\n    return api_key\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#async-task-management","title":"Async Task Management","text":"<pre><code>from uuid import uuid4\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\n@dataclass\nclass Task:\n    id: str\n    status: TaskStatus\n    progress: float\n    result: Any = None\n    error: str = None\n\ntask_registry: dict[str, Task] = {}\n\nasync def run_guard_rails_async(request: GuardRailsRequest) -&gt; str:\n    \"\"\"Run guard-rails asynchronously and return task ID.\"\"\"\n    task_id = str(uuid4())\n    task = Task(id=task_id, status=TaskStatus.PENDING, progress=0.0)\n    task_registry[task_id] = task\n\n    # Start background task\n    asyncio.create_task(_execute_guard_rails(task_id, request))\n\n    return task_id\n\nasync def _execute_guard_rails(task_id: str, request: GuardRailsRequest):\n    \"\"\"Execute guard-rails and update task status.\"\"\"\n    task = task_registry[task_id]\n    task.status = TaskStatus.RUNNING\n\n    try:\n        # Run quality gates\n        result = await run_quality_pipeline(\n            no_format=request.no_format,\n            progress_callback=lambda p: update_task_progress(task_id, p)\n        )\n\n        task.status = TaskStatus.COMPLETED\n        task.progress = 1.0\n        task.result = result\n    except Exception as e:\n        task.status = TaskStatus.FAILED\n        task.error = str(e)\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#streaming-progress","title":"Streaming Progress","text":"<pre><code>@router.get(\"/tasks/{task_id}/stream\")\nasync def stream_task_progress(task_id: str):\n    \"\"\"Stream task progress using Server-Sent Events.\"\"\"\n    async def event_generator():\n        while True:\n            task = task_registry.get(task_id)\n            if not task:\n                yield f\"data: {json.dumps({'error': 'Task not found'})}\\n\\n\"\n                break\n\n            yield f\"data: {json.dumps({\n                'status': task.status.value,\n                'progress': task.progress,\n                'result': task.result if task.status == TaskStatus.COMPLETED else None\n            })}\\n\\n\"\n\n            if task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED]:\n                break\n\n            await asyncio.sleep(1)\n\n    return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#consequences","title":"Consequences","text":""},{"location":"adr/0004-rest-grpc-api/#positive","title":"Positive","text":"<ol> <li>Remote Access: Enable remote invocation from any system</li> <li>AI Integration: Better integration with AI agents and automation</li> <li>Dashboard Support: Enable centralized quality dashboards</li> <li>Language Agnostic: gRPC supports multiple languages</li> <li>Real-time Updates: Streaming progress for long operations</li> <li>Strong Typing: gRPC provides compile-time type safety</li> </ol>"},{"location":"adr/0004-rest-grpc-api/#negative","title":"Negative","text":"<ol> <li>Complexity: Significant architectural complexity</li> <li>Security Surface: New attack surface requiring careful design</li> <li>Maintenance: Need to maintain API contracts and versioning</li> <li>Infrastructure: Requires running server processes</li> <li>Dependencies: Additional framework dependencies (FastAPI, gRPC)</li> <li>Deployment: More complex deployment scenarios</li> </ol>"},{"location":"adr/0004-rest-grpc-api/#risks","title":"Risks","text":"<ul> <li>Security: API keys could be compromised</li> <li>Performance: Network overhead for local operations</li> <li>Availability: Server downtime blocks operations</li> <li>Version Skew: Client/server version mismatches</li> <li>Resource Usage: Server consumes resources</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Security: Strong authentication, HTTPS/TLS, rate limiting</li> <li>Performance: Keep CLI as primary interface for local use</li> <li>Availability: Graceful fallback to CLI mode</li> <li>Versioning: API versioning with deprecation policy</li> <li>Resource Limits: Request timeouts, concurrent job limits</li> </ol>"},{"location":"adr/0004-rest-grpc-api/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/0004-rest-grpc-api/#1-cli-wrapper-only","title":"1. CLI Wrapper Only","text":"<p>Description: Provide language-specific wrappers around CLI.</p> <p>Pros:</p> <ul> <li>Simpler implementation</li> <li>No server needed</li> <li>Backward compatible</li> </ul> <p>Cons:</p> <ul> <li>Subprocess overhead</li> <li>No progress streaming</li> <li>Limited to local execution</li> </ul> <p>Why not chosen: Doesn't solve remote execution or progress tracking.</p>"},{"location":"adr/0004-rest-grpc-api/#2-rest-only","title":"2. REST Only","text":"<p>Description: Implement REST API without gRPC.</p> <p>Pros:</p> <ul> <li>Simpler implementation</li> <li>Universal HTTP support</li> <li>Good web integration</li> </ul> <p>Cons:</p> <ul> <li>Less efficient than gRPC</li> <li>No streaming (without SSE)</li> <li>Less type safety</li> </ul> <p>Why not chosen: gRPC provides better performance and type safety for programmatic clients.</p>"},{"location":"adr/0004-rest-grpc-api/#3-grpc-only","title":"3. gRPC Only","text":"<p>Description: Implement gRPC without REST.</p> <p>Pros:</p> <ul> <li>Best performance</li> <li>Strong typing</li> <li>Built-in streaming</li> </ul> <p>Cons:</p> <ul> <li>Harder HTTP integration</li> <li>Less accessible for web clients</li> <li>More complex debugging</li> </ul> <p>Why not chosen: REST provides better accessibility for web and AI agents.</p>"},{"location":"adr/0004-rest-grpc-api/#4-message-queue","title":"4. Message Queue","text":"<p>Description: Use message broker (RabbitMQ, Redis) for async execution.</p> <p>Pros:</p> <ul> <li>Proven architecture</li> <li>Scalable</li> <li>Decoupled</li> </ul> <p>Cons:</p> <ul> <li>Heavy infrastructure</li> <li>Operational complexity</li> <li>Overkill for use case</li> </ul> <p>Why not chosen: Too complex for initial requirements.</p>"},{"location":"adr/0004-rest-grpc-api/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr/0004-rest-grpc-api/#sprint-1-rest-api-core-complete","title":"Sprint 1: REST API Core (Complete)","text":"<ul> <li> Design OpenAPI specification</li> <li> Implement FastAPI application</li> <li> Add core endpoints (guard-rails, cleanup)</li> <li> Implement authentication</li> <li> Write API tests</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#sprint-2-async-progress","title":"Sprint 2: Async &amp; Progress","text":"<ul> <li> Implement async task management</li> <li> Add progress streaming (SSE)</li> <li> Add task status endpoints</li> <li> Implement timeouts and limits</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#sprint-3-grpc-service","title":"Sprint 3: gRPC Service","text":"<ul> <li> Define protocol buffers</li> <li> Implement gRPC server</li> <li> Add streaming RPCs</li> <li> Create gRPC client examples</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#sprint-4-production-ready","title":"Sprint 4: Production Ready","text":"<ul> <li> Add comprehensive security</li> <li> Implement rate limiting</li> <li> Add API versioning</li> <li> Create deployment guides</li> <li> Build API client libraries</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Design OpenAPI specification</li> <li> Implement REST API core</li> <li> Add authentication and security</li> <li> Implement async task management</li> <li> Design gRPC protocol buffers</li> <li> Implement gRPC service</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#references","title":"References","text":"<ul> <li>FastAPI Documentation</li> <li>gRPC Python</li> <li>OpenAPI Specification</li> <li>API Security Best Practices</li> <li>Hephaestus Schema Module</li> </ul>"},{"location":"adr/0004-rest-grpc-api/#appendix-example-api-usage","title":"Appendix: Example API Usage","text":""},{"location":"adr/0004-rest-grpc-api/#rest-api-python","title":"REST API (Python)","text":"<pre><code>import requests\n\n# Start guard-rails asynchronously\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/quality/guard-rails\",\n    headers={\"Authorization\": \"Bearer YOUR_API_KEY\"},\n    json={\"no_format\": False, \"drift_check\": True}\n)\n\ntask_id = response.json()[\"task_id\"]\n\n# Poll for status\nwhile True:\n    status = requests.get(\n        f\"http://localhost:8000/api/v1/tasks/{task_id}\",\n        headers={\"Authorization\": \"Bearer YOUR_API_KEY\"}\n    ).json()\n\n    if status[\"status\"] in [\"completed\", \"failed\"]:\n        break\n\n    print(f\"Progress: {status['progress']*100}%\")\n    time.sleep(2)\n\nprint(f\"Result: {status['result']}\")\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#grpc-python","title":"gRPC (Python)","text":"<pre><code>import grpc\nfrom hephaestus.v1 import quality_pb2, quality_pb2_grpc\n\n# Create channel\nchannel = grpc.insecure_channel('localhost:50051')\nstub = quality_pb2_grpc.QualityServiceStub(channel)\n\n# Call with streaming progress\nrequest = quality_pb2.GuardRailsRequest(\n    no_format=False,\n    drift_check=True\n)\n\nfor progress in stub.RunGuardRailsStream(request):\n    print(f\"{progress.stage}: {progress.progress}% - {progress.message}\")\n    if progress.completed:\n        break\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#curl-rest","title":"cURL (REST)","text":"<pre><code># Start guard-rails\ncurl -X POST http://localhost:8000/api/v1/quality/guard-rails \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"no_format\": false, \"drift_check\": true}'\n\n# Get task status\ncurl http://localhost:8000/api/v1/tasks/TASK_ID \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre>"},{"location":"adr/0004-rest-grpc-api/#status-history","title":"Status History","text":"<ul> <li>2025-01-11: Proposed (documented in ADR)</li> <li>Future: Accepted/Rejected based on community feedback</li> <li>Future: Implemented in future release</li> </ul>"},{"location":"adr/0005-pypi-publication/","title":"ADR 0005: PyPI Publication Automation","text":"<ul> <li>Status: Proposed</li> <li>Date: 2025-01-15</li> <li>Supersedes: N/A</li> <li>Superseded by: N/A</li> </ul>"},{"location":"adr/0005-pypi-publication/#context","title":"Context","text":"<p>Hephaestus currently distributes pre-built wheelhouses via GitHub Releases with SHA-256 checksums and Sigstore attestation. However, there is no automated publication to the Python Package Index (PyPI), which limits discoverability and adoption for users who prefer standard Python packaging workflows.</p> <p>Current distribution mechanism:</p> <ul> <li>GitHub Releases with wheelhouse archives (<code>.tar.gz</code> with embedded wheels)</li> <li>SHA-256 checksum manifests for verification</li> <li>Sigstore bundle attestation for supply chain security</li> <li>Manual installation via <code>hephaestus release install</code></li> </ul> <p>Limitations of current approach:</p> <ul> <li>Not discoverable via <code>pip search</code> or PyPI website</li> <li>Requires custom installation commands</li> <li>No integration with standard dependency managers (pip, poetry, uv)</li> <li>Limited visibility in Python ecosystem</li> <li>Manual version management for users</li> </ul>"},{"location":"adr/0005-pypi-publication/#motivating-use-cases","title":"Motivating Use Cases","text":"<ol> <li>Standard Installation: Users want <code>pip install hephaestus</code> instead of custom commands</li> <li>Dependency Management: Projects want to add Hephaestus to <code>requirements.txt</code> or <code>pyproject.toml</code></li> <li>Discoverability: New users should find Hephaestus via PyPI search</li> <li>Version Constraints: Dependency managers need semantic versioning support</li> <li>CI/CD Integration: Automated pipelines need standard package resolution</li> <li>Ecosystem Integration: Tools like Dependabot should track Hephaestus updates</li> </ol>"},{"location":"adr/0005-pypi-publication/#requirements","title":"Requirements","text":"<ul> <li>Security: Maintain current security posture (checksums, attestation)</li> <li>Automation: Fully automated publication on release</li> <li>Reliability: Fail-safe publication with rollback capability</li> <li>Backward Compatibility: Maintain GitHub Releases for wheelhouse distribution</li> <li>Metadata: Rich PyPI metadata (classifiers, keywords, links)</li> <li>Provenance: PyPI Trusted Publishers for secure authentication</li> </ul>"},{"location":"adr/0005-pypi-publication/#decision","title":"Decision","text":"<p>We will implement automated PyPI publication using GitHub Actions and PyPI Trusted Publishers:</p> <ol> <li>Dual Distribution: Maintain both PyPI packages and GitHub Releases wheelhouses</li> <li>Trusted Publishers: Use PyPI's OIDC authentication (no API tokens)</li> <li>Automated Release: Publish to PyPI on every GitHub Release</li> <li>Sigstore Attestation: Sign packages with Sigstore before upload</li> <li>Rich Metadata: Comprehensive <code>pyproject.toml</code> with classifiers and links</li> <li>Test PyPI: Pre-release validation via Test PyPI</li> </ol>"},{"location":"adr/0005-pypi-publication/#architecture","title":"Architecture","text":"<pre><code>Release Workflow:\n1. Version bump in pyproject.toml triggers release\n2. GitHub Actions builds wheel and sdist\n3. Sign with Sigstore\n4. Upload to Test PyPI (for pre-releases)\n5. Upload to PyPI (for stable releases)\n6. Create GitHub Release with wheelhouse\n7. Attach checksums and Sigstore bundles\n</code></pre>"},{"location":"adr/0005-pypi-publication/#pypi-package-metadata","title":"PyPI Package Metadata","text":"<pre><code>[project]\nname = \"hephaestus-toolkit\"\nversion = \"0.2.5\"\ndescription = \"Developer toolkit for code quality, refactoring, and release automation\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.9\"\nlicense = {text = \"MIT\"}\nauthors = [\n    {name = \"Hephaestus Contributors\", email = \"security@hephaestus.dev\"}\n]\nkeywords = [\n    \"quality-gates\",\n    \"refactoring\",\n    \"cleanup\",\n    \"release-automation\",\n    \"developer-tools\",\n    \"ci-cd\"\n]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"Topic :: Software Development :: Quality Assurance\",\n    \"Topic :: Software Development :: Testing\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\n\n[project.urls]\nHomepage = \"https://github.com/IAmJonoBo/Hephaestus\"\nDocumentation = \"https://iamjonobo.github.io/Hephaestus/\"\nRepository = \"https://github.com/IAmJonoBo/Hephaestus\"\nIssues = \"https://github.com/IAmJonoBo/Hephaestus/issues\"\nChangelog = \"https://github.com/IAmJonoBo/Hephaestus/blob/main/CHANGELOG.md\"\nSecurity = \"https://github.com/IAmJonoBo/Hephaestus/blob/main/SECURITY.md\"\n\n[project.scripts]\nhephaestus = \"hephaestus.cli:app\"\n</code></pre>"},{"location":"adr/0005-pypi-publication/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>name: Publish to PyPI\n\non:\n  release:\n    types: [published]\n\npermissions:\n  id-token: write # Required for PyPI Trusted Publishers\n  contents: write\n\njobs:\n  publish:\n    name: Publish to PyPI\n    runs-on: ubuntu-latest\n    environment:\n      name: pypi\n      url: https://pypi.org/p/hephaestus-toolkit\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.12\"\n\n      - name: Install build dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install build twine sigstore\n\n      - name: Build distribution\n        run: python -m build\n\n      - name: Sign with Sigstore\n        run: |\n          python -m sigstore sign dist/*\n\n      - name: Verify distribution\n        run: |\n          twine check dist/*\n\n      - name: Publish to Test PyPI (pre-releases)\n        if: github.event.release.prerelease\n        uses: pypa/gh-action-pypi-publish@release/v1\n        with:\n          repository-url: https://test.pypi.org/legacy/\n\n      - name: Publish to PyPI (stable)\n        if: \"!github.event.release.prerelease\"\n        uses: pypa/gh-action-pypi-publish@release/v1\n\n      - name: Attach Sigstore bundles to release\n        uses: actions/upload-release-asset@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ github.event.release.upload_url }}\n          asset_path: dist/*.sigstore\n          asset_name: sigstore-bundles.tar.gz\n          asset_content_type: application/gzip\n</code></pre>"},{"location":"adr/0005-pypi-publication/#security-model","title":"Security Model","text":"<ol> <li>Trusted Publishers: No API tokens stored in GitHub</li> <li>OIDC Authentication: GitHub verifies repository identity</li> <li>Sigstore Attestation: Packages signed before upload</li> <li>Checksum Verification: SHA-256 hashes published</li> <li>Two-Factor Auth: PyPI account secured with 2FA</li> <li>Provenance: Full supply chain transparency</li> </ol>"},{"location":"adr/0005-pypi-publication/#installation-methods","title":"Installation Methods","text":"<p>After PyPI publication, users can install via:</p> <pre><code># Standard pip installation\npip install hephaestus-toolkit\n\n# With extras\npip install hephaestus-toolkit[dev,qa]\n\n# Specific version\npip install hephaestus-toolkit==0.2.5\n\n# Development version from GitHub\npip install git+https://github.com/IAmJonoBo/Hephaestus.git\n\n# Wheelhouse (existing method)\nhephaestus release install --repository IAmJonoBo/Hephaestus\n</code></pre>"},{"location":"adr/0005-pypi-publication/#consequences","title":"Consequences","text":""},{"location":"adr/0005-pypi-publication/#positive","title":"Positive","text":"<ol> <li>Discoverability: Visible on PyPI with search and rankings</li> <li>Standard Installation: Users can use familiar <code>pip install</code> commands</li> <li>Dependency Management: Works with all Python dependency managers</li> <li>Ecosystem Integration: Dependabot, Renovate, and other tools work automatically</li> <li>Version Constraints: Semantic versioning support in dependencies</li> <li>Documentation: PyPI page provides project overview and links</li> <li>Trust Signals: PyPI verified publishers badge</li> <li>Download Metrics: PyPI analytics for adoption tracking</li> </ol>"},{"location":"adr/0005-pypi-publication/#negative","title":"Negative","text":"<ol> <li>Maintenance Burden: Additional release workflow to maintain</li> <li>PyPI Account: Requires PyPI account management</li> <li>Namespace Conflict: <code>hephaestus</code> name may be taken, requiring <code>hephaestus-toolkit</code></li> <li>Upload Failures: Network or PyPI issues could block releases</li> <li>Documentation Split: Need to document both installation methods</li> <li>Breaking Changes: PyPI packages require careful version management</li> </ol>"},{"location":"adr/0005-pypi-publication/#risks","title":"Risks","text":"<ul> <li>Name Squatting: Package name may already be registered</li> <li>Upload Failures: PyPI outages could block releases</li> <li>Metadata Errors: Incorrect classifiers or descriptions</li> <li>Version Conflicts: Mismatched versions between PyPI and GitHub</li> <li>Account Compromise: PyPI account security is critical</li> </ul>"},{"location":"adr/0005-pypi-publication/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Name Selection: Register name early, use <code>hephaestus-toolkit</code> if needed</li> <li>Failure Handling: Continue GitHub Release even if PyPI fails</li> <li>Pre-release Testing: Always test via Test PyPI first</li> <li>Version Sync: Automated version bumping in CI</li> <li>Account Security: 2FA, recovery codes, and Trusted Publishers only</li> <li>Rollback Plan: Document PyPI package yanking procedure</li> </ol>"},{"location":"adr/0005-pypi-publication/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/0005-pypi-publication/#1-github-releases-only","title":"1. GitHub Releases Only","text":"<p>Description: Continue current approach with wheelhouses only.</p> <p>Pros:</p> <ul> <li>No additional maintenance</li> <li>Full control over distribution</li> <li>Already working well</li> </ul> <p>Cons:</p> <ul> <li>Limited discoverability</li> <li>Non-standard installation</li> <li>No ecosystem integration</li> </ul> <p>Why not chosen: Limits adoption and violates Python ecosystem conventions.</p>"},{"location":"adr/0005-pypi-publication/#2-conda-packages","title":"2. Conda Packages","text":"<p>Description: Publish to conda-forge instead of PyPI.</p> <p>Pros:</p> <ul> <li>Better for scientific computing</li> <li>Handles non-Python dependencies</li> <li>conda-forge provides infrastructure</li> </ul> <p>Cons:</p> <ul> <li>Limited to Conda ecosystem</li> <li>Additional packaging complexity</li> <li>Most Python developers use pip</li> </ul> <p>Why not chosen: PyPI is more universal, Conda can be added later.</p>"},{"location":"adr/0005-pypi-publication/#3-docker-images","title":"3. Docker Images","text":"<p>Description: Distribute as Docker containers.</p> <p>Pros:</p> <ul> <li>Includes all dependencies</li> <li>Consistent environment</li> <li>Easy CI/CD integration</li> </ul> <p>Cons:</p> <ul> <li>Heavy distribution mechanism</li> <li>Not suitable for library use</li> <li>Limits integration options</li> </ul> <p>Why not chosen: Hephaestus is a library/CLI, not a service.</p>"},{"location":"adr/0005-pypi-publication/#4-manual-pypi-upload","title":"4. Manual PyPI Upload","text":"<p>Description: Manually upload packages to PyPI on release.</p> <p>Pros:</p> <ul> <li>Simple to start</li> <li>Full control over process</li> <li>No CI/CD complexity</li> </ul> <p>Cons:</p> <ul> <li>Error-prone</li> <li>Slow</li> <li>Not scalable</li> <li>Human bottleneck</li> </ul> <p>Why not chosen: Automation is critical for reliable releases.</p>"},{"location":"adr/0005-pypi-publication/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr/0005-pypi-publication/#sprint-1-preparation","title":"Sprint 1: Preparation","text":"<ul> <li> Verify PyPI package name availability</li> <li> Update <code>pyproject.toml</code> with rich metadata</li> <li> Register PyPI account and configure 2FA</li> <li> Set up Trusted Publishers on PyPI</li> <li> Create Test PyPI account for testing</li> </ul>"},{"location":"adr/0005-pypi-publication/#sprint-2-automation","title":"Sprint 2: Automation","text":"<ul> <li> Create PyPI publication workflow</li> <li> Add Sigstore signing to workflow</li> <li> Test publication to Test PyPI</li> <li> Update documentation with pip installation</li> <li> Add PyPI badge to README</li> </ul>"},{"location":"adr/0005-pypi-publication/#sprint-3-launch","title":"Sprint 3: Launch","text":"<ul> <li> Publish first stable release to PyPI</li> <li> Announce on GitHub, social media</li> <li> Update installation instructions</li> <li> Monitor PyPI analytics</li> <li> Gather user feedback</li> </ul>"},{"location":"adr/0005-pypi-publication/#sprint-4-optimization","title":"Sprint 4: Optimization","text":"<ul> <li> Add PyPI download metrics to dashboards</li> <li> Implement automated version bumping</li> <li> Create release notes automation</li> <li> Set up Dependabot for downstream projects</li> <li> Optimize package size and dependencies</li> </ul>"},{"location":"adr/0005-pypi-publication/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Register PyPI package name</li> <li> Configure Trusted Publishers</li> <li> Implement publication workflow</li> <li> Test publication to Test PyPI</li> <li> Launch first PyPI release</li> <li> Update all documentation</li> </ul>"},{"location":"adr/0005-pypi-publication/#references","title":"References","text":"<ul> <li>PyPI Trusted Publishers Guide</li> <li>Python Packaging User Guide</li> <li>Sigstore Python</li> <li>GitHub Actions PyPI Publish</li> <li>PEP 621 - pyproject.toml Metadata</li> </ul>"},{"location":"adr/0005-pypi-publication/#appendix-package-verification","title":"Appendix: Package Verification","text":"<p>Users can verify published packages:</p> <pre><code># Download and verify with pip\npip download --no-deps hephaestus-toolkit\npip verify hephaestus-toolkit\n\n# Verify Sigstore signature\nsigstore verify dist/hephaestus_toolkit-*.whl\n\n# Check PyPI metadata\npip show hephaestus-toolkit\n\n# View package contents\nwheel unpack hephaestus_toolkit-*.whl\n</code></pre>"},{"location":"adr/0005-pypi-publication/#status-history","title":"Status History","text":"<ul> <li>2025-01-15: Proposed (documented in ADR)</li> <li>Future: Accepted after name registration and Trusted Publishers setup</li> <li>Future: Implemented in next release</li> </ul>"},{"location":"adr/0006-sigstore-backfill/","title":"ADR 0006: Sigstore Bundle Backfill for Historical Releases","text":"<ul> <li>Status: Phase 1 Implemented</li> <li>Date: 2025-01-15</li> <li>Supersedes: N/A</li> <li>Superseded by: N/A</li> <li>Related: ADR-0001 (STRIDE Threat Model)</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#context","title":"Context","text":"<p>Hephaestus currently supports Sigstore attestation verification for wheelhouse installs, providing cryptographic proof of provenance and supply chain security. However, historical releases (prior to Sigstore implementation) lack these attestation bundles.</p> <p>Current state:</p> <ul> <li>New releases (v0.2.4+): Include Sigstore bundles with attestations</li> <li>Historical releases (v0.1.0-v0.2.3): No Sigstore bundles available</li> <li>Verification: Optional via <code>--require-sigstore</code> flag</li> <li>Identity pinning: Supported via <code>--sigstore-identity</code> flag</li> </ul> <p>The Red Team findings identify this as a high-priority gap:</p> <p>\"Supply-chain compromise risk narrows to unsigned archives and unpinned identities. Backfill Sigstore bundles for historical releases, require identities via <code>--sigstore-identity</code>, and enable <code>--require-sigstore</code> in automation to block unsigned installs.\"</p>"},{"location":"adr/0006-sigstore-backfill/#motivating-requirements","title":"Motivating Requirements","text":"<ol> <li>Supply Chain Security: Historical releases should have same security guarantees as new ones</li> <li>Audit Compliance: Organizations need complete provenance for all installed versions</li> <li>Zero-Trust Automation: CI/CD pipelines should enforce attestation verification</li> <li>Version Flexibility: Users should be able to safely install any historical version</li> <li>Rollback Safety: Emergency rollbacks to older versions should maintain security posture</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#current-limitations","title":"Current Limitations","text":"<ul> <li>Users installing historical versions via <code>hephaestus release install</code> cannot verify provenance</li> <li>Automated pipelines cannot enforce <code>--require-sigstore</code> if supporting older versions</li> <li>Audit tools cannot verify the complete supply chain for deployed versions</li> <li>Rollback procedures lack cryptographic verification</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#technical-challenges","title":"Technical Challenges","text":"<ol> <li>Retroactive Signing: Historical artifacts cannot be signed with current keys</li> <li>Timestamp Integrity: Backdating signatures violates transparency logs</li> <li>Trust Chain: How to establish trust for retroactive attestations</li> <li>Archive Immutability: GitHub release assets should not be modified post-publication</li> <li>Rekor Transparency: Sigstore Rekor log requires valid timestamps</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#decision","title":"Decision","text":"<p>We will implement a transparent backfill strategy that creates Sigstore attestations for historical releases without modifying original archives:</p> <ol> <li>Separate Attestation Assets: Publish <code>.sigstore</code> bundles as additional release assets</li> <li>Verification Policy: Document that backfilled attestations use current signing identity</li> <li>Transparency Metadata: Include backfill metadata (original release date, backfill date)</li> <li>Optional Verification: Users can verify backfilled bundles but enforcement remains optional</li> <li>CI Enforcement: New releases require Sigstore; historical backfills improve security but don't block</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#architecture","title":"Architecture","text":"<pre><code>Historical Release Backfill Process:\n1. Enumerate all historical releases (v0.1.0-v0.2.3)\n2. Download existing wheelhouse archives\n3. Verify SHA-256 checksums match published manifests\n4. Generate Sigstore attestations using current signing identity\n5. Add backfill metadata to attestation\n6. Upload .sigstore bundles as new release assets\n7. Update release notes with backfill notice\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#backfill-metadata-format","title":"Backfill Metadata Format","text":"<pre><code>{\n  \"version\": \"v0.2.3\",\n  \"original_release_date\": \"2025-01-10T12:00:00Z\",\n  \"backfill_date\": \"2025-01-20T15:30:00Z\",\n  \"backfill_identity\": \"https://github.com/IAmJonoBo/Hephaestus/.github/workflows/release.yml@refs/heads/main\",\n  \"verification_status\": \"backfilled\",\n  \"checksum_verified\": true,\n  \"notes\": \"Sigstore bundle backfilled for historical release. Original archive verified against published SHA-256 checksum.\"\n}\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#verification-workflow","title":"Verification Workflow","text":"<pre><code># Future enhancement to release.py\ndef verify_wheelhouse_with_backfill(\n    archive_path: Path,\n    sigstore_bundle: Path,\n    require_original: bool = False\n) -&gt; VerificationResult:\n    \"\"\"Verify wheelhouse with support for backfilled bundles.\"\"\"\n\n    # Load bundle and check for backfill metadata\n    bundle = load_sigstore_bundle(sigstore_bundle)\n    metadata = bundle.get(\"backfill_metadata\", {})\n\n    if metadata and require_original:\n        raise VerificationError(\n            \"Release uses backfilled Sigstore bundle. \"\n            \"Use --allow-backfill to accept retroactive attestations.\"\n        )\n\n    # Verify checksum first\n    if not verify_checksum(archive_path, bundle[\"checksum\"]):\n        raise VerificationError(\"Checksum mismatch\")\n\n    # Verify Sigstore signature\n    verify_sigstore(archive_path, sigstore_bundle)\n\n    # Log backfill status\n    if metadata:\n        logger.info(\n            f\"Verified backfilled bundle: \"\n            f\"Original release {metadata['original_release_date']}, \"\n            f\"Backfilled {metadata['backfill_date']}\"\n        )\n\n    return VerificationResult(\n        verified=True,\n        backfilled=bool(metadata),\n        identity=bundle[\"identity\"]\n    )\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#cli-flags","title":"CLI Flags","text":"<pre><code># Install with backfill verification\nhephaestus release install --require-sigstore --allow-backfill\n\n# Reject backfilled bundles (only accept original attestations)\nhephaestus release install --require-sigstore --no-backfill\n\n# Default behavior (accepts backfilled and original)\nhephaestus release install --require-sigstore\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#automation-script","title":"Automation Script","text":"<pre><code># scripts/backfill_sigstore_bundles.py\n\"\"\"Backfill Sigstore bundles for historical releases.\"\"\"\n\nimport requests\nimport subprocess\nfrom pathlib import Path\nfrom datetime import datetime\n\nREPO = \"IAmJonoBo/Hephaestus\"\nHISTORICAL_VERSIONS = [\n    \"v0.1.0\", \"v0.1.1\", \"v0.1.2\",\n    \"v0.2.0\", \"v0.2.1\", \"v0.2.2\", \"v0.2.3\"\n]\n\ndef backfill_release(version: str, token: str):\n    \"\"\"Backfill Sigstore bundle for a historical release.\"\"\"\n    print(f\"Processing {version}...\")\n\n    # Get release metadata\n    release = get_release_by_tag(REPO, version, token)\n\n    # Find wheelhouse asset\n    wheelhouse = next(\n        asset for asset in release[\"assets\"]\n        if asset[\"name\"].endswith(\".tar.gz\")\n    )\n\n    # Download archive\n    archive_path = download_asset(wheelhouse[\"url\"], token)\n\n    # Verify checksum against published manifest\n    checksum = get_published_checksum(release, wheelhouse[\"name\"])\n    if not verify_checksum(archive_path, checksum):\n        raise ValueError(f\"Checksum mismatch for {version}\")\n\n    # Generate Sigstore bundle\n    bundle_path = sign_with_sigstore(archive_path)\n\n    # Add backfill metadata\n    add_backfill_metadata(\n        bundle_path,\n        version=version,\n        original_date=release[\"published_at\"],\n        backfill_date=datetime.utcnow().isoformat()\n    )\n\n    # Upload bundle as release asset\n    upload_release_asset(\n        release[\"upload_url\"],\n        bundle_path,\n        f\"{wheelhouse['name']}.sigstore\",\n        token\n    )\n\n    # Update release notes\n    add_backfill_notice(release[\"id\"], version, token)\n\n    print(f\"\u2713 Backfilled {version}\")\n\ndef main():\n    token = os.getenv(\"GITHUB_TOKEN\")\n    for version in HISTORICAL_VERSIONS:\n        try:\n            backfill_release(version, token)\n        except Exception as e:\n            print(f\"\u2717 Failed to backfill {version}: {e}\")\n            continue\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#consequences","title":"Consequences","text":""},{"location":"adr/0006-sigstore-backfill/#positive","title":"Positive","text":"<ol> <li>Improved Security Posture: All releases have cryptographic attestation</li> <li>Audit Compliance: Complete provenance chain for audit requirements</li> <li>CI/CD Enforcement: Pipelines can enforce <code>--require-sigstore</code> for all versions</li> <li>Rollback Safety: Emergency rollbacks maintain security guarantees</li> <li>Transparency: Clear metadata distinguishes backfilled from original attestations</li> <li>Non-Breaking: Users without verification enabled are unaffected</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#negative","title":"Negative","text":"<ol> <li>Retroactive Trust: Backfilled attestations don't prove historical provenance</li> <li>Timestamp Discrepancy: Signing timestamp differs from release timestamp</li> <li>Maintenance Effort: Requires one-time backfill operation</li> <li>Documentation Burden: Need to explain backfill vs. original attestations</li> <li>Verification Complexity: Additional logic for handling backfilled bundles</li> <li>Transparency Log: Rekor entries show current timestamp, not original date</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#risks","title":"Risks","text":"<ul> <li>False Security: Users might not understand difference between backfilled and original</li> <li>Key Compromise: If current signing key is compromised, backfilled bundles are invalid</li> <li>Rekor Rejection: Transparency log might reject retroactive timestamps</li> <li>Archive Tampering: Original archives could have been modified before backfill</li> <li>Policy Confusion: Organizations might incorrectly trust backfilled attestations</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Clear Documentation: Explain limitations of backfilled attestations</li> <li>Metadata Transparency: Include backfill metadata in all bundles</li> <li>Checksum Verification: Always verify against published SHA-256 first</li> <li>Policy Flags: Allow organizations to reject backfilled bundles</li> <li>Audit Trail: Log all backfill operations with timestamps</li> <li>Release Notes: Add backfill notices to historical releases</li> </ol>"},{"location":"adr/0006-sigstore-backfill/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/0006-sigstore-backfill/#1-no-backfill-status-quo","title":"1. No Backfill (Status Quo)","text":"<p>Description: Accept that historical releases lack Sigstore attestation.</p> <p>Pros:</p> <ul> <li>No effort required</li> <li>No retroactive trust concerns</li> <li>Clear distinction between old and new</li> </ul> <p>Cons:</p> <ul> <li>Security gap remains</li> <li>Can't enforce verification on all versions</li> <li>Audit compliance issues</li> <li>Rollback safety concerns</li> </ul> <p>Why not chosen: Security gap is unacceptable per Red Team findings.</p>"},{"location":"adr/0006-sigstore-backfill/#2-re-release-historical-versions","title":"2. Re-release Historical Versions","text":"<p>Description: Create new releases with same code but new attestations.</p> <p>Pros:</p> <ul> <li>Attestations use correct timestamps</li> <li>Clear provenance chain</li> <li>No retroactive trust issues</li> </ul> <p>Cons:</p> <ul> <li>Version confusion (v0.2.3 vs v0.2.3-resigned)</li> <li>Breaks semantic versioning</li> <li>Confuses users and tools</li> <li>Duplicate release entries</li> </ul> <p>Why not chosen: Causes version management chaos and breaks conventions.</p>"},{"location":"adr/0006-sigstore-backfill/#3-detached-signature-repository","title":"3. Detached Signature Repository","text":"<p>Description: Maintain separate repository with Sigstore bundles.</p> <p>Pros:</p> <ul> <li>Doesn't modify original releases</li> <li>Clear separation of concerns</li> <li>Easier to update signatures</li> </ul> <p>Cons:</p> <ul> <li>Complex discovery mechanism</li> <li>Additional infrastructure</li> <li>Synchronization challenges</li> <li>Users might not find bundles</li> </ul> <p>Why not chosen: Increases complexity and reduces discoverability.</p>"},{"location":"adr/0006-sigstore-backfill/#4-in-place-modification","title":"4. In-Place Modification","text":"<p>Description: Modify existing release assets to include Sigstore bundles.</p> <p>Pros:</p> <ul> <li>Single source of truth</li> <li>No separate assets</li> <li>Simpler verification</li> </ul> <p>Cons:</p> <ul> <li>Violates archive immutability</li> <li>Changes release checksums</li> <li>Breaks existing installations</li> <li>Loses historical accuracy</li> </ul> <p>Why not chosen: Violates immutability principles and breaks existing users.</p>"},{"location":"adr/0006-sigstore-backfill/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr/0006-sigstore-backfill/#sprint-1-preparation-complete","title":"Sprint 1: Preparation (Complete)","text":"<ul> <li> Review historical releases (v0.1.0-v0.2.3)</li> <li> Verify all releases have SHA-256 checksums</li> <li> Design backfill metadata schema</li> <li> Write backfill automation script</li> <li> Test backfill process on staging</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#sprint-2-execution","title":"Sprint 2: Execution","text":"<ul> <li> Run backfill script for all historical releases</li> <li> Verify uploaded bundles</li> <li> Update release notes with backfill notices</li> <li> Update documentation to explain backfilled attestations</li> <li> Test verification with backfilled bundles</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#sprint-3-enforcement","title":"Sprint 3: Enforcement","text":"<ul> <li> Add <code>--allow-backfill</code> and <code>--no-backfill</code> CLI flags</li> <li> Update verification logic to handle backfilled bundles</li> <li> Write tests for backfill verification</li> <li> Update CI/CD documentation</li> <li> Announce backfill completion</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#sprint-4-documentation","title":"Sprint 4: Documentation","text":"<ul> <li> Update SECURITY.md with backfill policy</li> <li> Add backfill section to Operating Safely guide</li> <li> Create FAQ for backfilled attestations</li> <li> Update audit compliance documentation</li> <li> Announce in CHANGELOG</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#follow-up-actions","title":"Follow-up Actions","text":"<ul> <li> Design backfill metadata schema</li> <li> Implement backfill automation script</li> <li> Execute backfill for historical releases</li> <li> Add verification flags to CLI</li> <li> Update documentation and announce completion</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#references","title":"References","text":"<ul> <li>Sigstore Documentation</li> <li>Rekor Transparency Log</li> <li>ADR-0001: STRIDE Threat Model</li> <li>SECURITY.md</li> <li>Operating Safely Guide</li> </ul>"},{"location":"adr/0006-sigstore-backfill/#appendix-backfill-verification-example","title":"Appendix: Backfill Verification Example","text":"<pre><code># Install historical release with backfilled verification\n$ hephaestus release install \\\n    --repository IAmJonoBo/Hephaestus \\\n    --tag v0.2.3 \\\n    --require-sigstore \\\n    --allow-backfill\n\nINFO: Downloading release v0.2.3...\nINFO: Verifying SHA-256 checksum... \u2713\nINFO: Verifying Sigstore bundle... \u2713\nWARN: Sigstore bundle is backfilled (original: 2025-01-10, backfilled: 2025-01-20)\nINFO: Identity: https://github.com/IAmJonoBo/Hephaestus/.github/workflows/release.yml@refs/heads/main\nINFO: Installation complete\n\n# Reject backfilled bundles\n$ hephaestus release install \\\n    --repository IAmJonoBo/Hephaestus \\\n    --tag v0.2.3 \\\n    --require-sigstore \\\n    --no-backfill\n\nERROR: Release v0.2.3 uses backfilled Sigstore bundle\nERROR: Use --allow-backfill to accept retroactive attestations\n</code></pre>"},{"location":"adr/0006-sigstore-backfill/#status-history","title":"Status History","text":"<ul> <li>2025-01-15: Proposed (documented in ADR)</li> <li>Future: Accepted after backfill metadata schema review</li> <li>Future: Implemented in next release</li> </ul>"},{"location":"explanation/architecture/","title":"Architecture Overview","text":"<p>Hephaestus packages a set of CLI workflows, automation helpers, and refactoring scripts that can be adopted project by project. The repository is organised to reflect the separation between the Python package (distributed as wheels) and the supporting toolkit assets.</p>"},{"location":"explanation/architecture/#high-level-components","title":"High-Level Components","text":"Component Purpose <code>src/hephaestus/</code> Python package containing the Typer CLI, release helpers, planning utilities, and API. <code>hephaestus-toolkit/refactoring/</code> Scripts, configuration, and docs for advisory refactoring workflows. <code>.github/workflows/</code> CI and release automation, including the Build Wheelhouse pipeline. <code>docs/</code> Di\u00e1taxis-aligned documentation published via MkDocs. <code>tests/</code> Pytest suite covering CLI behaviours, release helpers, planning logic, and cleanup."},{"location":"explanation/architecture/#package-layout","title":"Package Layout","text":"<p>The <code>src/hephaestus/</code> directory is structured as a standard Python package:</p> <ul> <li><code>cli.py</code>: Typer entrypoint exposing <code>cleanup</code>, <code>plan</code>, <code>tools</code>, and <code>release</code> commands.</li> <li><code>cleanup.py</code>: Workspace hygiene engine used by both the CLI and automation scripts.</li> <li><code>release.py</code>: Functions for downloading, validating, and installing wheelhouse archives.</li> <li><code>planning.py</code>: Utilities that build execution plans for refactoring rollouts.</li> <li><code>toolbox.py</code>: Data models and helper functions consumed by CLI subcommands and scripts.</li> <li><code>events.py</code>: Telemetry event definitions for structured logging.</li> <li><code>backfill.py</code>: Sigstore backfill metadata schema for historical releases (ADR-0006).</li> </ul>"},{"location":"explanation/architecture/#new-modules-phase-1-implementations","title":"New Modules (Phase 1 Implementations)","text":"<ul> <li><code>telemetry/</code>: OpenTelemetry integration for optional distributed tracing (ADR-0003).</li> <li><code>plugins/</code>: Plugin architecture for extensible quality gates (ADR-0002).</li> <li><code>api/</code>: REST/gRPC API module structure for remote invocation (ADR-0004).</li> </ul> <p>All CLI commands run through the same console abstraction (<code>rich.Console</code>) to ensure consistent colourised output across shells and CI environments.</p>"},{"location":"explanation/architecture/#distribution-artefacts","title":"Distribution Artefacts","text":"<p>The release workflow produces a wheelhouse archive consisting of:</p> <ul> <li>Wheels and source distributions built with <code>uv build</code></li> <li>A manifest recording the version and build metadata</li> </ul> <p>These artefacts live outside the repository (as GitHub Release assets) but follow a predictable naming convention (<code>*wheelhouse*.tar.gz</code>). Consumers install them with <code>hephaestus release install</code> without needing PyPI access.</p>"},{"location":"explanation/architecture/#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>Python 3.12+</li> <li><code>typer</code>, <code>rich</code>, and <code>pytest</code> for CLI and testing</li> <li>Standard library networking modules for release downloads</li> <li><code>uv</code> for reproducible environments and pip interoperability</li> </ul> <p>The project intentionally avoids heavyweight dependencies so the wheelhouse can execute on GitHub Actions runners, Codespaces, and developer laptops without extra packaging steps.</p>"},{"location":"explanation/architecture/#directory-hygiene","title":"Directory Hygiene","text":"<ul> <li>Generated build artefacts (e.g., <code>dist/</code>, <code>build/</code>, coverage data) are ignored via <code>.gitignore</code>.</li> <li>The <code>cleanup-macos-cruft.sh</code> script ensures macOS metadata (<code>.DS_Store</code>, etc.) do not enter   history.</li> <li><code>uv run hephaestus cleanup</code> is wired into pre-commit and CI workflows to keep working trees clean   before packaging or releasing.</li> </ul>"},{"location":"explanation/architecture/#extensibility","title":"Extensibility","text":"<ul> <li>Add new CLI commands by extending <code>src/hephaestus/cli.py</code> and corresponding modules.</li> <li>Create custom quality gate plugins using the <code>QualityGatePlugin</code> interface (see Plugin Development Guide).</li> <li>Enable optional OpenTelemetry tracing via environment variables (see Observability Guide).</li> <li>Provide additional how-to guides under <code>docs/how-to/</code> and link them via <code>mkdocs.yml</code>.</li> <li>Customise the refactoring toolkit by editing <code>hephaestus-toolkit/refactoring/config/refactor.config.yaml</code>.</li> </ul> <p>For a quick visual summary of the repository, refer to the \"Project Layout\" section in the <code>README.md</code>.</p>"},{"location":"explanation/exfat-compatibility/","title":"exFAT Filesystem Compatibility Implementation","text":""},{"location":"explanation/exfat-compatibility/#overview","title":"Overview","text":"<p>This document describes the implementation of automatic exFAT/non-xattr filesystem compatibility for the Hephaestus development environment setup process.</p>"},{"location":"explanation/exfat-compatibility/#problem-statement","title":"Problem Statement","text":"<p>When the Hephaestus repository is cloned to a filesystem that doesn't support extended attributes (exFAT, NTFS, FAT32), such as an external USB drive or network share, macOS creates AppleDouble companion files (prefixed with <code>._</code>) when copying wheel payloads with extended attributes. This causes:</p> <ol> <li>UV installation failures with RECORD mismatches</li> <li><code>._</code> files appearing in package installations</li> <li>Broken symlinks and missing files during <code>uv sync</code></li> </ol>"},{"location":"explanation/exfat-compatibility/#root-cause","title":"Root Cause","text":"<ul> <li>Non-xattr filesystems: exFAT, NTFS, FAT32 don't support macOS extended attributes</li> <li>AppleDouble files: macOS materializes <code>._</code> files as resource forks when copying files with xattrs to non-xattr volumes</li> <li>UV verification: UV's RECORD verification fails when unexpected <code>._</code> files appear in wheel installations</li> </ul>"},{"location":"explanation/exfat-compatibility/#solution","title":"Solution","text":""},{"location":"explanation/exfat-compatibility/#1-filesystem-detection","title":"1. Filesystem Detection","text":"<p>The setup script now detects the filesystem type using:</p> <pre><code># Primary method (macOS)\nFS_TYPE=$(stat -f %T . 2&gt;/dev/null || echo \"\")\n\n# Fallback method\nFS_TYPE=$(df -T . 2&gt;/dev/null | tail -1 | awk '{print $2}' || echo \"\")\n</code></pre> <p>Pattern matching identifies non-xattr filesystems:</p> <ul> <li>exFAT (case-insensitive)</li> <li>MSDOS</li> <li>NTFS</li> <li>FAT32</li> <li>VFAT</li> </ul>"},{"location":"explanation/exfat-compatibility/#2-automatic-environment-relocation","title":"2. Automatic Environment Relocation","text":"<p>When a non-xattr filesystem is detected:</p> <ol> <li>Set <code>UV_PROJECT_ENVIRONMENT=$HOME/.uvenvs/&lt;repo-name&gt;</code></li> <li>Create the parent directory: <code>mkdir -p $HOME/.uvenvs</code></li> <li>Run <code>uv sync</code> targeting the relocated environment</li> <li>Create symlink: <code>.venv -&gt; $UV_PROJECT_ENVIRONMENT</code></li> </ol> <p>This ensures the virtual environment is created on an APFS-backed internal disk, avoiding xattr issues.</p>"},{"location":"explanation/exfat-compatibility/#3-extended-attribute-stripping","title":"3. Extended Attribute Stripping","text":"<p>Before syncing dependencies:</p> <pre><code># Strip xattrs from UV cache\nxattr -rc ~/.cache/uv\n\n# Strip xattrs from relocated environment (if exists)\nxattr -rc $UV_PROJECT_ENVIRONMENT\n</code></pre> <p>This prevents AppleDouble files from being created when copying files.</p>"},{"location":"explanation/exfat-compatibility/#4-improved-error-messages","title":"4. Improved Error Messages","text":"<p>Python version check now provides actionable remediation:</p> <pre><code>Python 3.12+ required, found 3.9.6\n\nRecommended fixes:\n  1. Install Python 3.12 with uv: uv python install 3.12\n  2. Use it for this project: uv python pin 3.12\n  Or install Python 3.12+ from https://www.python.org/downloads/\n</code></pre>"},{"location":"explanation/exfat-compatibility/#5-pre-commit-hooks-handling","title":"5. Pre-commit Hooks Handling","text":"<p>The script now detects when <code>core.hooksPath</code> is configured elsewhere:</p> <pre><code>HOOKS_PATH=$(git config --get core.hooksPath 2&gt;/dev/null || echo \"\")\nif [[ -n \"$HOOKS_PATH\" ]]; then\n    print_warning \"core.hooksPath is set to: $HOOKS_PATH\"\n    print_warning \"Pre-commit hooks managed centrally - skipping local installation\"\nfi\n</code></pre>"},{"location":"explanation/exfat-compatibility/#files-modified","title":"Files Modified","text":""},{"location":"explanation/exfat-compatibility/#scriptssetup-dev-envsh","title":"scripts/setup-dev-env.sh","text":"<p>Changes:</p> <ol> <li>Added filesystem detection logic (Step 2.5)</li> <li>Added automatic environment relocation</li> <li>Added xattr stripping before sync</li> <li>Updated Python version check with remediation steps</li> <li>Added symlink creation after successful sync</li> <li>Added pre-commit hooks path detection</li> <li>Updated retry logic to handle symlinks and xattr stripping</li> <li>Added informational output about relocated environment</li> </ol>"},{"location":"explanation/exfat-compatibility/#docshow-totroubleshootingmd","title":"docs/how-to/troubleshooting.md","text":"<p>Changes:</p> <ol> <li>Expanded \"macOS AppleDouble/Resource Fork Installation Errors\" section</li> <li>Added \"Working on External/USB Drives (exFAT, NTFS, FAT32)\" subsection</li> <li>Documented manual workaround steps</li> <li>Added prevention tips for shell configuration</li> <li>Explained symlink behavior and UV_PROJECT_ENVIRONMENT</li> </ol>"},{"location":"explanation/exfat-compatibility/#readmemd","title":"README.md","text":"<p>Changes:</p> <ol> <li>Added note about external drive support in Quick Start section</li> <li>Linked to troubleshooting guide for details</li> </ol>"},{"location":"explanation/exfat-compatibility/#teststest_setup_script_logicsh-new-file","title":"tests/test_setup_script_logic.sh (new file)","text":"<p>Test Coverage:</p> <ul> <li>Script syntax validation</li> <li>Filesystem type detection (12 filesystem types tested)</li> <li>Environment relocation flag logic</li> <li>Symlink path generation</li> <li>Python version checking (5 versions tested)</li> <li>Symlink vs directory detection</li> <li>Git hooks path configuration detection</li> </ul> <p>Results: 7 test categories, 24 assertions, all passing</p>"},{"location":"explanation/exfat-compatibility/#usage","title":"Usage","text":""},{"location":"explanation/exfat-compatibility/#automatic-recommended","title":"Automatic (Recommended)","text":"<p>Simply run the setup script:</p> <pre><code>./scripts/setup-dev-env.sh\n</code></pre> <p>The script will:</p> <ol> <li>Detect if you're on a non-xattr filesystem</li> <li>Automatically relocate the environment</li> <li>Strip xattrs from cache and environment</li> <li>Create the <code>.venv</code> symlink</li> <li>Show informational messages about the relocation</li> </ol>"},{"location":"explanation/exfat-compatibility/#manual-configuration","title":"Manual Configuration","text":"<p>For advanced users or to force relocation:</p> <pre><code># Set environment variable before running setup\nexport UV_PROJECT_ENVIRONMENT=\"$HOME/.uvenvs/hephaestus\"\n./scripts/setup-dev-env.sh\n</code></pre>"},{"location":"explanation/exfat-compatibility/#verification","title":"Verification","text":"<p>Check if relocation was successful:</p> <pre><code># Check if .venv is a symlink\nls -la .venv\n\n# Should show something like:\n# lrwxr-xr-x  1 user  staff  39 Oct  9 12:34 .venv -&gt; /Users/user/.uvenvs/hephaestus\n\n# Verify the target exists\nls -la ~/.uvenvs/hephaestus\n</code></pre>"},{"location":"explanation/exfat-compatibility/#environment-variables","title":"Environment Variables","text":"<p>The setup script uses these environment variables:</p> <ul> <li><code>UV_PROJECT_ENVIRONMENT</code>: Target location for virtual environment</li> <li><code>UV_LINK_MODE=copy</code>: Prevents reflink issues on macOS</li> <li><code>COPYFILE_DISABLE=1</code>: Prevents AppleDouble file creation</li> <li><code>UV_CACHE_DIR</code>: UV cache directory (defaults to <code>~/.cache/uv</code>)</li> </ul>"},{"location":"explanation/exfat-compatibility/#compatibility","title":"Compatibility","text":"<p>Tested on:</p> <ul> <li>macOS 14+ (Sonoma)</li> <li>exFAT-formatted external drives</li> <li>APFS internal disks</li> <li>Python 3.12+</li> </ul> <p>Future Considerations:</p> <ul> <li>Linux support (if needed)</li> <li>Windows support (WSL)</li> <li>Network share detection</li> </ul>"},{"location":"explanation/exfat-compatibility/#references","title":"References","text":"<ul> <li>UV Documentation</li> <li>macOS Extended Attributes</li> <li>exFAT Specification</li> </ul>"},{"location":"explanation/exfat-compatibility/#troubleshooting","title":"Troubleshooting","text":"<p>See docs/how-to/troubleshooting.md for detailed troubleshooting steps.</p>"},{"location":"explanation/exfat-compatibility/#maintenance","title":"Maintenance","text":"<p>To ensure this solution remains effective:</p> <ol> <li>Test with new macOS versions</li> <li>Test with new UV versions</li> <li>Monitor for AppleDouble file reports in issues</li> <li>Keep troubleshooting documentation updated</li> </ol>"},{"location":"explanation/frontier-red-team-gap-analysis/","title":"Frontier Readiness Red Team &amp; Gap Analysis","text":""},{"location":"explanation/frontier-red-team-gap-analysis/#scope-method","title":"Scope &amp; Method","text":"<p>This assessment stress-tests Hephaestus across its primary safety-, quality-, and automation-critical workflows. We combined STRIDE threat modelling, code-level review, negative test design, and operator journey mapping to evaluate:</p> <ul> <li>CLI orchestration and guard rails that coordinate cleanup, QA, and rollout tasks (<code>src/hephaestus/cli.py</code>).</li> <li>Release supply-chain automation responsible for downloading, extracting, and installing wheelhouse bundles (<code>src/hephaestus/release.py</code>).</li> <li>Workspace hygiene tooling that performs destructive filesystem operations (<code>src/hephaestus/cleanup.py</code>).</li> <li>Refactoring analytics scaffolding that prioritises hotspots, coverage gaps, and advisory workstreams (<code>src/hephaestus/toolbox.py</code>).</li> <li>Documentation, playbooks, and MkDocs site to confirm operator guidance keeps pace with the implementation (<code>README.md</code>, <code>docs/</code> tree).</li> </ul> <p>Each area was reviewed for adversarial misuse potential, resilience under failure, telemetry coverage, and UX/operability at scale. Findings are mapped to severity, residual risk, and remediation priorities.</p>"},{"location":"explanation/frontier-red-team-gap-analysis/#attack-surface-overview","title":"Attack Surface Overview","text":""},{"location":"explanation/frontier-red-team-gap-analysis/#cli-orchestration","title":"CLI Orchestration","text":"<p>The Typer-based CLI exposes nested command groups for tooling, QA, release operations, cleanup, and guard rails (<code>app</code>, <code>tools_app</code>, and child apps). It shells out to the Python interpreter for pip installs and surfaces plan, coverage, and refactor analytics (<code>src/hephaestus/cli.py</code>). The CLI inherits the safeguards of the underlying modules but currently lacks structured logging and dry-run previews for destructive flows.</p>"},{"location":"explanation/frontier-red-team-gap-analysis/#release-supply-chain","title":"Release Supply Chain","text":"<p>Release automation fetches GitHub release metadata, sanitises asset names, applies retry/backoff with bounded timeouts, and installs wheels through pip (<code>src/hephaestus/release.py</code>). Network operations are authenticated via HTTPS/GitHub tokens, SHA-256 manifests are required by default, and Sigstore bundles are downloaded and verified when published. Residual risk centres on enforcing identity policies and ensuring every historical release ships an attestation.</p>"},{"location":"explanation/frontier-red-team-gap-analysis/#workspace-cleanup","title":"Workspace Cleanup","text":"<p>The cleanup engine guards dangerous roots, normalises extra paths, and removes caches, build artefacts, and macOS metadata (<code>src/hephaestus/cleanup.py</code>). Protections include hard blocklists for <code>/</code>, <code>/home</code>, <code>/usr</code>, <code>/etc</code>, and other critical directories. However, operations outside the repository still lack confirmation prompts or dry-run manifests, so user error remains a latent risk.</p>"},{"location":"explanation/frontier-red-team-gap-analysis/#refactoring-analytics-toolkit","title":"Refactoring Analytics Toolkit","text":"<p>Refactor planning utilities load YAML configuration, generate deterministic hotspot rankings, and emit advisory opportunities (<code>src/hephaestus/toolbox.py</code>). New analytics adapters can ingest churn, coverage, and embedding exports directly from YAML/JSON sources, replacing the synthetic fallbacks for repositories that wire in live feeds. Remaining limitations centre on correlation across repositories and incremental refresh automation, which still requires manual orchestration.</p>"},{"location":"explanation/frontier-red-team-gap-analysis/#key-findings-residual-risks","title":"Key Findings &amp; Residual Risks","text":"Severity Area Observation Recommended Remediation Medium Release supply chain Wheelhouse installs now fail closed without matching SHA-256 manifests and verify Sigstore bundles when available (<code>src/hephaestus/release.py</code>). Remaining exposure stems from repositories that have not yet published bundles or whose attestations do not match trusted identities. Enforce Sigstore identity policies via <code>--sigstore-identity</code>, require attestations with <code>--require-sigstore</code> in automated environments, and backfill bundles for historical releases. Integrate attestation metadata into audit logs for downstream verification. High Workspace hygiene Cleanup now enforces a mandatory dry-run preview, typed confirmation for targets outside the repository root, and writes JSON audit manifests for every run (<code>src/hephaestus/cleanup.py</code>, <code>src/hephaestus/cli.py</code>). Continue layering additional controls such as signed manifests and reversible deletions for environments that demand forensic-grade traceability. Medium Observability CLI and release helpers emit ad-hoc <code>logger.info</code> messages without structured context or correlation IDs (<code>src/hephaestus/release.py</code>, <code>src/hephaestus/cli.py</code>). Incident triage and fleet-wide metrics are limited. Adopt structured JSON logging with run IDs, command metadata, and timing. Provide file-based audit logs for destructive flows and expose OpenTelemetry exporters guarded by environment flags. Medium AI/automation readiness Refactor analytics now support pluggable churn, coverage, and embedding adapters via <code>src/hephaestus/analytics.py</code>, unlocking data-backed hotspot rankings when repositories export telemetry. Automated refresh and richer risk scoring remain open. Extend adapters with incremental sync tooling, add historical trend analysis, and expose a vector-friendly API so AI copilots can query hotspots, dependencies, and rollout playbooks in real time. Low UX &amp; guard rails CLI commands lack progressive disclosure for long-running tasks (no progress bars, ETA hints) and omit contextual help for advanced flags (<code>src/hephaestus/cli.py</code>). Operators may misconfigure options under stress. Integrate Rich progress renderers, contextual examples in help text, and guard-rail suggestions when thresholds are breached."},{"location":"explanation/frontier-red-team-gap-analysis/#gap-analysis","title":"Gap Analysis","text":""},{"location":"explanation/frontier-red-team-gap-analysis/#quality-coverage","title":"Quality &amp; Coverage","text":"<ul> <li>Test coverage enforces an 85% floor via pytest-cov defaults in <code>pyproject.toml</code>, yet release retry/backoff logic and cleanup safety rails were under-tested. New regression tests now exercise timeout validation, retry escalation, and sanitisation edge cases to prevent silent regressions (<code>tests/test_release.py</code>).</li> <li>CLI release install wiring now has regression coverage for Sigstore pattern/identity flags (<code>tests/test_cli.py</code>), including multi-pattern identity matching to guard against accidental bypasses of the supply-chain gates.</li> <li>Characterisation tests remain sparse for cleanup and planning flows; add scenario suites to lock down failure semantics before shipping automation.</li> </ul>"},{"location":"explanation/frontier-red-team-gap-analysis/#security-compliance","title":"Security &amp; Compliance","text":"<ul> <li>STRIDE ADR outlines supply-chain and cleanup threats. Checksum enforcement and Sigstore verification now gate wheelhouse installs, but we still need identity policies, attested cleanup manifests, and security sign-off gates that verify these controls before release.</li> <li>Secret redaction is manual; expand token redaction utilities to cover CLI output, logs, and exceptions.</li> </ul>"},{"location":"explanation/frontier-red-team-gap-analysis/#observability-telemetry","title":"Observability &amp; Telemetry","text":"<ul> <li>Structured JSON logging with run IDs is in place and now backed by a central telemetry event schema plus CLI operation correlation identifiers. Remaining gaps include tracing/span export and metrics\u2014introducing OpenTelemetry instrumentation around release downloads, cleanup sweeps, and guard-rail pipelines would unblock SLO tracking and anomaly detection. Cleanup continues to emit structured audit manifests for post-run inspection; next steps include wiring those artefacts into telemetry sinks.</li> </ul>"},{"location":"explanation/frontier-red-team-gap-analysis/#developer-experience","title":"Developer Experience","text":"<ul> <li>No dry-run or preview for cleanup and release install flows reduces operator confidence. Provide interactive confirmations, plan visualisations, and recoverable trash bins for deleted artefacts.</li> <li>CLI help should surface recommended workflows (e.g., <code>guard-rails</code> before commits) and link to operating guides directly from <code>--help</code> output.</li> </ul>"},{"location":"explanation/frontier-red-team-gap-analysis/#ai-frontier-capabilities","title":"AI &amp; Frontier Capabilities","text":"<ul> <li>Toolkit analytics can now ingest churn, coverage, and embedding exports, providing data-backed hotspots and refactor suggestions when telemetry files are present. Next steps include streaming ingestion, prompt-ready summaries, and API endpoints so AI agents can query tasks programmatically.</li> <li>Introduce policy-based guard rails allowing AI operators to request automation only within whitelisted directories or branches, enforced via CLI and cleanup options.</li> </ul>"},{"location":"explanation/frontier-red-team-gap-analysis/#frontier-grade-roadmap-recommendations","title":"Frontier-Grade Roadmap Recommendations","text":"<ol> <li>Supply-Chain Hardening: Enforce Sigstore identity policies, publish attestations for every release, and surface attestation metadata in audit logs so operators can trace provenance end-to-end. Provide continuous scanning of release archives post-download.</li> <li>Structured Operational Telemetry: Implement JSON logging and OpenTelemetry tracing for CLI invocations, release downloads, cleanup operations, and QA pipelines. Expose dashboards for retries, failure modes, and duration percentiles.</li> <li>Refactor Intelligence Platform: Replace synthetic analytics with adapters that ingest git churn, coverage heatmaps, static analysis (Ruff/Mypy), and ML embeddings. Offer ranking APIs and CLI visualisations for hotspots, risk scores, and effort models.</li> <li>AI Co-Pilot Interfaces: Publish a gRPC/REST layer enabling autonomous agents to request refactor plans, QA profiles, and guard-rail enforcement. Include sandboxed \u201cwhat-if\u201d simulators to rehearse rollout plans and evaluate blast radius before execution.</li> <li>Progressive Safety Controls: Add dry-run manifests, undo checkpoints, and interactive confirmations for cleanup and release installation. Provide emergency stop commands wired into guard-rail pipelines.</li> <li>Integrated Quality Console: Bundle a Rich- or Textual-based TUI that aggregates guard-rail status, coverage deltas, dependency risks, and release readiness in one place for operators.</li> <li>Continuous Gap Audits: Automate periodic red-team exercises that run scripted adversarial scenarios against cleanup, release, and analytics modules, logging drift from expected controls.</li> </ol>"},{"location":"explanation/frontier-red-team-gap-analysis/#quality-gates-next-steps","title":"Quality Gates &amp; Next Steps","text":"<ul> <li>Expand regression coverage across release retries, sanitisation, and configuration propagation (added in <code>tests/test_release.py</code>).</li> <li>Track remediation of high-severity findings (checksum verification, cleanup dry-runs) in <code>Next_Steps.md</code> to ensure accountability.</li> <li>Prioritise structured telemetry and AI-ready analytics in the upcoming iteration to unlock frontier-grade automation.</li> </ul>"},{"location":"explanation/frontier-standards/","title":"Frontier Standards Charter","text":"<p>This charter codifies the frontier-grade engineering standards for the Hephaestus toolkit. It captures every enforced quality gate, the required developer behaviors, and the automation that keeps those expectations evergreen. The goal is to make quality non-negotiable while remaining explicit about the few approved places where judgment calls or waivers apply.</p>"},{"location":"explanation/frontier-standards/#scope-responsibilities","title":"Scope &amp; Responsibilities","text":"<p>These standards apply to everyone who contributes to, packages, or operates Hephaestus. They cover the full software development lifecycle:</p> <ul> <li>Discovery &amp; technical planning</li> <li>Local development and environment hygiene</li> <li>Code quality, testing, and security validation</li> <li>Release management and supply-chain assurance</li> <li>Ongoing operations, observability, and currency management</li> <li>Documentation, knowledge capture, and AI/automation integration</li> </ul>"},{"location":"explanation/frontier-standards/#guiding-principles","title":"Guiding Principles","text":"<ol> <li>Automate the baseline. Every recurring control must be enforced by scripts, guard-rails, or    CI workflows before it becomes policy.</li> <li>Fail closed on safety-critical paths. Cleanup, release installation, and supply-chain    verification abort rather than run with reduced coverage unless an explicit escape hatch is    documented.</li> <li>Prefer typed, observable code. Strict typing, structured logging, and telemetry hooks are the    default\u2014new code without them requires sign-off.</li> <li>Document as you deliver. Di\u00e1taxis-aligned documentation is a release criterion, not an    afterthought.</li> <li>Reproduce everything. All environments are provisioned with <code>uv</code>, wheelhouses are signed, and    every scripted action is idempotent.</li> </ol>"},{"location":"explanation/frontier-standards/#lifecycle-standards","title":"Lifecycle Standards","text":""},{"location":"explanation/frontier-standards/#1-discovery-planning","title":"1. Discovery &amp; Planning","text":"Requirement Enforcement Architectural decisions captured as ADRs before large refactors <code>docs/adr/</code> templates (ADR-0000) Execution plans reviewed for multi-week initiatives <code>hephaestus plan</code> command output and review meeting notes Risk and threat analysis refreshed yearly <code>docs/explanation/frontier-red-team-gap-analysis.md</code> &amp; ADR-0001 Roadmapping and gap tracking centralised <code>Next_Steps.md</code>, <code>IMPLEMENTATION_SUMMARY.md</code>, project boards"},{"location":"explanation/frontier-standards/#2-environment-tooling-hygiene","title":"2. Environment &amp; Tooling Hygiene","text":"Requirement Enforcement Use <code>uv</code> for dependency management <code>uv sync --extra dev --extra qa</code> mandated by setup docs Detect drift before shipping <code>uv run hephaestus guard-rails --drift</code> (required before PR open) Prevent metadata cruft Pre-commit <code>hephaestus cleanup</code> hook; <code>.github/workflows/macos-metadata-guard.yml</code> Only operate within repo roots by default <code>cleanup</code> safety rails guard <code>/</code>, home, system paths"},{"location":"explanation/frontier-standards/#3-development-coding-standards","title":"3. Development &amp; Coding Standards","text":"<ul> <li>Respect Ruff linting profile (<code>E</code>, <code>F</code>, <code>I</code>, <code>UP</code>, <code>B</code>, <code>C4</code>) and 100-character formatting enforced   via <code>ruff format</code>.</li> <li>Mypy strict mode (<code>disallow_untyped_defs</code>, <code>warn_return_any</code>, etc.) guards <code>src/</code> and   <code>tests/</code>.</li> <li>New public APIs ship with docstrings, usage examples, and type annotations.</li> <li>Nested Typer command decorators are prohibited and blocked by <code>scripts/lint_nested_decorators.py</code>   in pre-commit and CI.</li> <li>Structured logging uses <code>hephaestus.logging.get_logger()</code> with run IDs and operation IDs for every   CLI entry point.</li> </ul>"},{"location":"explanation/frontier-standards/#4-testing-quality-gates","title":"4. Testing &amp; Quality Gates","text":"Gate Threshold / Expectation Primary Command Automation Unit &amp; integration tests 100% pass, coverage \u2265 85%, warnings-as-errors <code>uv run pytest</code> CI (<code>ci.yml</code>), <code>guard-rails</code>, <code>validate_quality_gates.py</code> Linting Zero Ruff violations <code>uv run ruff check .</code> Pre-commit &amp; CI Formatting Zero drift <code>uv run ruff format --check .</code> Pre-commit &amp; CI Type safety No mypy errors <code>uv run mypy src tests</code> Pre-commit &amp; CI YAML hygiene No yamllint errors under <code>.trunk/configs/.yamllint.yaml</code> <code>uv run yamllint \u2026</code> Guard-rails &amp; quality gate script Nested decorator lint Zero violations <code>python3 scripts/lint_nested_decorators.py</code> Pre-commit &amp; CI Build reproducibility Wheels &amp; sdists build cleanly <code>uv run uv build</code> (or <code>python3 -m build</code>) <code>validate_quality_gates.py</code>, release workflows Security audit <code>pip-audit --strict</code> clean (ignoring GHSA-4xh5-x5gv-qwph until patched) <code>uv run pip-audit --strict --ignore-vuln GHSA-4xh5-x5gv-qwph</code> Guard-rails, scheduled <code>pip-audit.yml</code> Workflow lint (optional) Actionlint passes <code>bash scripts/run_actionlint.sh</code> Optional quality gate, manual before large workflow edits <p>Run the full suite locally using either:</p> <pre><code>uv run hephaestus guard-rails\npython3 scripts/validate_quality_gates.py\n</code></pre>"},{"location":"explanation/frontier-standards/#5-security-privacy","title":"5. Security &amp; Privacy","text":"<ul> <li>Follow the disclosure process in <code>SECURITY.md</code>; critical vulnerabilities target   14-day remediation.</li> <li>Wheelhouse installs must verify SHA-256 manifests and Sigstore bundles unless <code>--allow-unsigned</code>   is approved for an isolated environment.</li> <li>Release downloads enforce HTTPS, bounded retries, and sanitized asset names (<code>src/hephaestus/release.py</code>).</li> <li>Cleanup requires explicit confirmation for paths outside the repository and records JSON audit   manifests under <code>.hephaestus/audit/</code> for compliance.</li> <li>Dependency hygiene is augmented by Dependabot, weekly <code>pip-audit</code> workflow, and pre-commit hooks.</li> </ul>"},{"location":"explanation/frontier-standards/#6-release-management","title":"6. Release Management","text":"Standard Mechanism Semantic versioning applied (<code>MAJOR.MINOR.PATCH</code>) Manual review via <code>docs/how-to/release-process.md</code> Release prep checklist executed <code>docs/pre-release-checklist.md</code> Automated tagging &amp; GitHub Releases <code>.github/workflows/release-tag.yml</code> Wheelhouse build &amp; attachment <code>.github/workflows/publish.yml</code> Installation verification <code>uv run hephaestus release install --cleanup --remove-archive</code> Rollback readiness Procedures codified in pre-release checklist; gh release delete workflow Security attestation backlog Sigstore bundles tracked in <code>Next_Steps.md</code> (status reported in charter notes)"},{"location":"explanation/frontier-standards/#7-operations-currency","title":"7. Operations &amp; Currency","text":"<ul> <li>CI (uv with offline-ready install): <code>ci.yml</code> runs <code>uv sync</code>, <code>pytest</code>, builds wheelhouse artifacts,   and executes offline QA on self-hosted runners.</li> <li>CodeQL: Weekly plus on-push/pull-request static analysis (<code>codeql.yml</code>).</li> <li>Dependency Review: Pull-request scans via <code>dependency-review.yml</code>.</li> <li>pip-audit Scheduled Sweep: Weekly security audit (<code>pip-audit.yml</code>).</li> <li>Pre-commit Autoupdate: Weekly hook refresh (<code>pre-commit-autoupdate.yml</code>).</li> <li>TurboRepo Release Monitor: Daily schedule to open issues when upstream TurboRepo releases change   (<code>turborepo-monitor.yml</code> + <code>ops/turborepo-release.json</code>).</li> <li>macOS Metadata Guard: Prevents <code>.DS_Store</code> and friends from entering history.</li> <li>Dependabot: Weekly package and GitHub Action updates (<code>.github/dependabot.yml</code>).</li> </ul> <p>Each workflow must remain green before a release; failures block the release checklist until resolved or explicitly waived by the maintainer of record.</p>"},{"location":"explanation/frontier-standards/#8-observability-telemetry","title":"8. Observability &amp; Telemetry","text":"<ul> <li>CLI commands default to human-readable logs but must support <code>--log-format json</code> for machine   ingestion (<code>docs/how-to/ai-agent-integration.md</code>).</li> <li>Telemetry events are defined in <code>src/hephaestus/telemetry.py</code>; every new command registers   structured events with run IDs.</li> <li>OpenTelemetry spans are tracked in <code>Next_Steps.md</code> &amp; ADR-0003; once delivered they will be   mandatory for long-running operations.</li> </ul>"},{"location":"explanation/frontier-standards/#9-documentation-knowledge-management","title":"9. Documentation &amp; Knowledge Management","text":"<ul> <li>All user-facing features require updates to the Di\u00e1taxis docs (<code>docs/how-to/</code>, <code>docs/reference/</code>,   <code>docs/tutorials/</code>, <code>docs/explanation/</code>).</li> <li>README quick-start commands must remain accurate for the latest release; changes to CLI signatures   update <code>docs/reference/cli.md</code> and <code>schemas</code>.</li> <li>Rollback playbooks, safety guides, and AI integration guides are canonical references and must be   updated with new options or flags.</li> </ul>"},{"location":"explanation/frontier-standards/#10-ai-automation-readiness","title":"10. AI &amp; Automation Readiness","text":"<ul> <li>Export schemas with <code>hephaestus schema --output schemas.json</code> whenever the CLI surface changes.</li> <li>Maintain deterministic command outputs (Rich tables, JSON logs) to keep AI integrations reliable.</li> <li>Link AI-facing guidance in <code>docs/how-to/ai-agent-integration.md</code>.</li> <li>Guard-rails <code>--drift</code> output must list remediation commands to keep agent remediation consistent.</li> </ul>"},{"location":"explanation/frontier-standards/#quality-gate-escape-hatches","title":"Quality Gate Escape Hatches","text":"<p>If a gate fails:</p> <ol> <li>Investigate locally with the single-gate command listed above.</li> <li>If the failure stems from known external constraints (e.g., <code>pip-audit</code> SSL trust chains in    constrained containers), document the waiver in the PR description and re-run in a compliant    environment before release.</li> <li>Long-lived waivers require an issue in the tracker plus an entry in <code>Next_Steps.md</code> with owner and    target date.</li> </ol>"},{"location":"explanation/frontier-standards/#developer-workflow-checklist","title":"Developer Workflow Checklist","text":"<ol> <li><code>uv sync --extra dev --extra qa</code></li> <li><code>uv run hephaestus guard-rails --drift</code></li> <li>Implement changes with lint/type/format hooks active.</li> <li><code>uv run hephaestus guard-rails</code> (or <code>python3 scripts/validate_quality_gates.py</code>)</li> <li>Update docs + changelog; export schemas if CLI changed.</li> <li>Ensure all GitHub Actions workflows are green; resolve or document any failures.</li> <li>Submit PR with links to relevant docs/tests and checklist ticked.</li> <li>Before release: follow the pre-release checklist and confirm wheelhouse install.</li> </ol>"},{"location":"explanation/frontier-standards/#governance-review-cadence","title":"Governance &amp; Review Cadence","text":"<ul> <li>Quarterly: Review this charter, frontier gap analysis, and <code>Next_Steps.md</code> to capture new   threats or automation opportunities.</li> <li>Monthly: Audit workflow run history for flaky gates or drift, refresh dependency locks, and   review Sigstore attestation coverage.</li> <li>Per Release: Validate charter alignment via checklist sign-off and ensure documentation is   synchronized.</li> </ul>"},{"location":"explanation/frontier-standards/#references","title":"References","text":"<ul> <li>Quality Gate Guide</li> <li>Operating Safely</li> <li>Testing Guide</li> <li>Release Process</li> <li>AI Agent Integration</li> <li>Evergreen Lifecycle Playbook</li> <li>Frontier Red Team &amp; Gap Analysis</li> <li><code>scripts/README.md</code></li> <li><code>src/hephaestus/cli.py</code></li> <li>GitHub Actions workflows under <code>.github/workflows/</code></li> </ul> <p>Maintaining frontier status means treating this charter as executable policy. When a new tool, workflow, or risk emerges, update the automation first, then amend the charter so that expectations stay aligned with reality.</p>"},{"location":"how-to/ai-agent-integration/","title":"AI Agent Integration Guide","text":"<p>This guide helps AI agents (GitHub Copilot, Cursor, Claude, etc.) integrate with Hephaestus CLI commands safely and predictably.</p>"},{"location":"how-to/ai-agent-integration/#getting-command-schemas","title":"Getting Command Schemas","text":"<p>Export all command schemas as JSON for programmatic consumption:</p> <pre><code>hephaestus schema --output schemas.json\n</code></pre> <p>This generates a JSON file with:</p> <ul> <li>Command names and descriptions</li> <li>Parameter specifications (types, defaults, help text)</li> <li>Usage examples</li> <li>Expected output formats</li> <li>Retry hints for common failures</li> </ul>"},{"location":"how-to/ai-agent-integration/#schema-format","title":"Schema Format","text":"<pre><code>{\n  \"version\": \"1.0\",\n  \"commands\": [\n    {\n      \"name\": \"cleanup\",\n      \"help\": \"Scrub development cruft...\",\n      \"parameters\": [\n        {\n          \"name\": \"root\",\n          \"type\": \"path\",\n          \"required\": false,\n          \"help\": \"Workspace root to clean\"\n        }\n      ],\n      \"examples\": [\"hephaestus cleanup\", \"hephaestus cleanup --deep-clean\"],\n      \"expected_output\": \"Table showing cleaned paths and sizes\",\n      \"retry_hints\": [\n        \"If cleanup fails with permission errors, check file permissions\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"how-to/ai-agent-integration/#common-integration-patterns","title":"Common Integration Patterns","text":""},{"location":"how-to/ai-agent-integration/#1-command-discovery","title":"1. Command Discovery","text":"<p>Use the schema to discover available commands and their capabilities:</p> <pre><code>import json\n\nwith open(\"schemas.json\") as f:\n    schemas = json.load(f)\n\nfor cmd in schemas[\"commands\"]:\n    print(f\"{cmd['name']}: {cmd['help']}\")\n</code></pre>"},{"location":"how-to/ai-agent-integration/#2-parameter-validation","title":"2. Parameter Validation","text":"<p>Validate parameters before invoking commands:</p> <pre><code>def validate_params(command_name, user_params):\n    cmd = next(c for c in schemas[\"commands\"] if c[\"name\"] == command_name)\n\n    for param in cmd[\"parameters\"]:\n        if param[\"required\"] and param[\"name\"] not in user_params:\n            raise ValueError(f\"Missing required parameter: {param['name']}\")\n</code></pre>"},{"location":"how-to/ai-agent-integration/#3-error-recovery","title":"3. Error Recovery","text":"<p>Use retry hints to guide error recovery:</p> <pre><code>def execute_with_retry(command, max_attempts=3):\n    for attempt in range(max_attempts):\n        result = subprocess.run(command, capture_output=True)\n        if result.returncode == 0:\n            return result\n\n        # Check retry hints from schema\n        cmd_schema = get_schema(command[0])\n        print(f\"Retry hint: {cmd_schema['retry_hints'][0]}\")\n</code></pre>"},{"location":"how-to/ai-agent-integration/#command-specific-guidance","title":"Command-Specific Guidance","text":""},{"location":"how-to/ai-agent-integration/#cleanup","title":"Cleanup","text":"<p>When to use: Before running quality checks, during CI cleanup stages, or when disk space is low.</p> <p>Safe patterns:</p> <pre><code># Always run with default safety checks\nhephaestus cleanup\n\n# Add dry-run for verification\nhephaestus cleanup --dry-run\n\n# Deep clean for CI environments\nhephaestus cleanup --deep-clean\n</code></pre> <p>Avoid:</p> <ul> <li>Running cleanup on system directories (/, /home, /usr)</li> <li>Using <code>--extra-path</code> without verification</li> <li>Running outside git repositories without <code>--allow-outside-root</code></li> </ul>"},{"location":"how-to/ai-agent-integration/#guard-rails","title":"Guard-Rails","text":"<p>When to use: Before committing, as part of CI/CD, or after making code changes.</p> <p>Recommended workflow:</p> <pre><code># Full check with auto-format\nhephaestus guard-rails\n\n# Check only (no format) during review\nhephaestus guard-rails --no-format\n</code></pre> <p>Expected failures:</p> <ul> <li>Lint errors: Fix reported issues in code</li> <li>Type errors: Address mypy complaints</li> <li>Test failures: Fix failing tests</li> <li>Security issues: Review and address vulnerabilities</li> </ul>"},{"location":"how-to/ai-agent-integration/#analytics-rankings","title":"Analytics Rankings","text":"<p>When to use: Planning refactoring work, prioritizing technical debt, understanding codebase health.</p> <p>Strategies:</p> <pre><code># Risk-weighted (recommended for general use)\nhephaestus tools refactor rankings\n\n# Coverage-first (when improving test coverage)\nhephaestus tools refactor rankings --strategy coverage_first\n\n# Churn-based (for identifying hotspots)\nhephaestus tools refactor rankings --strategy churn_based\n\n# Composite (balanced with embeddings)\nhephaestus tools refactor rankings --strategy composite\n</code></pre> <p>Prerequisites:</p> <ul> <li>Analytics sources configured in settings</li> <li>churn_file, coverage_file, or embeddings_file paths set</li> <li>Data files exist and are readable</li> </ul>"},{"location":"how-to/ai-agent-integration/#release-install","title":"Release Install","text":"<p>When to use: Installing pre-built wheelhouse distributions, setting up environments.</p> <p>Safe patterns:</p> <pre><code># Standard install (with signature verification)\nhephaestus release install\n\n# Specific version\nhephaestus release install --tag v1.0.0\n\n# With authentication for private repos\nGITHUB_TOKEN=xxx hephaestus release install --repository owner/private-repo\n</code></pre> <p>Network considerations:</p> <ul> <li>Set <code>--timeout</code> higher for slow networks</li> <li>Use <code>--max-retries</code> for flaky connections</li> <li>Cache downloads with <code>--destination</code> to avoid re-downloading</li> </ul>"},{"location":"how-to/ai-agent-integration/#deterministic-outputs","title":"Deterministic Outputs","text":"<p>All commands produce structured, predictable outputs:</p>"},{"location":"how-to/ai-agent-integration/#table-outputs","title":"Table Outputs","text":"<p>Commands like <code>rankings</code>, <code>hotspots</code>, and <code>guard-rails</code> emit Rich tables with consistent columns:</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Rank\u2503 Path            \u2503 Score  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502  1  \u2502 module_a.py     \u2502 0.8234 \u2502\n\u2502  2  \u2502 module_b.py     \u2502 0.7156 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parse these by:</p> <ol> <li>Capturing stdout</li> <li>Extracting table rows</li> <li>Parsing columns by position or header</li> </ol>"},{"location":"how-to/ai-agent-integration/#json-logs","title":"JSON Logs","text":"<p>Enable structured logging for machine parsing:</p> <pre><code>hephaestus --log-format json guard-rails\n</code></pre> <p>Produces:</p> <pre><code>{\n  \"timestamp\": \"2025-01-01T12:00:00Z\",\n  \"level\": \"INFO\",\n  \"message\": \"Starting cleanup\",\n  \"run_id\": \"abc123\"\n}\n</code></pre>"},{"location":"how-to/ai-agent-integration/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Success</li> <li><code>1</code>: Command-specific failure (see stderr for details)</li> <li><code>2</code>: Invalid arguments</li> </ul>"},{"location":"how-to/ai-agent-integration/#best-practices-for-ai-agents","title":"Best Practices for AI Agents","text":""},{"location":"how-to/ai-agent-integration/#1-always-use-schemas","title":"1. Always Use Schemas","text":"<p>Regenerate schemas when Hephaestus is updated:</p> <pre><code>hephaestus schema --output /path/to/agent/schemas.json\n</code></pre>"},{"location":"how-to/ai-agent-integration/#2-validate-before-execution","title":"2. Validate Before Execution","text":"<p>Check parameters against schema before invoking commands to avoid unnecessary failures.</p>"},{"location":"how-to/ai-agent-integration/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>Use retry hints from schemas to guide recovery:</p> <ul> <li>Network timeouts \u2192 increase <code>--timeout</code></li> <li>Permission errors \u2192 check file ownership</li> <li>Missing data \u2192 verify configuration paths</li> </ul>"},{"location":"how-to/ai-agent-integration/#4-use-structured-logging","title":"4. Use Structured Logging","text":"<p>Request JSON logs for easier parsing:</p> <pre><code>hephaestus --log-format json &lt;command&gt;\n</code></pre>"},{"location":"how-to/ai-agent-integration/#5-respect-safety-guardrails","title":"5. Respect Safety Guardrails","text":"<p>Never bypass safety features like:</p> <ul> <li>Dangerous path validation in cleanup</li> <li>Checksum verification in release install</li> <li>Required parameters in commands</li> </ul>"},{"location":"how-to/ai-agent-integration/#6-context-aware-invocation","title":"6. Context-Aware Invocation","text":"<p>Choose commands based on context:</p> <ul> <li>During development: <code>guard-rails</code>, <code>cleanup</code></li> <li>Planning refactors: <code>rankings</code>, <code>opportunities</code>, <code>hotspots</code></li> <li>CI/CD: <code>guard-rails</code>, <code>release install</code></li> <li>Post-mortem analysis: <code>rankings --strategy composite</code></li> </ul>"},{"location":"how-to/ai-agent-integration/#testing-ai-agent-integration","title":"Testing AI Agent Integration","text":"<p>Validate your integration with these test cases:</p> <pre><code># 1. Schema export works\nhephaestus schema --output test-schemas.json\ntest -f test-schemas.json\n\n# 2. Commands execute successfully\nhephaestus version\nhephaestus plan\n\n# 3. Error handling works\nhephaestus cleanup / 2&gt;&amp;1 | grep \"dangerous path\"\n\n# 4. JSON logs parse correctly\nhephaestus --log-format json version | jq .message\n</code></pre>"},{"location":"how-to/ai-agent-integration/#support","title":"Support","text":"<p>For issues with AI integration:</p> <ol> <li>Check command schemas for updated parameters</li> <li>Review retry hints in schema output</li> <li>Enable debug logging: <code>hephaestus --log-level DEBUG &lt;command&gt;</code></li> <li>Report integration issues with schema version and agent details</li> </ol>"},{"location":"how-to/ci-setup/","title":"CI/CD Setup Guide","text":"<p>This guide explains the Hephaestus CI/CD pipeline architecture and how to ensure bulletproof dependency management for ephemeral runners.</p>"},{"location":"how-to/ci-setup/#architecture-overview","title":"Architecture Overview","text":"<p>The Hephaestus CI pipeline uses a dual-path approach to ensure reliability in both internet-enabled and restricted network environments:</p> <ol> <li>Online Path (<code>deps-and-tests-online</code>): Fast path using <code>uv</code> with direct PyPI access</li> <li>Offline Path (<code>build-wheelhouse</code> + <code>ci-offline</code>): Bulletproof path using pre-built wheel archives</li> </ol>"},{"location":"how-to/ci-setup/#why-two-paths","title":"Why Two Paths?","text":""},{"location":"how-to/ci-setup/#online-path-benefits","title":"Online Path Benefits","text":"<ul> <li>Speed: Uses uv's built-in caching and parallel downloads</li> <li>Simplicity: Direct dependency resolution from PyPI</li> <li>Latest versions: Always uses the locked versions from <code>uv.lock</code></li> </ul>"},{"location":"how-to/ci-setup/#offline-path-benefits","title":"Offline Path Benefits","text":"<ul> <li>Reliability: Works in restricted network environments</li> <li>Reproducibility: Guaranteed exact versions from wheelhouse</li> <li>Security: Reduced external dependencies during CI runs</li> <li>Portability: Can be used in air-gapped environments</li> </ul>"},{"location":"how-to/ci-setup/#pipeline-details","title":"Pipeline Details","text":""},{"location":"how-to/ci-setup/#job-1-online-ci-deps-and-tests-online","title":"Job 1: Online CI (<code>deps-and-tests-online</code>)","text":"<pre><code>- Setup uv and Python 3.12\n- Sync dependencies from uv.lock with dev + qa extras\n- Validate environment (Python, pytest, ruff, mypy)\n- Run tests\n- Run ruff lint check\n- Run ruff format check\n- Run mypy type check\n</code></pre> <p>Key Features:</p> <ul> <li>Uses <code>astral-sh/setup-uv@v7</code> for consistent uv installation</li> <li>Enables uv caching for faster subsequent runs</li> <li>Validates all tools are available before running checks</li> </ul>"},{"location":"how-to/ci-setup/#job-2-build-wheelhouse-build-wheelhouse","title":"Job 2: Build Wheelhouse (<code>build-wheelhouse</code>)","text":"<pre><code>- Setup uv and Python 3.12\n- Export uv.lock to requirements.txt (with --extra dev --extra qa)\n- Build wheels for all dependencies\n- Build wheel for hephaestus itself\n- Sanitize wheelhouse (remove macOS resource forks)\n- Verify wheelhouse (check for any remaining artifacts)\n- Upload wheelhouse as artifact\n</code></pre> <p>Key Features:</p> <ul> <li>Uses <code>--extra</code> (not <code>--group</code>) for optional-dependencies</li> <li>Includes comprehensive logging for debugging</li> <li>Validates wheelhouse integrity before upload</li> <li>Sets <code>COPYFILE_DISABLE=1</code> to prevent macOS artifacts</li> </ul>"},{"location":"how-to/ci-setup/#job-3-offline-ci-ci-offline","title":"Job 3: Offline CI (<code>ci-offline</code>)","text":"<pre><code>- Download wheelhouse artifact from build-wheelhouse\n- Validate artifact structure and contents\n- Create isolated venv\n- Install dependencies from wheelhouse (no network)\n- Validate all tools are available\n- Run tests\n- Run QA checks (ruff, mypy)\n</code></pre> <p>Key Features:</p> <ul> <li>Uses <code>--no-index</code> to ensure no network access</li> <li>Validates Python version matches build environment</li> <li>Comprehensive tool availability checks</li> <li>Same OS/arch as build job (ubuntu-24.04)</li> </ul>"},{"location":"how-to/ci-setup/#dependency-management-best-practices","title":"Dependency Management Best Practices","text":""},{"location":"how-to/ci-setup/#1-use-uvlock-for-reproducibility","title":"1. Use uv.lock for Reproducibility","text":"<pre><code># Lock dependencies\nuv lock\n\n# Sync environment from lock\nuv sync --locked --extra dev --extra qa\n</code></pre> <p>The lockfile ensures:</p> <ul> <li>Exact versions across all environments</li> <li>Transitive dependency resolution</li> <li>Consistent builds in CI and local development</li> </ul>"},{"location":"how-to/ci-setup/#2-proper-extra-specification","title":"2. Proper Extra Specification","text":"<p>In <code>pyproject.toml</code>, use <code>[project.optional-dependencies]</code>:</p> <pre><code>[project.optional-dependencies]\ndev = [\n  \"ruff&gt;=0.14.0\",\n  \"mypy&gt;=1.18.2\",\n  # ...\n]\nqa = [\n  \"pytest&gt;=8.2\",\n  \"pytest-cov&gt;=5.0\",\n  # ...\n]\n</code></pre> <p>In CI, use <code>--extra</code> (not <code>--group</code>):</p> <pre><code># Correct \u2713\nuv export --locked --format requirements-txt --extra dev --extra qa\n\n# Incorrect \u2717\nuv export --locked --format requirements-txt --group dev --group qa\n</code></pre>"},{"location":"how-to/ci-setup/#3-validate-environment-before-tests","title":"3. Validate Environment Before Tests","text":"<p>Always validate that all required tools are available:</p> <pre><code># Validate Python\nuv run python --version\n\n# Validate key packages\nuv run python -c \"import pytest; print(f'pytest {pytest.__version__}')\"\nuv run python -c \"import mypy; print(f'mypy {mypy.__version__}')\"\n\n# Validate CLI tools\nuv run python -m ruff --version\n</code></pre>"},{"location":"how-to/ci-setup/#4-wheelhouse-build-process","title":"4. Wheelhouse Build Process","text":"<p>The wheelhouse build follows this pattern:</p> <pre><code># 1. Export locked requirements\nuv export --locked --format requirements-txt \\\n  --extra dev --extra qa \\\n  --all-extras \\\n  -o requirements.txt\n\n# 2. Build wheels for dependencies\npip wheel -r requirements.txt -w wheelhouse\n\n# 3. Build project wheel\nuv build --wheel\ncp dist/*.whl wheelhouse/\n\n# 4. Sanitize (remove macOS artifacts)\nuv run python -m hephaestus.cli wheelhouse sanitize wheelhouse\n\n# 5. Verify (check for remaining artifacts)\nuv run python -m hephaestus.cli wheelhouse verify wheelhouse\n</code></pre>"},{"location":"how-to/ci-setup/#5-offline-install-process","title":"5. Offline Install Process","text":"<p>The offline install follows this pattern:</p> <pre><code># 1. Create isolated environment\npython -m venv .venv\n. .venv/bin/activate\n\n# 2. Upgrade pip from wheelhouse\npip install --no-index --find-links=wheelhouse pip\n\n# 3. Install dependencies from wheelhouse\npip install --no-index \\\n  --find-links=wheelhouse \\\n  -r requirements.txt\n\n# 4. Install project from wheelhouse\npip install --no-index \\\n  --find-links=wheelhouse \\\n  hephaestus\n</code></pre>"},{"location":"how-to/ci-setup/#local-development-setup","title":"Local Development Setup","text":""},{"location":"how-to/ci-setup/#quick-start","title":"Quick Start","text":"<p>Use the provided setup script for a bulletproof local environment:</p> <pre><code>./scripts/setup-dev-env.sh\n</code></pre> <p>This script:</p> <ul> <li>Validates Python 3.12+ is installed</li> <li>Installs uv if not present</li> <li>Syncs dependencies from uv.lock</li> <li>Validates all tools are available</li> <li>Installs pre-commit hooks</li> <li>Runs a quick validation test</li> </ul>"},{"location":"how-to/ci-setup/#manual-setup","title":"Manual Setup","text":"<p>If you prefer manual setup:</p> <pre><code># 1. Ensure Python 3.12+ is installed\npython3 --version\n\n# 2. Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# 3. Sync dependencies\nuv sync --locked --extra dev --extra qa\n\n# 4. Validate environment\nuv run hephaestus --version\nuv run pytest --version\nuv run python -m ruff --version\nuv run mypy --version\n\n# 5. Run quality checks\nuv run hephaestus guard-rails\n</code></pre>"},{"location":"how-to/ci-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/ci-setup/#issue-uv-export-failed-with-unknown-option-group","title":"Issue: \"uv export failed with unknown option --group\"","text":"<p>Cause: Using <code>--group</code> instead of <code>--extra</code> for optional-dependencies.</p> <p>Solution: Use <code>--extra</code> for optional-dependencies:</p> <pre><code># Correct\nuv export --locked --format requirements-txt --extra dev --extra qa\n</code></pre>"},{"location":"how-to/ci-setup/#issue-module-not-found-errors-in-ci","title":"Issue: \"Module not found\" errors in CI","text":"<p>Cause: Dependencies not installed or environment not activated.</p> <p>Solution: Ensure <code>uv sync</code> or offline install completed successfully. Check validation steps.</p>"},{"location":"how-to/ci-setup/#issue-wheelhouse-verification-failed","title":"Issue: \"Wheelhouse verification failed\"","text":"<p>Cause: macOS resource fork artifacts present in wheelhouse.</p> <p>Solution: Run sanitization:</p> <pre><code>uv run python -m hephaestus.cli wheelhouse sanitize wheelhouse\n</code></pre>"},{"location":"how-to/ci-setup/#issue-failed-to-install-on-macos-with-appledouble-files","title":"Issue: \"Failed to install\" on macOS with AppleDouble files","text":"<p>Cause: macOS creates AppleDouble files (<code>._*</code>) during package installation, which are not listed in wheel RECORD files.</p> <p>Solution: The <code>scripts/setup-dev-env.sh</code> script now automatically handles this. For manual setup on macOS:</p> <pre><code># Set environment variables\nexport UV_LINK_MODE=copy\nexport COPYFILE_DISABLE=1\n\n# Clean existing cache and venv\nrm -rf ~/.cache/uv\nrm -rf .venv\n\n# Sync dependencies\nuv sync --locked --extra dev --extra qa\n</code></pre> <p>See the troubleshooting guide for more details.</p>"},{"location":"how-to/ci-setup/#issue-python-version-mismatch-in-offline-install","title":"Issue: \"Python version mismatch in offline install\"","text":"<p>Cause: Wheelhouse built with different Python version than offline runner.</p> <p>Solution: Ensure both jobs use the same Python version and OS/arch:</p> <pre><code>build-wheelhouse:\n  runs-on: ubuntu-24.04\n  # ...\n\nci-offline:\n  runs-on: ubuntu-24.04 # Must match!\n  # ...\n</code></pre>"},{"location":"how-to/ci-setup/#issue-test-failures-in-ephemeral-runners","title":"Issue: \"Test failures in ephemeral runners\"","text":"<p>Cause: Missing dependencies or environment issues.</p> <p>Solution:</p> <ol> <li>Check validation step output</li> <li>Verify uv.lock is committed and up-to-date</li> <li>Ensure all extras are specified in export command</li> <li>Check CI logs for specific errors</li> </ol>"},{"location":"how-to/ci-setup/#maintenance","title":"Maintenance","text":""},{"location":"how-to/ci-setup/#updating-dependencies","title":"Updating Dependencies","text":"<pre><code># Update dependencies\nuv lock --upgrade\n\n# Sync environment\nuv sync --locked --extra dev --extra qa\n\n# Run quality checks\nuv run hephaestus guard-rails\n\n# Commit updated lock file\ngit add uv.lock\ngit commit -m \"chore: update dependencies\"\n</code></pre>"},{"location":"how-to/ci-setup/#regenerating-wheelhouse","title":"Regenerating Wheelhouse","text":"<p>Wheelhouses are built automatically in CI, but you can build locally:</p> <pre><code># Export requirements\nuv export --locked --format requirements-txt \\\n  --extra dev --extra qa \\\n  --all-extras \\\n  -o requirements.txt\n\n# Build wheelhouse\npip wheel -r requirements.txt -w wheelhouse\nuv build --wheel\ncp dist/*.whl wheelhouse/\n\n# Sanitize and verify\nuv run python -m hephaestus.cli wheelhouse sanitize wheelhouse\nuv run python -m hephaestus.cli wheelhouse verify wheelhouse\n</code></pre>"},{"location":"how-to/ci-setup/#references","title":"References","text":"<ul> <li>uv Documentation</li> <li>setup-uv Action</li> <li>pip wheel</li> <li>GitHub Actions Artifacts</li> <li>Hephaestus Quality Gates</li> </ul>"},{"location":"how-to/ci-setup/#summary","title":"Summary","text":"<p>The Hephaestus CI pipeline provides:</p> <p>\u2705 Bulletproof dependency management through dual online/offline paths \u2705 Reproducible builds using uv.lock and wheelhouses \u2705 Comprehensive validation at every step \u2705 Clear error messages for quick debugging \u2705 Portable workflows that work in restricted environments \u2705 Fast feedback through parallel job execution \u2705 Developer-friendly setup scripts and documentation</p> <p>By following these practices, ephemeral runners will always have reliable access to all required dependencies, ensuring consistent and reproducible CI/CD runs.</p>"},{"location":"how-to/editor-setup/","title":"Editor Setup","text":"<p>Use these quick steps to align your editor with the tooling that ships in Hephaestus. The configuration keeps formatting, linting, and typing feedback consistent with CI so contributors see issues locally before they reach a pull request.</p>"},{"location":"how-to/editor-setup/#universal-settings","title":"Universal Settings","text":"<p>Hephaestus includes a project-wide <code>.editorconfig</code>. Most modern editors respect it automatically. If yours does not, install an EditorConfig plugin so indentation and whitespace behaviour match the repository defaults.</p> <p>Key defaults:</p> <ul> <li>UTF-8 encoding and LF line endings</li> <li>Four-space indentation for Python</li> <li>Two-space indentation for YAML, JSON, Markdown, shell scripts, and web assets</li> <li>Trailing whitespace trimmed on save and final newlines ensured</li> </ul>"},{"location":"how-to/editor-setup/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install the recommended extensions (VS Code prompts automatically when opening the workspace).</li> <li>Python (<code>ms-python.python</code>)</li> <li>Black Formatter (<code>ms-python.black-formatter</code>)</li> <li>Ruff (<code>charliermarsh.ruff</code>)</li> <li>Ruff Format (<code>charliermarsh.ruff-format</code>)</li> <li>Pylance (<code>ms-python.vscode-pylance</code>)</li> <li>UV (<code>astral-sh.uv</code>)</li> <li>Reload VS Code so the extensions activate, then run <code>uv sync --extra dev --extra qa</code> to install    tool dependencies.</li> <li>Enable the \"Format on Save\" option or add the following snippet to your user settings:</li> </ol> <pre><code>{\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.ruff\": \"explicit\"\n  }\n}\n</code></pre> <ol> <li>Install pre-commit hooks with <code>uv run pre-commit install</code> to keep linting and typing feedback in    sync with CI.</li> </ol>"},{"location":"how-to/editor-setup/#pycharm-intellij-idea","title":"PyCharm / IntelliJ IDEA","text":"<ul> <li>Install the EditorConfig plugin (bundled by default) and ensure \"Use tab character\" is   disabled for Python projects.</li> <li>Configure Black as the formatter and Ruff as an external tool or via the Ruff plugin to mirror the   command line experience.</li> <li>Point the interpreter at the UV-managed virtual environment (<code>.venv</code>) so type checking and pytest   discovery use the same dependencies as CI.</li> </ul>"},{"location":"how-to/editor-setup/#neovim","title":"Neovim","text":"<ul> <li>Install <code>editorconfig.nvim</code> (or equivalent) to honour the shared configuration.</li> <li>Use <code>null-ls</code> or <code>conform.nvim</code> to wire Black and Ruff formatters, and configure the <code>mypy</code> linter   through <code>nvim-lint</code> or <code>ALE</code> for inline typing diagnostics.</li> <li>Consider the <code>astral-sh/uv.nvim</code> plugin to manage environments with UV commands directly from   Neovim.</li> </ul>"},{"location":"how-to/editor-setup/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If Ruff or Black appear to conflict, run <code>uv run pre-commit run ruff-format --all-files</code> to reset   the workspace.</li> <li>If your editor cannot locate the virtual environment, create one with <code>uv sync --extra dev</code> and   reselect it in your IDE settings.</li> <li>For CI parity, always finish a feature branch by running the quickstart commands listed in   <code>README.md</code> or the pre-release checklist in <code>docs/pre-release-checklist.md</code>.</li> <li>Need the tooling without PyPI access? Run <code>uv run hephaestus release install</code> to download and   install the latest wheelhouse from GitHub Releases directly into your current environment.</li> </ul>"},{"location":"how-to/install-wheelhouse/","title":"How-To: Install Hephaestus from a Wheelhouse","text":"<p>Follow these steps when you want to consume the toolkit in a repository without cloning the full source tree or publishing to PyPI.</p>"},{"location":"how-to/install-wheelhouse/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or newer</li> <li>uv or <code>pip</code></li> <li>Access to the GitHub release that provides the wheelhouse archive</li> </ul>"},{"location":"how-to/install-wheelhouse/#1-locate-the-wheelhouse-asset","title":"1. Locate the Wheelhouse Asset","text":"<ol> <li>Visit the GitHub Releases page.</li> <li>Download the asset named similar to <code>hephaestus-&lt;version&gt;-wheelhouse.tar.gz</code>.</li> </ol>"},{"location":"how-to/install-wheelhouse/#2-install-via-the-cli-recommended","title":"2. Install via the CLI (Recommended)","text":"<p>The CLI handles download, extraction, checksum verification, and installation.</p> <pre><code>uv run hephaestus release install --tag &lt;tag&gt; --cleanup --remove-archive\n</code></pre> <ul> <li><code>--tag &lt;tag&gt;</code>: optional; defaults to the latest release.</li> <li><code>--cleanup</code>: removes the extracted wheelhouse directory after successful install.</li> <li><code>--remove-archive</code>: deletes the downloaded archive to keep caches tidy.</li> <li><code>--manifest-pattern</code>: override if your release uploads checksum manifests with a different name.</li> <li><code>--allow-unsigned</code>: opt out of checksum verification (not recommended except for trusted mirrors).</li> </ul> <p>By default the CLI requires a checksum manifest (matching <code>*wheelhouse*.sha256</code>) to be present in the release and fails closed if verification does not succeed. Store manifests next to the wheelhouse archives in GitHub Releases to keep installation automated and tamper-evident.</p> <p>To target a specific repository or self-hosted release mirror, override the repository and asset pattern:</p> <pre><code>uv run hephaestus release install \\\n  --repository your-org/Hephaestus-fork \\\n  --asset-pattern \"*wheelhouse*.tar.gz\"\n</code></pre>"},{"location":"how-to/install-wheelhouse/#3-install-manually-fallback","title":"3. Install Manually (Fallback)","text":"<p>If you cannot run the CLI, extract and install the wheels yourself:</p> <pre><code>mkdir -p wheelhouse\ntar -xzf hephaestus-&lt;version&gt;-wheelhouse.tar.gz -C wheelhouse\npython -m pip install wheelhouse/*.whl\n</code></pre>"},{"location":"how-to/install-wheelhouse/#4-verify-the-installation","title":"4. Verify the Installation","text":"<p>Confirm the CLI is available and report the version:</p> <pre><code>python -m hephaestus.cli version\n</code></pre> <p>or, if you installed with uv:</p> <pre><code>uv run hephaestus version\n</code></pre>"},{"location":"how-to/install-wheelhouse/#5-keep-the-toolkit-updated","title":"5. Keep the Toolkit Updated","text":"<ul> <li>Re-run the installation steps whenever a new release lands.</li> <li>Automate the process via CI by invoking <code>hephaestus release install</code> within your pipeline before   running CLI workflows.</li> <li>Combine with Dependabot or Renovate to receive alerts when new versions are published.</li> </ul>"},{"location":"how-to/install-wheelhouse/#troubleshooting","title":"Troubleshooting","text":"Symptom Fix <code>ReleaseError: asset not found</code> Check the <code>--asset-pattern</code> or confirm the release tag exists. <code>Checksum manifest could not be found</code> Upload the <code>*.sha256</code> manifest next to the wheelhouse asset or use <code>--allow-unsigned</code>. <code>Checksum verification failed</code> Re-upload the wheelhouse and manifest pair; ensure digests match exactly. <code>pip</code> times out or fails due to networking Pre-download the archive and use the manual install path. <code>wheel directory ... does not exist</code> Ensure the tarball extracted correctly and includes <code>*.whl</code> files. Import errors after install Activate the environment you installed into before running commands"},{"location":"how-to/observability/","title":"OpenTelemetry Integration Guide (ADR-0003)","text":"<p>Status: Phase 1 (Foundation) - Optional observability support</p>"},{"location":"how-to/observability/#overview","title":"Overview","text":"<p>Hephaestus supports optional OpenTelemetry integration for distributed tracing and observability. This is fully opt-in and disabled by default.</p>"},{"location":"how-to/observability/#quick-start","title":"Quick Start","text":""},{"location":"how-to/observability/#installation","title":"Installation","text":"<p>Install Hephaestus with telemetry support:</p> <pre><code>pip install hephaestus[telemetry]\n</code></pre>"},{"location":"how-to/observability/#basic-configuration","title":"Basic Configuration","text":"<p>Enable telemetry via environment variables:</p> <pre><code>export HEPHAESTUS_TELEMETRY_ENABLED=true\nexport OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318\nexport OTEL_SERVICE_NAME=hephaestus\n</code></pre>"},{"location":"how-to/observability/#running-with-telemetry","title":"Running with Telemetry","text":"<p>Once configured, run any Hephaestus command normally:</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>Telemetry data will be exported to your configured OTLP endpoint.</p>"},{"location":"how-to/observability/#configuration","title":"Configuration","text":""},{"location":"how-to/observability/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>HEPHAESTUS_TELEMETRY_ENABLED</code> Enable/disable telemetry <code>false</code> <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> OTLP collector endpoint None <code>OTEL_SERVICE_NAME</code> Service name for traces <code>hephaestus</code> <code>HEPHAESTUS_TELEMETRY_PRIVACY</code> Privacy mode (strict/balanced/minimal) <code>strict</code>"},{"location":"how-to/observability/#privacy-modes","title":"Privacy Modes","text":"<ul> <li>strict: Maximum anonymization, minimal data collection</li> <li>balanced: Anonymize sensitive paths and usernames</li> <li>minimal: Minimal anonymization, maximum visibility</li> </ul>"},{"location":"how-to/observability/#architecture","title":"Architecture","text":"<p>The telemetry module provides:</p> <ol> <li>No-op fallback: Works without OpenTelemetry installed</li> <li>Graceful degradation: Errors don't break functionality</li> <li>Environment-driven: All configuration via environment variables</li> <li>Privacy-first: Opt-in with anonymization support</li> </ol>"},{"location":"how-to/observability/#phase-1-limitations","title":"Phase 1 Limitations","text":"<p>Current Phase 1 implementation provides:</p> <ul> <li>\u2705 Module structure and API</li> <li>\u2705 No-op tracer fallback</li> <li>\u2705 Basic configuration</li> <li>\u274c Not yet: Actual instrumentation of commands</li> <li>\u274c Not yet: Metrics collection</li> <li>\u274c Not yet: Advanced privacy controls</li> </ul>"},{"location":"how-to/observability/#future-phases","title":"Future Phases","text":"<ul> <li>Phase 2 (v0.4.0): Instrument all CLI commands, add metrics</li> <li>Phase 3 (v0.5.0): Advanced sampling, custom metrics, plugin support</li> <li>Phase 4 (v0.6.0): Production-ready with analytics dashboard</li> </ul>"},{"location":"how-to/observability/#related-documentation","title":"Related Documentation","text":"<ul> <li>ADR-0003: OpenTelemetry Integration</li> <li>Architecture Overview</li> </ul>"},{"location":"how-to/operating-safely/","title":"Operating Safely with Hephaestus","text":"<p>This guide explains safety constraints, guard-rail workflows, and secure operational practices when using the Hephaestus toolkit.</p>"},{"location":"how-to/operating-safely/#cleanup-safety","title":"Cleanup Safety","text":"<p>The <code>hephaestus cleanup</code> command removes files and directories from your workspace. Understanding its safety features is critical to avoiding accidental data loss.</p>"},{"location":"how-to/operating-safely/#built-in-safety-features","title":"Built-in Safety Features","text":"<ol> <li> <p>Mandatory Preview: Every invocation runs a dry-run first and renders a Rich table preview so you can inspect pending deletions before anything touches disk.</p> </li> <li> <p>Typed Confirmation Outside the Root: If cleanup would touch paths outside the detected workspace root (e.g., <code>--extra-path /tmp</code>), the CLI pauses and requires you to type <code>CONFIRM</code> unless you pass <code>--yes</code> explicitly.</p> </li> <li> <p>Git Repository Detection: By default, cleanup operates from the git repository root. If no git repository is detected, it uses the current working directory.</p> </li> <li> <p>Excluded Paths: The <code>.git</code> directory is excluded by default unless you explicitly pass <code>--include-git</code>.</p> </li> <li> <p>Virtual Environment Protection: When cleaning build artifacts, the command preserves <code>.venv/site-packages</code> unless you're cleaning the virtual environment itself with <code>--include-poetry-env</code>.</p> </li> <li> <p>Audit Manifests: Successful runs emit a JSON manifest under <code>.hephaestus/audit/</code> (or the path provided to <code>--audit-manifest</code>) capturing the options, removals, skips, and errors for compliance reviews.</p> </li> </ol>"},{"location":"how-to/operating-safely/#dangerous-operations-to-avoid","title":"Dangerous Operations to Avoid","text":"<p>\u26a0\ufe0f Never use these patterns:</p> <pre><code># DON'T: Clean the root filesystem\nhephaestus cleanup /\n\n# DON'T: Clean your home directory\nhephaestus cleanup ~\nhephaestus cleanup /home/username\n\n# DON'T: Use wildcards or shell expansion with --extra-path\nhephaestus cleanup --extra-path \"*\"\n</code></pre>"},{"location":"how-to/operating-safely/#safe-usage-patterns","title":"Safe Usage Patterns","text":"<p>\u2705 Recommended patterns:</p> <pre><code># Clean current repository\nhephaestus cleanup\n\n# Clean specific subdirectory within the repo\nhephaestus cleanup ./subproject\n\n# Deep clean with all options\nhephaestus cleanup --deep-clean\n\n# Clean build artifacts only\nhephaestus cleanup --build-artifacts\n\n# Dry-run: Preview what would be removed without deleting anything\nhephaestus cleanup --dry-run --deep-clean\n</code></pre>"},{"location":"how-to/operating-safely/#extra-paths","title":"Extra Paths","text":"<p>The <code>--extra-path</code> flag adds directories to the cleanup scope. Always verify paths before using this flag:</p> <pre><code># Safe: Relative path within repository\nhephaestus cleanup --extra-path ./legacy/dist\n\n# Safe: Absolute path within repository\nhephaestus cleanup --extra-path /home/user/projects/myrepo/temp\n\n# UNSAFE: Path outside repository\nhephaestus cleanup --extra-path /tmp\n</code></pre>"},{"location":"how-to/operating-safely/#future-safety-enhancements","title":"Future Safety Enhancements","text":"<p>Recently delivered features include previews, typed confirmations, and audit manifests. Remaining roadmap items:</p> <ul> <li>Sigstore-backed manifests: Attach signed attestations to cleanup manifests for tamper detection.</li> <li>Undo checkpoints: Offer reversible trash-bin moves for supported platforms instead of hard deletions.</li> </ul>"},{"location":"how-to/operating-safely/#guard-rails-workflow","title":"Guard Rails Workflow","text":"<p>The <code>hephaestus guard-rails</code> command runs a comprehensive quality and security pipeline. It's designed to catch issues before they reach production.</p>"},{"location":"how-to/operating-safely/#what-guard-rails-does","title":"What Guard Rails Does","text":"<p>The guard-rails command executes these steps in order:</p> <ol> <li>Deep Cleanup: Removes all build artifacts, caches, and macOS metadata</li> <li>Lint: Checks code style and common errors with <code>ruff check</code></li> <li>Format: Auto-formats code with <code>ruff format</code> (skip with <code>--no-format</code>)</li> <li>Type Check: Validates type annotations with <code>mypy</code></li> <li>Test: Runs the pytest suite with coverage reporting</li> <li>Security Audit: Scans dependencies for known vulnerabilities with <code>pip-audit</code></li> </ol>"},{"location":"how-to/operating-safely/#when-to-use-guard-rails","title":"When to Use Guard Rails","text":"<p>Before committing:</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>Before opening a PR:</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>After pulling changes:</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>Skip formatting (useful for reviewing changes):</p> <pre><code>hephaestus guard-rails --no-format\n</code></pre> <p>Check for tool version drift:</p> <pre><code>hephaestus guard-rails --drift\n</code></pre>"},{"location":"how-to/operating-safely/#tool-version-drift-detection","title":"Tool Version Drift Detection","text":"<p>The <code>--drift</code> flag enables drift detection mode, which checks if your installed development tools match the versions specified in <code>pyproject.toml</code>.</p> <p>When to check for drift:</p> <ul> <li>After setting up a new development environment</li> <li>When CI builds start failing locally</li> <li>Before reporting \"works on my machine\" issues</li> <li>After system updates or Python version changes</li> </ul> <p>Example output:</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Tool       \u2503 Expected \u2503 Actual        \u2503 Status \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 ruff       \u2502 0.14.0   \u2502 0.14.5        \u2502 OK     \u2502\n\u2502 black      \u2502 25.9.0   \u2502 25.8.0        \u2502 Drift  \u2502\n\u2502 mypy       \u2502 1.18.2   \u2502 Not installed \u2502 Missing\u2502\n\u2502 pip-audit  \u2502 2.9.0    \u2502 2.9.0         \u2502 OK     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRemediation commands:\n  # Recommended: Use uv to sync dependencies\n  uv sync --extra dev --extra qa\n\n  # Or manually update individual tools:\n  pip install --upgrade black&gt;=25.9.0\n  pip install mypy&gt;=1.18.2\n</code></pre> <p>Drift detection rules:</p> <ul> <li>OK: Installed version matches expected major.minor (patch differences ignored)</li> <li>Drift: Installed version differs in major or minor version</li> <li>Missing: Tool not installed in environment</li> </ul> <p>The command exits with code 1 if any drift or missing tools are detected.</p> <pre><code>### Guard Rails in CI\n\nThe CI pipeline automatically runs guard rails on every push and pull request. Local execution ensures you catch issues before pushing.\n\n### Troubleshooting Guard Rails\n\nIf guard rails fail:\n\n1. **Lint failures**: Run `ruff check . --fix` to auto-fix issues\n2. **Format failures**: Run `ruff format .` to format code\n3. **Type failures**: Review mypy output and add/fix type annotations\n4. **Test failures**: Run `pytest -v` for detailed test output\n5. **Audit failures**: Review CVE details and update dependencies or add waivers\n\n## Release Verification\n\nWhen using `hephaestus release install`, follow these practices:\n\n### Verify Release Source\n\n```bash\n# Always specify the repository explicitly\nhephaestus release install --repository IAmJonoBo/Hephaestus\n\n# Pin to a specific tag for reproducibility\nhephaestus release install --tag v0.1.0\n</code></pre>"},{"location":"how-to/operating-safely/#network-security","title":"Network Security","text":"<p>The release command includes several security features:</p> <ul> <li>HTTPS only: All downloads use HTTPS</li> <li>Timeouts: Configurable timeouts prevent hanging (default: 30s)</li> <li>Retries: Automatic retry with exponential backoff (default: 3 attempts)</li> <li>Checksum verification: SHA-256 manifests are required unless you pass <code>--allow-unsigned</code></li> <li>Sigstore attestation: Sigstore bundles are downloaded and validated automatically; use <code>--require-sigstore</code> to fail closed if an attestation is missing, <code>--sigstore-identity</code> to pin trusted identities, and <code>--sigstore-pattern</code> to override bundle discovery when repositories publish custom naming schemes</li> <li>Token security: Use environment variables for GitHub tokens</li> </ul> <pre><code># Set token via environment variable\nexport GITHUB_TOKEN=ghp_your_token_here\nhephaestus release install\n\n# Or pass it as an option\nhephaestus release install --token ghp_your_token_here\n</code></pre>"},{"location":"how-to/operating-safely/#future-verification-features","title":"Future Verification Features","text":"<p>The following security enhancements are planned:</p> <ul> <li>Sigstore transparency policy enforcement: Record attestation metadata in audit logs and require identity policies per environment profile</li> <li>Signed cleanup manifests: Attach Sigstore attestations to cleanup JSON manifests for tamper detection</li> <li>Automated attestation publication: Backfill Sigstore bundles for historical releases and verify during CI before upload</li> </ul>"},{"location":"how-to/operating-safely/#secure-development-workflow","title":"Secure Development Workflow","text":""},{"location":"how-to/operating-safely/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks to catch issues early:</p> <pre><code>uv run pre-commit install\n</code></pre> <p>This automatically runs on every commit:</p> <ul> <li>Cleanup of macOS metadata</li> <li>Code formatting</li> <li>Linting</li> <li>Type checking</li> <li>Security audits</li> </ul>"},{"location":"how-to/operating-safely/#dependency-management","title":"Dependency Management","text":"<p>Regular updates:</p> <pre><code># Check for outdated dependencies\npip list --outdated\n\n# Run security audit\npip-audit --strict\n</code></pre> <p>Review Dependabot PRs:</p> <ul> <li>Always review dependency updates before merging</li> <li>Check changelogs for breaking changes</li> <li>Verify tests pass after updates</li> </ul>"},{"location":"how-to/operating-safely/#token-management","title":"Token Management","text":"<p>GitHub Token Permissions:</p> <p>For <code>hephaestus release install</code>, use a fine-grained personal access token with these read-only permissions:</p> <ul> <li>Contents: Read access to download release assets</li> <li>Metadata: Read access (automatically included)</li> </ul> <p>For classic tokens, use the minimal <code>public_repo</code> scope (or <code>repo</code> for private repositories).</p> <p>Best practices:</p> <ul> <li>Store tokens in environment variables or password managers</li> <li>Use fine-grained GitHub tokens with minimal permissions</li> <li>Rotate tokens regularly (recommended: every 90 days)</li> <li>Never commit tokens to version control</li> <li>Set token expiration dates to limit exposure window</li> </ul>"},{"location":"how-to/operating-safely/#cicd-security","title":"CI/CD Security","text":"<p>Secrets management:</p> <ul> <li>Use GitHub Secrets for sensitive values</li> <li>Never log tokens or credentials</li> <li>Audit workflow permissions regularly</li> </ul>"},{"location":"how-to/operating-safely/#incident-response","title":"Incident Response","text":"<p>If you discover a security issue:</p> <ol> <li>Stop: Don't push compromised code</li> <li>Report: Follow the disclosure process in SECURITY.md</li> <li>Rotate: Change any exposed credentials immediately</li> <li>Review: Check git history for sensitive data</li> <li>Clean: Use <code>git filter-branch</code> or BFG Repo-Cleaner to remove secrets</li> </ol>"},{"location":"how-to/operating-safely/#rollback-procedures","title":"Rollback Procedures","text":"<p>If a bad release is deployed:</p> <ol> <li>Identify the issue: Review release notes and changelogs</li> <li>Pin to last known good version:    <pre><code>hephaestus release install --tag v0.0.9\n</code></pre></li> <li>Report the issue: Open a GitHub issue with details</li> <li>Document learnings: Update documentation and tests</li> </ol>"},{"location":"how-to/operating-safely/#release-revocation-future","title":"Release Revocation (Future)","text":"<p>The following rollback features are planned:</p> <ul> <li>Automated release deletion from GitHub</li> <li>Security advisory publication</li> <li>Coordinated disclosure timeline</li> <li>Rollback automation in CI</li> </ul>"},{"location":"how-to/operating-safely/#monitoring-and-telemetry","title":"Monitoring and Telemetry","text":""},{"location":"how-to/operating-safely/#current-logging","title":"Current Logging","text":"<p>Hephaestus logs to stdout/stderr using Rich formatting. Key events are highlighted:</p> <ul> <li>Green: Successful operations</li> <li>Yellow: Warnings and skipped operations</li> <li>Red: Errors and failures</li> <li>Cyan: Informational messages</li> </ul>"},{"location":"how-to/operating-safely/#future-telemetry","title":"Future Telemetry","text":"<p>Planned observability features:</p> <ul> <li>Structured JSON logs: Machine-parseable event streams</li> <li>OpenTelemetry spans: Distributed tracing for CLI operations</li> <li>Anonymous metrics: Aggregated usage statistics (opt-in)</li> <li>Failure tracking: Network errors, timeout counts, retry attempts</li> </ul> <p>All telemetry will be:</p> <ul> <li>Opt-in: Disabled by default, enabled via environment flag</li> <li>Privacy-preserving: No sensitive data or PII</li> <li>Transparent: Full disclosure of what's collected</li> </ul>"},{"location":"how-to/operating-safely/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: See <code>docs/</code> for detailed guides</li> <li>Issues: Open a GitHub issue for bugs or feature requests</li> <li>Security: Email opensource@hephaestus.dev for security concerns</li> <li>Community: Check existing issues and discussions</li> </ul>"},{"location":"how-to/operating-safely/#summary-checklist","title":"Summary Checklist","text":"<p>Before running potentially destructive operations:</p> <ul> <li> Verify you're in the correct directory</li> <li> Review paths and arguments carefully</li> <li> Check for typos in path specifications</li> <li> Consider running without <code>--deep-clean</code> first</li> <li> Ensure critical work is committed to git</li> <li> Have backups of important data</li> </ul> <p>Remember: Hephaestus is a powerful tool. With power comes responsibility. Stay safe! \ud83d\udee1\ufe0f</p>"},{"location":"how-to/plugin-development/","title":"Plugin Development Guide (ADR-0002)","text":"<p>Status: Phase 1 (Foundation) - API specification only</p>"},{"location":"how-to/plugin-development/#overview","title":"Overview","text":"<p>Hephaestus supports a plugin architecture for extending quality gates with custom checks. This allows teams to add project-specific quality gates without modifying Hephaestus core.</p>"},{"location":"how-to/plugin-development/#quick-start","title":"Quick Start","text":""},{"location":"how-to/plugin-development/#example-plugin","title":"Example Plugin","text":"<pre><code>from hephaestus.plugins import QualityGatePlugin, PluginMetadata, PluginResult\n\nclass MyCustomPlugin(QualityGatePlugin):\n    \"\"\"Example custom quality gate plugin.\"\"\"\n\n    @property\n    def metadata(self) -&gt; PluginMetadata:\n        return PluginMetadata(\n            name=\"my-custom-check\",\n            version=\"1.0.0\",\n            description=\"My custom quality check\",\n            author=\"Your Name\",\n            category=\"custom\",\n            requires=[],  # Python dependencies\n            order=100,  # Execution order (lower = earlier)\n        )\n\n    def validate_config(self, config: dict) -&gt; bool:\n        \"\"\"Validate plugin configuration.\"\"\"\n        # Check that required config keys exist\n        return True\n\n    def run(self, config: dict) -&gt; PluginResult:\n        \"\"\"Execute the quality check.\"\"\"\n        # Perform your custom check\n        success = True  # Replace with actual logic\n\n        return PluginResult(\n            success=success,\n            message=\"Custom check passed\",\n            details={\"files_checked\": 42},\n            exit_code=0 if success else 1,\n        )\n</code></pre>"},{"location":"how-to/plugin-development/#plugin-api","title":"Plugin API","text":""},{"location":"how-to/plugin-development/#pluginmetadata","title":"PluginMetadata","text":"<p>Describes your plugin:</p> <pre><code>@dataclass\nclass PluginMetadata:\n    name: str          # Unique plugin identifier\n    version: str       # Semantic version\n    description: str   # Human-readable description\n    author: str        # Author name\n    category: str      # \"linting\", \"testing\", \"security\", \"custom\"\n    requires: list[str]  # Python package dependencies\n    order: int = 100   # Execution order (lower runs first)\n</code></pre>"},{"location":"how-to/plugin-development/#pluginresult","title":"PluginResult","text":"<p>Returned from <code>run()</code> method:</p> <pre><code>@dataclass\nclass PluginResult:\n    success: bool                # Did the check pass?\n    message: str                 # Status message\n    details: dict | None = None  # Additional data\n    exit_code: int = 0          # Process exit code\n</code></pre>"},{"location":"how-to/plugin-development/#qualitygateplugin","title":"QualityGatePlugin","text":"<p>Base class for all plugins:</p> <pre><code>class QualityGatePlugin(ABC):\n    @property\n    @abstractmethod\n    def metadata(self) -&gt; PluginMetadata:\n        \"\"\"Return plugin metadata.\"\"\"\n        pass\n\n    @abstractmethod\n    def validate_config(self, config: dict) -&gt; bool:\n        \"\"\"Validate plugin configuration.\"\"\"\n        pass\n\n    @abstractmethod\n    def run(self, config: dict) -&gt; PluginResult:\n        \"\"\"Execute the quality gate check.\"\"\"\n        pass\n\n    def setup(self) -&gt; None:\n        \"\"\"Optional: Setup before running.\"\"\"\n        pass\n\n    def teardown(self) -&gt; None:\n        \"\"\"Optional: Cleanup after running.\"\"\"\n        pass\n</code></pre>"},{"location":"how-to/plugin-development/#plugin-registry","title":"Plugin Registry","text":"<p>Register and manage plugins:</p> <pre><code>from hephaestus.plugins import registry\n\n# Register a plugin\nplugin = MyCustomPlugin()\nregistry.register(plugin)\n\n# Check if registered\nif registry.is_registered(\"my-custom-check\"):\n    plugin = registry.get(\"my-custom-check\")\n\n# Get all plugins (sorted by order)\nall_plugins = registry.all_plugins()\n</code></pre>"},{"location":"how-to/plugin-development/#phase-1-limitations","title":"Phase 1 Limitations","text":"<p>Current Phase 1 implementation provides:</p> <ul> <li>\u2705 Plugin API specification</li> <li>\u2705 Base classes and interfaces</li> <li>\u2705 Plugin registry</li> <li>\u274c Not yet: Plugin discovery</li> <li>\u274c Not yet: Configuration file support</li> <li>\u274c Not yet: Built-in plugins</li> <li>\u274c Not yet: Integration with guard-rails command</li> </ul>"},{"location":"how-to/plugin-development/#future-phases","title":"Future Phases","text":"<ul> <li>Phase 2 (v0.4.0): Refactor existing gates to plugins, add discovery</li> <li>Phase 3 (v0.5.0): Plugin catalog, example plugins, documentation</li> <li>Phase 4 (v0.6.0): Marketplace, versioning, dependency resolution</li> </ul>"},{"location":"how-to/plugin-development/#best-practices","title":"Best Practices","text":"<ol> <li>Keep plugins focused: One check per plugin</li> <li>Use descriptive names: Clear, unique plugin names</li> <li>Validate configuration: Check all required config in <code>validate_config()</code></li> <li>Handle errors gracefully: Catch exceptions and return failed result</li> <li>Document thoroughly: Clear docstrings and metadata</li> <li>Test extensively: Unit tests for all plugin functionality</li> </ol>"},{"location":"how-to/plugin-development/#related-documentation","title":"Related Documentation","text":"<ul> <li>ADR-0002: Plugin Architecture</li> <li>Quality Gates Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"how-to/quality-gates/","title":"Quality Gate Validation","text":"<p>This guide explains how to use Hephaestus's comprehensive quality gate validation system to ensure frontier-level code quality.</p>"},{"location":"how-to/quality-gates/#overview","title":"Overview","text":"<p>The Hephaestus project enforces strict quality standards through automated checks that run locally and in CI. These checks catch issues early and ensure consistent quality across all contributions.</p>"},{"location":"how-to/quality-gates/#quick-start","title":"Quick Start","text":""},{"location":"how-to/quality-gates/#validate-all-quality-gates","title":"Validate All Quality Gates","text":"<p>Run all quality checks with a single command:</p> <pre><code>python3 scripts/validate_quality_gates.py\n</code></pre> <p>This runs:</p> <ul> <li>Pytest with coverage \u226585%</li> <li>Ruff linting</li> <li>Ruff formatting checks</li> <li>YAML linting with yamllint</li> <li>Mypy type checking</li> <li>Nested decorator linting</li> <li>Workflow validation with actionlint (optional)</li> <li>Build artifact generation</li> <li>Security auditing (when available)</li> </ul>"},{"location":"how-to/quality-gates/#use-guard-rails-command","title":"Use Guard Rails Command","text":"<p>The <code>guard-rails</code> command provides an integrated workflow:</p> <pre><code>uv run hephaestus guard-rails\n</code></pre> <p>This performs:</p> <ol> <li>Deep cleanup of build artifacts</li> <li>Ruff linting with auto-fix</li> <li>Ruff formatting</li> <li>YAML linting with yamllint</li> <li>Mypy type checking</li> <li>Full test suite with coverage</li> <li>Security audit with pip-audit</li> </ol>"},{"location":"how-to/quality-gates/#individual-quality-gates","title":"Individual Quality Gates","text":""},{"location":"how-to/quality-gates/#testing","title":"Testing","text":"<p>Run the test suite with coverage:</p> <pre><code>uv run pytest\n</code></pre> <p>Requirements:</p> <ul> <li>All tests must pass</li> <li>Coverage must be \u226585%</li> <li>No warnings allowed (treated as errors)</li> </ul>"},{"location":"how-to/quality-gates/#linting","title":"Linting","text":"<p>Check code style:</p> <pre><code>uv run ruff check .\n</code></pre> <p>Auto-fix issues:</p> <pre><code>uv run ruff check --fix .\n</code></pre> <p>Ruff's fixer also normalizes import ordering, so no separate isort pass is required.</p>"},{"location":"how-to/quality-gates/#formatting","title":"Formatting","text":"<p>Check formatting:</p> <pre><code>uv run ruff format --check .\n</code></pre> <p>Apply formatting:</p> <pre><code>uv run ruff format .\n</code></pre>"},{"location":"how-to/quality-gates/#yaml-linting","title":"YAML Linting","text":"<p>Lint YAML files for consistency and correctness:</p> <pre><code>uv run yamllint -c .trunk/configs/.yamllint.yaml .github/ .pre-commit-config.yaml mkdocs.yml hephaestus-toolkit/\n</code></pre> <p>Requirements:</p> <ul> <li>Uses custom configuration from <code>.trunk/configs/.yamllint.yaml</code></li> <li>Checks workflow files, configuration files, and documentation</li> <li>Enforces consistent quote usage and structure</li> </ul>"},{"location":"how-to/quality-gates/#type-checking","title":"Type Checking","text":"<p>Verify type annotations:</p> <pre><code>uv run mypy src tests\n</code></pre> <p>Requirements:</p> <ul> <li>Strict mode enabled</li> <li>All functions must have type annotations</li> <li>No <code>Any</code> types unless explicitly justified</li> </ul>"},{"location":"how-to/quality-gates/#nested-decorator-check","title":"Nested Decorator Check","text":"<p>Prevent command registration bugs:</p> <pre><code>python3 scripts/lint_nested_decorators.py src/hephaestus\n</code></pre> <p>This ensures Typer commands are defined at module scope, not nested inside other functions. See the red team findings in <code>Next_Steps.md</code> for context on the guard-rails availability bug this prevents.</p>"},{"location":"how-to/quality-gates/#workflow-validation-actionlint","title":"Workflow Validation (actionlint)","text":"<p>Validate GitHub Actions workflows:</p> <pre><code>bash scripts/run_actionlint.sh\n</code></pre> <p>This optional check:</p> <ul> <li>Automatically installs actionlint if not present</li> <li>Validates workflow syntax and structure</li> <li>Checks for deprecated actions</li> <li>Reports shellcheck issues in workflow scripts</li> </ul> <p>Note: This is an optional quality gate. The script will download actionlint on first run.</p>"},{"location":"how-to/quality-gates/#security-audit","title":"Security Audit","text":"<p>Audit dependencies for vulnerabilities:</p> <pre><code>uv run pip-audit --strict --ignore-vuln GHSA-4xh5-x5gv-qwph\n</code></pre> <p>Note: This check may fail in containerized environments without proper SSL certificate chains.</p>"},{"location":"how-to/quality-gates/#build-artifacts","title":"Build Artifacts","text":"<p>Verify the package builds correctly:</p> <pre><code>uv run uv build\n</code></pre> <p>Or with standard tooling:</p> <pre><code>python3 -m build\n</code></pre>"},{"location":"how-to/quality-gates/#ci-integration","title":"CI Integration","text":"<p>All quality gates run automatically in CI on:</p> <ul> <li>Pull requests</li> <li>Pushes to main</li> </ul> <p>The CI pipeline matrix tests against:</p> <ul> <li>Python 3.12</li> <li>Python 3.13</li> </ul>"},{"location":"how-to/quality-gates/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks for local validation:</p> <pre><code>uv run pre-commit install\n</code></pre> <p>This runs on every commit:</p> <ul> <li>Ruff linting and formatting</li> <li>Black formatting</li> <li>Pyupgrade modernization</li> <li>Mypy type checking</li> <li>pip-audit security scanning</li> <li>Nested decorator linting</li> <li>Hephaestus cleanup</li> </ul>"},{"location":"how-to/quality-gates/#quality-standards","title":"Quality Standards","text":""},{"location":"how-to/quality-gates/#frontier-level-requirements","title":"Frontier-Level Requirements","text":"<ul> <li>Zero Tolerance: No linting errors, type errors, or test failures</li> <li>High Coverage: \u226585% test coverage maintained</li> <li>Security First: All dependencies audited, vulnerabilities addressed</li> <li>Type Safety: Full type coverage with strict Mypy</li> <li>Documentation: All features documented following Di\u00e1taxis</li> </ul>"},{"location":"how-to/quality-gates/#progressive-enhancement","title":"Progressive Enhancement","text":"<p>While all gates are enforced, some are optional in certain environments:</p> <ul> <li>pip-audit: May fail in containers without SSL certificates (non-blocking)</li> <li>Nested decorator check: Critical - blocks merges if violations found</li> </ul>"},{"location":"how-to/quality-gates/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/quality-gates/#coverage-below-threshold","title":"Coverage Below Threshold","text":"<pre><code># See which lines need coverage\nuv run pytest --cov-report=term-missing\n\n# Generate HTML report for detailed analysis\nuv run pytest --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"how-to/quality-gates/#type-check-failures","title":"Type Check Failures","text":"<pre><code># Check specific file\nuv run mypy src/hephaestus/file.py\n\n# Show error codes for targeted fixes\nuv run mypy --show-error-codes src\n</code></pre>"},{"location":"how-to/quality-gates/#nested-decorator-violations","title":"Nested Decorator Violations","text":"<p>If the linter reports nested decorators:</p> <ol> <li>Move the command function to module scope</li> <li>Remove it from inside any parent function</li> <li>Ensure it's defined at the top level of the module</li> </ol> <p>Example fix:</p> <pre><code># \u274c Bad - nested inside function\ndef parent_function():\n    @app.command()\n    def nested_command():\n        pass\n\n# \u2705 Good - at module scope\n@app.command()\ndef module_level_command():\n    pass\n</code></pre>"},{"location":"how-to/quality-gates/#best-practices","title":"Best Practices","text":"<ol> <li>Run locally first: Always validate before pushing</li> <li>Fix incrementally: Address issues as they appear</li> <li>Watch test order: Use <code>pytest-randomly</code> to catch order dependencies</li> <li>Review coverage: Don't just meet the threshold, aim for meaningful tests</li> <li>Update docs: Document new features as you build them</li> </ol>"},{"location":"how-to/quality-gates/#related-documentation","title":"Related Documentation","text":"<ul> <li>Operating Safely: Safety features and best practices</li> <li>Architecture: Component design and boundaries</li> <li>Frontier Analysis: Security assessment</li> <li>Pre-release Checklist: Release validation steps</li> </ul>"},{"location":"how-to/release-process/","title":"Release Process Guide","text":"<p>This guide explains how to release new versions of Hephaestus.</p>"},{"location":"how-to/release-process/#overview","title":"Overview","text":"<p>Hephaestus uses automated release workflows with manual preparation steps. The release process is designed to be safe, repeatable, and auditable.</p>"},{"location":"how-to/release-process/#release-types","title":"Release Types","text":"<ul> <li>Major (X.0.0): Breaking changes, incompatible API changes</li> <li>Minor (0.X.0): New features, backward compatible</li> <li>Patch (0.0.X): Bug fixes, backward compatible</li> </ul>"},{"location":"how-to/release-process/#automated-vs-manual","title":"Automated vs Manual","text":"<p>Automated (via GitHub Actions):</p> <ul> <li>Tag creation and pushing</li> <li>GitHub Release creation</li> <li>Wheelhouse building and packaging</li> <li>Asset attachment to releases</li> </ul> <p>Manual (requires human):</p> <ul> <li>Version number decision</li> <li>CHANGELOG updates</li> <li>Code changes and commits</li> <li>Quality validation</li> <li>PR review and merge</li> </ul>"},{"location":"how-to/release-process/#quick-release-patch","title":"Quick Release (Patch)","text":"<p>For simple patch releases with bug fixes:</p> <pre><code># 1. Update version\nvim pyproject.toml  # Change version to X.Y.Z\n\n# 2. Update CHANGELOG\nvim CHANGELOG.md  # Add new version section\n\n# 3. Commit and push to main\ngit add pyproject.toml CHANGELOG.md\ngit commit -m \"chore: Prepare release vX.Y.Z\"\ngit push origin main\n\n# 4. Automation takes over (tag, release, wheelhouse)\n</code></pre>"},{"location":"how-to/release-process/#full-release-process-minormajor","title":"Full Release Process (Minor/Major)","text":""},{"location":"how-to/release-process/#phase-1-planning","title":"Phase 1: Planning","text":"<ol> <li>Review completed work:</li> <li>Check closed PRs since last release</li> <li>Review <code>Next_Steps.md</code> for completed items</li> <li> <p>Identify breaking changes (major) vs new features (minor)</p> </li> <li> <p>Choose version number:</p> </li> <li>Follow Semantic Versioning</li> <li>Check current version: <code>grep version pyproject.toml</code></li> <li> <p>Decide: Major? Minor? Patch?</p> </li> <li> <p>Create milestone/project board:</p> </li> <li>Group related issues/PRs</li> <li>Track completion status</li> </ol>"},{"location":"how-to/release-process/#phase-2-preparation","title":"Phase 2: Preparation","text":"<ol> <li>Create release branch (for major/minor):</li> </ol> <pre><code>git checkout main\ngit pull origin main\ngit checkout -b release/vX.Y.Z\n</code></pre> <ol> <li>Update version number:</li> </ol> <pre><code># Edit pyproject.toml\nvim pyproject.toml\n\n# Change version field\n[project]\nversion = \"X.Y.Z\"\n</code></pre> <ol> <li>Update CHANGELOG.md:</li> </ol> <pre><code>## [X.Y.Z] - YYYY-MM-DD\n\n### Added\n\n- New feature descriptions\n\n### Changed\n\n- Breaking changes (if major)\n- Non-breaking changes\n\n### Fixed\n\n- Bug fixes\n\n### Security\n\n- Security improvements\n</code></pre> <ol> <li>Update documentation:</li> <li>README.md \"What's New\" section</li> <li>Getting started guide (if needed)</li> <li>Migration guide (if breaking changes)</li> <li> <p>API reference (if API changes)</p> </li> <li> <p>Run quality gates:</p> </li> </ol> <pre><code># Clean workspace\nhephaestus cleanup --deep-clean\n\n# Check for drift\nhephaestus guard-rails --drift\n\n# Run all quality checks\nhephaestus guard-rails\n\n# Validate all gates\npython3 scripts/validate_quality_gates.py\n</code></pre> <ol> <li>Commit changes:</li> </ol> <pre><code>git add .\ngit commit -m \"chore: Prepare release vX.Y.Z\n\n- Update version to X.Y.Z\n- Update CHANGELOG with release notes\n- Update documentation\n- [Additional changes]\n\"\n</code></pre>"},{"location":"how-to/release-process/#phase-3-review","title":"Phase 3: Review","text":"<ol> <li>Push release branch:</li> </ol> <pre><code>git push origin release/vX.Y.Z\n</code></pre> <ol> <li>Create Pull Request:</li> <li>Title: <code>Release vX.Y.Z</code></li> <li>Description: Copy highlights from CHANGELOG</li> <li>Labels: <code>release</code>, <code>documentation</code></li> <li> <p>Assignees: Release manager + reviewer</p> </li> <li> <p>PR Review checklist:</p> </li> <li> Version number correct</li> <li> CHANGELOG complete and accurate</li> <li> Documentation updated</li> <li> All CI checks pass</li> <li> Test coverage maintained (\u226585%)</li> <li> No security vulnerabilities</li> <li> <p> Breaking changes documented (if major)</p> </li> <li> <p>Address feedback:</p> </li> <li>Make requested changes</li> <li>Push updates to release branch</li> <li> <p>Re-request review</p> </li> <li> <p>Merge PR:</p> </li> <li>Use \"Squash and merge\" or \"Merge commit\"</li> <li>Ensure commit message is clean</li> <li>Delete release branch after merge</li> </ol>"},{"location":"how-to/release-process/#phase-4-automated-release","title":"Phase 4: Automated Release","text":"<p>Once merged to main, automation triggers:</p> <ol> <li>Automated Release Tagging workflow:</li> <li>Detects version change in <code>pyproject.toml</code></li> <li>Runs cleanup</li> <li>Creates git tag <code>vX.Y.Z</code></li> <li>Pushes tag to GitHub</li> <li> <p>Creates GitHub Release with auto-generated notes</p> </li> <li> <p>Build Wheelhouse workflow:</p> </li> <li>Triggers on release publication</li> <li>Builds package with <code>uv build</code></li> <li>Creates wheelhouse archive</li> <li>Uploads as workflow artifact</li> <li>Attaches to GitHub Release</li> </ol>"},{"location":"how-to/release-process/#phase-5-post-release","title":"Phase 5: Post-Release","text":"<ol> <li>Verify release:</li> </ol> <pre><code># Check tag exists\ngit fetch --tags\ngit tag | grep vX.Y.Z\n\n# Check GitHub Release\ngh release view vX.Y.Z\n\n# Check wheelhouse attached\ngh release view vX.Y.Z --json assets\n</code></pre> <ol> <li>Test installation:</li> </ol> <pre><code># In a fresh environment\nhephaestus release install --repository IAmJonoBo/Hephaestus --tag vX.Y.Z\n\n# Verify version\nhephaestus --version\n\n# Smoke test\nhephaestus --help\nhephaestus guard-rails --drift\n</code></pre> <ol> <li>Update tracking:</li> <li>Close milestone</li> <li>Update project board</li> <li> <p>Mark issues as released</p> </li> <li> <p>Communicate:</p> </li> <li>Post release announcement</li> <li>Update team/stakeholders</li> <li>Tweet/blog (if appropriate)</li> </ol>"},{"location":"how-to/release-process/#hotfix-process","title":"Hotfix Process","text":"<p>For urgent bug fixes that can't wait for next planned release:</p> <ol> <li>Create hotfix branch from tag:</li> </ol> <pre><code>git checkout -b hotfix/vX.Y.Z+1 vX.Y.Z\n</code></pre> <ol> <li>Apply fix:</li> <li>Make minimal changes</li> <li>Add regression test</li> <li> <p>Update CHANGELOG</p> </li> <li> <p>Fast-track review:</p> </li> <li>Create PR to main</li> <li>Mark as urgent</li> <li> <p>Get expedited review</p> </li> <li> <p>Release immediately:</p> </li> <li>Follow normal release process</li> <li>Communicate urgency in release notes</li> </ol>"},{"location":"how-to/release-process/#emergency-rollback","title":"Emergency Rollback","text":"<p>If critical issues discovered after release:</p> <ol> <li>Assess severity:</li> <li>Data loss/corruption: CRITICAL</li> <li>Security vulnerability: CRITICAL</li> <li>Broken functionality: HIGH</li> <li> <p>Performance degradation: MEDIUM</p> </li> <li> <p>For CRITICAL issues:</p> </li> </ol> <pre><code># Delete release\ngh release delete vX.Y.Z --yes\n\n# Delete tag locally\ngit tag -d vX.Y.Z\n\n# Delete tag remotely\ngit push origin :refs/tags/vX.Y.Z\n\n# Notify users immediately\n</code></pre> <ol> <li>Publish security advisory (if needed):</li> <li>Use <code>.github/SECURITY.md</code> process</li> <li>Follow disclosure template</li> <li> <p>Coordinate with users</p> </li> <li> <p>Prepare fixed release:</p> </li> <li>Follow hotfix process</li> <li>Increment patch version</li> <li>Clearly document fix in CHANGELOG</li> </ol> <p>See <code>.github/RELEASE_CHECKLIST_TEMPLATE.md</code> for detailed rollback procedures.</p>"},{"location":"how-to/release-process/#release-checklist","title":"Release Checklist","text":"<p>Before each release, complete the checklist in <code>.github/RELEASE_CHECKLIST_TEMPLATE.md</code>:</p> <pre><code># Copy template\ncp .github/RELEASE_CHECKLIST_TEMPLATE.md .github/RELEASE_CHECKLIST_v{X.Y.Z}.md\n\n# Fill out checklist\nvim .github/RELEASE_CHECKLIST_v{X.Y.Z}.md\n\n# Track progress\ngit add .github/RELEASE_CHECKLIST_v{X.Y.Z}.md\ngit commit -m \"chore: Add release checklist for vX.Y.Z\"\n</code></pre>"},{"location":"how-to/release-process/#automation-details","title":"Automation Details","text":""},{"location":"how-to/release-process/#automated-release-tagging","title":"Automated Release Tagging","text":"<p>Workflow: <code>.github/workflows/release-tag.yml</code></p> <p>Triggers: Push to <code>main</code> branch</p> <p>Actions:</p> <ol> <li>Checkout repository</li> <li>Install uv</li> <li>Run cleanup</li> <li>Extract version from <code>pyproject.toml</code></li> <li>Check if tag already exists</li> <li>Create and push tag (if new)</li> <li>Create GitHub Release with generated notes</li> </ol> <p>Requirements:</p> <ul> <li>Version in <code>pyproject.toml</code> must be new</li> <li>Workflow requires <code>contents: write</code> permission</li> </ul>"},{"location":"how-to/release-process/#build-wheelhouse","title":"Build Wheelhouse","text":"<p>Workflow: <code>.github/workflows/publish.yml</code></p> <p>Triggers: Release published</p> <p>Actions:</p> <ol> <li>Checkout repository at release tag</li> <li>Set up Python 3.12</li> <li>Install uv and sync dependencies</li> <li>Run cleanup</li> <li>Build package with <code>uv build</code></li> <li>Create wheelhouse archive</li> <li>Upload as workflow artifact</li> <li>Attach to GitHub Release</li> </ol> <p>Artifacts:</p> <ul> <li><code>hephaestus-{version}-wheelhouse.tar.gz</code></li> <li>Retained for 30 days in workflow artifacts</li> <li>Permanently attached to release</li> </ul>"},{"location":"how-to/release-process/#version-bumping-script","title":"Version Bumping Script","text":"<p>For convenience, use this script to bump version:</p> <pre><code>#!/usr/bin/env bash\n# scripts/bump_version.sh\n\nset -euo pipefail\n\nif [ $# -ne 1 ]; then\n    echo \"Usage: $0 &lt;version&gt;\"\n    echo \"Example: $0 0.3.0\"\n    exit 1\nfi\n\nVERSION=\"$1\"\n\n# Validate version format\nif ! [[ \"$VERSION\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n    echo \"Error: Invalid version format. Use X.Y.Z\"\n    exit 1\nfi\n\necho \"Bumping version to $VERSION...\"\n\n# Update pyproject.toml\nsed -i.bak \"s/^version = \\\".*\\\"/version = \\\"$VERSION\\\"/\" pyproject.toml\nrm pyproject.toml.bak\n\n# Update __init__.py if it has version\nif grep -q \"__version__\" src/hephaestus/__init__.py; then\n    sed -i.bak \"s/__version__ = \\\".*\\\"/__version__ = \\\"$VERSION\\\"/\" src/hephaestus/__init__.py\n    rm src/hephaestus/__init__.py.bak\nfi\n\necho \"Version bumped to $VERSION\"\necho \"\"\necho \"Next steps:\"\necho \"1. Update CHANGELOG.md\"\necho \"2. git add pyproject.toml CHANGELOG.md\"\necho \"3. git commit -m 'chore: Prepare release v$VERSION'\"\necho \"4. git push origin main\"\n</code></pre>"},{"location":"how-to/release-process/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/release-process/#tag-already-exists","title":"Tag Already Exists","text":"<pre><code># Delete local tag\ngit tag -d vX.Y.Z\n\n# Delete remote tag\ngit push origin :refs/tags/vX.Y.Z\n\n# Try again\n</code></pre>"},{"location":"how-to/release-process/#workflow-failed","title":"Workflow Failed","text":"<ol> <li>Check workflow logs in GitHub Actions</li> <li>Common issues:</li> <li>Network timeout: Re-run workflow</li> <li>Test failure: Fix tests before release</li> <li>Permission error: Check workflow permissions</li> </ol>"},{"location":"how-to/release-process/#release-notes-empty","title":"Release Notes Empty","text":"<p>GitHub auto-generates notes from PR titles. Ensure PRs have:</p> <ul> <li>Clear, descriptive titles</li> <li>Proper labels (enhancement, bug, documentation)</li> <li>Milestone assigned</li> </ul>"},{"location":"how-to/release-process/#wheelhouse-not-attached","title":"Wheelhouse Not Attached","text":"<ol> <li>Check Build Wheelhouse workflow status</li> <li>Verify release was published (not draft)</li> <li>Check workflow artifacts for archive</li> <li>Manually attach if needed:    <pre><code>gh release upload vX.Y.Z path/to/wheelhouse.tar.gz\n</code></pre></li> </ol>"},{"location":"how-to/release-process/#best-practices","title":"Best Practices","text":"<ol> <li>Release regularly: Small, frequent releases are better than large, infrequent ones</li> <li>Test thoroughly: Use the release checklist every time</li> <li>Communicate clearly: Write good CHANGELOG entries</li> <li>Document breaking changes: Be explicit about what breaks</li> <li>Monitor post-release: Watch for issues in the first 24 hours</li> <li>Learn from mistakes: Update this guide based on experience</li> </ol>"},{"location":"how-to/release-process/#related-documentation","title":"Related Documentation","text":"<ul> <li>Release Checklist Template</li> <li>Pre-Release Checklist</li> <li>CHANGELOG</li> <li>Semantic Versioning</li> <li>GitHub Release Documentation</li> </ul>"},{"location":"how-to/release-process/#questions","title":"Questions?","text":"<ul> <li>Check existing releases for examples</li> <li>Review past release PRs</li> <li>Consult with previous release managers</li> <li>Open a discussion on GitHub</li> </ul> <p>Remember: Releases should be boring. If it's exciting, something went wrong. \u2705</p>"},{"location":"how-to/testing/","title":"Testing Guide","text":"<p>This guide explains the testing philosophy, structure, and best practices for Hephaestus.</p>"},{"location":"how-to/testing/#overview","title":"Overview","text":"<p>Hephaestus maintains high test coverage (\u226585%) with comprehensive test suites covering:</p> <ul> <li>CLI commands and workflows</li> <li>Core functionality (cleanup, release, analytics)</li> <li>Edge cases and error conditions</li> <li>Integration patterns</li> </ul>"},{"location":"how-to/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_cli.py                  # CLI command tests\n\u251c\u2500\u2500 test_cleanup.py              # Cleanup safety and functionality\n\u251c\u2500\u2500 test_release.py              # Release verification and security\n\u251c\u2500\u2500 test_analytics.py            # Ranking strategies and adapters\n\u251c\u2500\u2500 test_schema.py               # Schema export and validation\n\u251c\u2500\u2500 test_drift.py                # Drift detection and remediation\n\u251c\u2500\u2500 test_logging.py              # Structured logging\n\u251c\u2500\u2500 test_toolbox.py              # Toolbox utilities\n\u251c\u2500\u2500 test_planning.py             # Planning module\n\u251c\u2500\u2500 test_telemetry.py            # Telemetry events\n\u2514\u2500\u2500 test_lint_nested_decorators.py  # Nested decorator linting\n</code></pre>"},{"location":"how-to/testing/#running-tests","title":"Running Tests","text":""},{"location":"how-to/testing/#all-tests","title":"All Tests","text":"<pre><code># Using pytest directly\npytest\n\n# With coverage report\npytest --cov=src/hephaestus --cov-report=term-missing\n\n# Generate XML coverage report (for CI)\npytest --cov=src/hephaestus --cov-report=xml\n</code></pre>"},{"location":"how-to/testing/#specific-test-files","title":"Specific Test Files","text":"<pre><code># Single file\npytest tests/test_cli.py\n\n# Multiple files\npytest tests/test_cli.py tests/test_cleanup.py\n\n# Verbose output\npytest tests/test_cli.py -v\n\n# Show print statements\npytest tests/test_cli.py -s\n</code></pre>"},{"location":"how-to/testing/#specific-tests","title":"Specific Tests","text":"<pre><code># Single test function\npytest tests/test_cli.py::test_cleanup_command\n\n# Test class\npytest tests/test_cli.py::TestCleanupCommand\n\n# Pattern matching\npytest -k \"cleanup\"  # Run all tests with \"cleanup\" in name\npytest -k \"not slow\"  # Exclude slow tests\n</code></pre>"},{"location":"how-to/testing/#test-with-random-order","title":"Test with Random Order","text":"<pre><code># Verify test independence\npytest --random-order\n\n# With specific seed for reproducibility\npytest --random-order-seed=12345\n</code></pre>"},{"location":"how-to/testing/#test-categories","title":"Test Categories","text":""},{"location":"how-to/testing/#unit-tests","title":"Unit Tests","text":"<p>Test individual functions and classes in isolation.</p> <p>Example:</p> <pre><code>def test_is_dangerous_path():\n    \"\"\"Test dangerous path detection.\"\"\"\n    assert is_dangerous_path(Path(\"/\"))\n    assert is_dangerous_path(Path(\"/home\"))\n    assert not is_dangerous_path(Path(\"/home/user/project\"))\n</code></pre>"},{"location":"how-to/testing/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between components.</p> <p>Example:</p> <pre><code>def test_guard_rails_command_flow(runner):\n    \"\"\"Test guard-rails runs full pipeline.\"\"\"\n    result = runner.invoke(app, [\"guard-rails\"])\n    assert result.exit_code == 0\n    assert \"cleanup\" in result.stdout.lower()\n    assert \"lint\" in result.stdout.lower()\n</code></pre>"},{"location":"how-to/testing/#cli-tests","title":"CLI Tests","text":"<p>Test command-line interface using Typer's test runner.</p> <p>Example:</p> <pre><code>from typer.testing import CliRunner\nfrom hephaestus.cli import app\n\ndef test_cleanup_dry_run():\n    \"\"\"Test cleanup in dry-run mode.\"\"\"\n    runner = CliRunner()\n    result = runner.invoke(app, [\"cleanup\", \"--dry-run\"])\n    assert result.exit_code == 0\n    assert \"would delete\" in result.stdout.lower()\n</code></pre>"},{"location":"how-to/testing/#regression-tests","title":"Regression Tests","text":"<p>Prevent known bugs from recurring.</p> <p>Example:</p> <pre><code>def test_guard_rails_available_immediately():\n    \"\"\"Regression test for guard-rails availability bug.\n\n    Ensures guard-rails command is registered at module scope,\n    not nested inside cleanup function.\n    \"\"\"\n    from hephaestus.cli import app\n    command_names = [cmd.name for cmd in app.registered_commands]\n    assert \"guard-rails\" in command_names\n</code></pre>"},{"location":"how-to/testing/#testing-patterns","title":"Testing Patterns","text":""},{"location":"how-to/testing/#fixtures","title":"Fixtures","text":"<p>Use pytest fixtures for common setup:</p> <pre><code>import pytest\nfrom pathlib import Path\nfrom typer.testing import CliRunner\n\n@pytest.fixture\ndef runner():\n    \"\"\"Provide a CLI test runner.\"\"\"\n    return CliRunner()\n\n@pytest.fixture\ndef temp_workspace(tmp_path):\n    \"\"\"Create a temporary workspace with test files.\"\"\"\n    workspace = tmp_path / \"workspace\"\n    workspace.mkdir()\n    (workspace / \"test.py\").write_text(\"print('hello')\")\n    return workspace\n\ndef test_cleanup_removes_pycache(runner, temp_workspace):\n    \"\"\"Test cleanup removes __pycache__ directories.\"\"\"\n    pycache = temp_workspace / \"__pycache__\"\n    pycache.mkdir()\n\n    result = runner.invoke(app, [\"cleanup\", str(temp_workspace)])\n    assert result.exit_code == 0\n    assert not pycache.exists()\n</code></pre>"},{"location":"how-to/testing/#mocking","title":"Mocking","text":"<p>Mock external dependencies:</p> <pre><code>from unittest.mock import Mock, patch\n\ndef test_release_download_retry(monkeypatch):\n    \"\"\"Test release download retries on failure.\"\"\"\n    mock_response = Mock()\n    mock_response.status_code = 500\n\n    with patch(\"requests.get\", return_value=mock_response):\n        with pytest.raises(ReleaseError):\n            download_asset(\"http://example.com/asset.tar.gz\")\n</code></pre>"},{"location":"how-to/testing/#parametrized-tests","title":"Parametrized Tests","text":"<p>Test multiple scenarios efficiently:</p> <pre><code>@pytest.mark.parametrize(\"path,expected\", [\n    (\"/\", True),\n    (\"/home\", True),\n    (\"/usr\", True),\n    (\"/tmp\", False),\n    (\"/home/user/project\", False),\n])\ndef test_dangerous_path_detection(path, expected):\n    \"\"\"Test various paths for danger detection.\"\"\"\n    assert is_dangerous_path(Path(path)) == expected\n</code></pre>"},{"location":"how-to/testing/#temporary-files","title":"Temporary Files","text":"<p>Use pytest's tmp_path fixture:</p> <pre><code>def test_cleanup_manifest_generation(tmp_path):\n    \"\"\"Test cleanup generates audit manifest.\"\"\"\n    manifest_path = tmp_path / \"manifest.json\"\n\n    options = CleanupOptions(\n        root=tmp_path,\n        manifest_path=manifest_path,\n    )\n\n    run_cleanup(options)\n\n    assert manifest_path.exists()\n    manifest = json.loads(manifest_path.read_text())\n    assert \"deleted_paths\" in manifest\n</code></pre>"},{"location":"how-to/testing/#coverage-guidelines","title":"Coverage Guidelines","text":""},{"location":"how-to/testing/#minimum-coverage","title":"Minimum Coverage","text":"<ul> <li>Overall: \u226585% (enforced in CI)</li> <li>New Code: \u226590% (aim high for new features)</li> <li>Critical Paths: 100% (security, safety, data loss prevention)</li> </ul>"},{"location":"how-to/testing/#check-coverage","title":"Check Coverage","text":"<pre><code># Terminal report\npytest --cov=src/hephaestus --cov-report=term-missing\n\n# HTML report (more detailed)\npytest --cov=src/hephaestus --cov-report=html\nopen htmlcov/index.html\n\n# Show uncovered lines\npytest --cov=src/hephaestus --cov-report=term-missing | grep \"MISS\"\n</code></pre>"},{"location":"how-to/testing/#coverage-exceptions","title":"Coverage Exceptions","text":"<p>Some code may be hard to test:</p> <ul> <li>Platform-specific code (use <code># pragma: no cover</code>)</li> <li>Error handlers for rare conditions</li> <li>Defensive programming checks</li> </ul> <pre><code>if sys.platform == \"win32\":  # pragma: no cover\n    # Windows-specific code\n    pass\n</code></pre>"},{"location":"how-to/testing/#best-practices","title":"Best Practices","text":""},{"location":"how-to/testing/#1-test-independence","title":"1. Test Independence","text":"<p>Tests should not depend on execution order:</p> <pre><code># BAD: Depends on previous test\ndef test_create_file():\n    Path(\"test.txt\").write_text(\"data\")\n\ndef test_read_file():  # Assumes test_create_file ran first\n    assert Path(\"test.txt\").read_text() == \"data\"\n\n# GOOD: Self-contained\ndef test_read_file(tmp_path):\n    test_file = tmp_path / \"test.txt\"\n    test_file.write_text(\"data\")\n    assert test_file.read_text() == \"data\"\n</code></pre>"},{"location":"how-to/testing/#2-clear-test-names","title":"2. Clear Test Names","text":"<p>Use descriptive names that explain what's being tested:</p> <pre><code># BAD\ndef test_cleanup():\n    ...\n\n# GOOD\ndef test_cleanup_refuses_dangerous_paths():\n    ...\n</code></pre>"},{"location":"how-to/testing/#3-arrange-act-assert-pattern","title":"3. Arrange-Act-Assert Pattern","text":"<p>Structure tests clearly:</p> <pre><code>def test_ranking_strategy_risk_weighted():\n    # Arrange\n    modules = [\n        AnalyticsModule(path=\"a.py\", churn=100, coverage=0.5, uncovered_lines=50),\n        AnalyticsModule(path=\"b.py\", churn=50, coverage=0.8, uncovered_lines=20),\n    ]\n\n    # Act\n    ranked = rank_by_risk_weighted(modules)\n\n    # Assert\n    assert ranked[0].path == \"a.py\"  # Higher risk should be first\n    assert ranked[0].score &gt; ranked[1].score\n</code></pre>"},{"location":"how-to/testing/#4-test-error-conditions","title":"4. Test Error Conditions","text":"<p>Don't just test happy paths:</p> <pre><code>def test_cleanup_invalid_root():\n    \"\"\"Test cleanup fails gracefully with invalid root.\"\"\"\n    with pytest.raises(ValueError, match=\"Invalid root path\"):\n        run_cleanup(CleanupOptions(root=Path(\"/nonexistent\")))\n</code></pre>"},{"location":"how-to/testing/#5-use-assertions-effectively","title":"5. Use Assertions Effectively","text":"<pre><code># Be specific\nassert result.exit_code == 0  # Not just assert result\nassert \"error\" not in output.lower()\n\n# Use pytest's rich assertions\nassert actual == expected  # Shows diff on failure\n\n# Check multiple conditions\nassert all([\n    result.exit_code == 0,\n    \"success\" in output,\n    not error_log.exists(),\n])\n</code></pre>"},{"location":"how-to/testing/#6-mock-sparingly","title":"6. Mock Sparingly","text":"<p>Prefer real implementations when possible:</p> <pre><code># PREFER: Use real filesystem with tmp_path\ndef test_cleanup_deletes_files(tmp_path):\n    test_file = tmp_path / \"test.py\"\n    test_file.write_text(\"data\")\n    run_cleanup(CleanupOptions(root=tmp_path))\n    assert not test_file.exists()\n\n# MOCK: Only for external services\ndef test_download_handles_network_error(monkeypatch):\n    with patch(\"requests.get\", side_effect=ConnectionError()):\n        with pytest.raises(ReleaseError):\n            download_asset(\"http://example.com/file\")\n</code></pre>"},{"location":"how-to/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"how-to/testing/#run-with-more-output","title":"Run with More Output","text":"<pre><code># Show print statements\npytest -s\n\n# Verbose output\npytest -v\n\n# Show all output including passed tests\npytest -vv\n\n# Show local variables on failure\npytest -l\n</code></pre>"},{"location":"how-to/testing/#debug-individual-tests","title":"Debug Individual Tests","text":"<pre><code># Drop into debugger on failure\npytest --pdb\n\n# Drop into debugger at start of test\npytest --trace\n</code></pre>"},{"location":"how-to/testing/#using-python-debugger","title":"Using Python Debugger","text":"<pre><code>def test_complex_logic():\n    result = compute_something()\n\n    import pdb; pdb.set_trace()  # Pause here\n\n    assert result == expected\n</code></pre>"},{"location":"how-to/testing/#ci-integration","title":"CI Integration","text":"<p>Tests run automatically in CI on:</p> <ul> <li>Pull requests</li> <li>Pushes to main</li> <li>Python 3.12 and 3.13 matrices</li> </ul>"},{"location":"how-to/testing/#ci-configuration","title":"CI Configuration","text":"<p>See <code>.github/workflows/ci.yml</code>:</p> <pre><code>- name: Run tests with coverage\n  run: |\n    pytest --cov=src/hephaestus --cov-report=xml --cov-report=term\n\n- name: Upload coverage to artifacts\n  uses: actions/upload-artifact@v4\n  with:\n    name: coverage-report\n    path: coverage.xml\n</code></pre>"},{"location":"how-to/testing/#coverage-enforcement","title":"Coverage Enforcement","text":"<p>Coverage threshold enforced in <code>pyproject.toml</code>:</p> <pre><code>[tool.coverage.report]\nfail_under = 85\nshow_missing = true\n</code></pre>"},{"location":"how-to/testing/#writing-new-tests","title":"Writing New Tests","text":""},{"location":"how-to/testing/#checklist-for-new-features","title":"Checklist for New Features","text":"<p>When adding a new feature:</p> <ul> <li> Unit tests for core logic</li> <li> Integration tests for component interaction</li> <li> CLI tests for user-facing commands</li> <li> Edge case tests (empty input, invalid values, etc.)</li> <li> Error condition tests</li> <li> Regression tests for known bugs</li> <li> Update test documentation if needed</li> </ul>"},{"location":"how-to/testing/#example-testing-a-new-command","title":"Example: Testing a New Command","text":"<pre><code># tests/test_cli.py\n\ndef test_new_command_help(runner):\n    \"\"\"Test new-command shows help text.\"\"\"\n    result = runner.invoke(app, [\"new-command\", \"--help\"])\n    assert result.exit_code == 0\n    assert \"Usage:\" in result.stdout\n\ndef test_new_command_basic_usage(runner, tmp_path):\n    \"\"\"Test new-command basic functionality.\"\"\"\n    result = runner.invoke(app, [\"new-command\", str(tmp_path)])\n    assert result.exit_code == 0\n    assert \"success\" in result.stdout.lower()\n\ndef test_new_command_invalid_input(runner):\n    \"\"\"Test new-command handles invalid input.\"\"\"\n    result = runner.invoke(app, [\"new-command\", \"/invalid/path\"])\n    assert result.exit_code != 0\n    assert \"error\" in result.stdout.lower()\n\n@pytest.mark.parametrize(\"option,expected\", [\n    (\"--verbose\", \"verbose output\"),\n    (\"--quiet\", \"minimal output\"),\n])\ndef test_new_command_options(runner, tmp_path, option, expected):\n    \"\"\"Test new-command option handling.\"\"\"\n    result = runner.invoke(app, [\"new-command\", str(tmp_path), option])\n    assert result.exit_code == 0\n    assert expected in result.stdout.lower()\n</code></pre>"},{"location":"how-to/testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/testing/#tests-fail-locally-but-pass-in-ci","title":"Tests Fail Locally but Pass in CI","text":"<ul> <li>Check Python version: <code>python --version</code></li> <li>Check for test order dependencies: <code>pytest --random-order</code></li> <li>Check for uncommitted changes affecting tests</li> <li>Verify dependencies are installed: <code>pip list</code></li> </ul>"},{"location":"how-to/testing/#flaky-tests","title":"Flaky Tests","text":"<p>Tests that pass sometimes and fail other times:</p> <ul> <li>Check for timing issues (use explicit waits, not sleeps)</li> <li>Check for order dependencies (use <code>pytest-randomly</code>)</li> <li>Check for shared state between tests</li> <li>Check for race conditions in concurrent code</li> </ul>"},{"location":"how-to/testing/#coverage-drop","title":"Coverage Drop","text":"<p>If coverage drops unexpectedly:</p> <pre><code># See which files have low coverage\npytest --cov=src/hephaestus --cov-report=term-missing\n\n# Generate detailed HTML report\npytest --cov=src/hephaestus --cov-report=html\nopen htmlcov/index.html\n</code></pre> <p>Add tests for uncovered lines shown in the report.</p>"},{"location":"how-to/testing/#resources","title":"Resources","text":"<ul> <li>pytest documentation</li> <li>pytest-cov documentation</li> <li>pytest-randomly documentation</li> <li>Typer testing</li> </ul>"},{"location":"how-to/testing/#related-documentation","title":"Related Documentation","text":"<ul> <li>Quality Gates Guide</li> <li>Contributing Guide</li> <li>CI Configuration</li> </ul> <p>Remember: Tests are documentation that runs. Write tests that explain what the code should do.</p>"},{"location":"how-to/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and fix common issues with Hephaestus.</p>"},{"location":"how-to/troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":"<p>Start with these commands to identify issues:</p> <pre><code># Check version\nhephaestus --version\n\n# Verify environment\nhephaestus guard-rails --drift\n\n# Run full quality checks\nhephaestus guard-rails\n\n# Check Python version\npython3 --version  # Should be 3.12+\n\n# List installed packages\npip list | grep -E \"(hephaestus|ruff|mypy|pytest)\"\n</code></pre>"},{"location":"how-to/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"how-to/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"how-to/troubleshooting/#hephaestus-command-not-found","title":"\"hephaestus: command not found\"","text":"<p>Symptom: Command not found when running <code>hephaestus</code></p> <p>Causes:</p> <ul> <li>Package not installed</li> <li>Installation directory not in PATH</li> <li>Virtual environment not activated</li> </ul> <p>Solutions:</p> <pre><code># Check if installed\npip show hephaestus\n\n# If not installed, install it\npip install hephaestus\n# or: pip install -e \".[dev,qa]\"  # from source\n\n# If installed but not in PATH, try:\npython -m hephaestus --help\n\n# Activate virtual environment if using one\nsource .venv/bin/activate  # Linux/macOS\n# or: .venv\\Scripts\\activate  # Windows\n</code></pre>"},{"location":"how-to/troubleshooting/#module-not-found-errors","title":"\"Module not found\" errors","text":"<p>Symptom: <code>ModuleNotFoundError: No module named 'X'</code></p> <p>Cause: Missing dependencies</p> <p>Solution:</p> <pre><code># Reinstall with all extras\npip install -e \".[dev,qa]\"\n\n# Or sync with uv\nuv sync --extra dev --extra qa\n\n# Verify installation\npip list\n</code></pre>"},{"location":"how-to/troubleshooting/#uv-command-not-found","title":"\"uv: command not found\"","text":"<p>Symptom: <code>bash: uv: command not found</code></p> <p>Cause: uv package manager not installed</p> <p>Solutions:</p> <pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Or use pip\npip install uv\n\n# Or use the repo without uv\npip install -e \".[dev,qa]\"\npython -m hephaestus --help\n</code></pre>"},{"location":"how-to/troubleshooting/#macos-appledoubleresource-fork-installation-errors","title":"macOS AppleDouble/Resource Fork Installation Errors","text":"<p>Symptom: Installation fails with errors like:</p> <pre><code>error: Failed to install: ruff-0.14.0-py3-none-macosx_11_0_arm64.whl (ruff==0.14.0)\nCaused by: RECORD file doesn't match wheel contents: Could not find entry for ruff-0.14.0.data/scripts/._ruff\n</code></pre> <p>or:</p> <pre><code>warning: Failed to clone files; falling back to full copy\nerror: Failed to install: bandit-1.8.6-py3-none-any.whl (bandit==1.8.6)\nCaused by: failed to copy file from ... to ...: No such file or directory\n</code></pre> <p>Cause: macOS creates AppleDouble files (prefixed with <code>._</code>) in the UV cache and virtual environment, which are not listed in wheel RECORD files. This happens when:</p> <ul> <li>Files are copied across filesystems (e.g., network drives, external drives)</li> <li>The repository is on a non-xattr filesystem (exFAT, NTFS, FAT32)</li> <li>The cache contains corrupted or stale metadata</li> <li>Reflink operations fail on non-APFS filesystems</li> </ul> <p>Solution:</p> <p>The <code>scripts/setup-dev-env.sh</code> script now automatically handles this on macOS, including:</p> <ul> <li>Detecting non-xattr filesystems (exFAT, NTFS, FAT32, etc.)</li> <li>Automatically relocating the virtual environment to an APFS-backed location (<code>$HOME/.uvenvs/&lt;repo&gt;</code>)</li> <li>Stripping extended attributes from UV cache and environment before sync</li> <li>Creating a symlink from <code>.venv</code> to the relocated environment</li> </ul> <p>If you still encounter issues:</p> <pre><code># 1. Set environment variables to prevent the issue\nexport UV_LINK_MODE=copy\nexport COPYFILE_DISABLE=1\n\n# 2. Strip extended attributes from UV cache\nxattr -rc ~/.cache/uv\n\n# 3. Clear UV cache completely\nrm -rf ~/.cache/uv\n\n# 4. Remove virtual environment (if it's a symlink, remove the target too)\nif [[ -L .venv ]]; then\n    rm -rf \"$(readlink .venv)\"\n    rm .venv\nelse\n    rm -rf .venv\nfi\n\n# 5. Run the cleanup script to remove all macOS metadata\n./cleanup-macos-cruft.sh\n\n# 6. Re-run setup\n./scripts/setup-dev-env.sh\n\n# Alternatively, if the issue persists, try:\nuv sync --extra dev --extra qa --reinstall\n</code></pre> <p>Working on External/USB Drives (exFAT, NTFS, FAT32):</p> <p>If your repository is on an external drive or USB stick formatted as exFAT, NTFS, or FAT32, the setup script will automatically:</p> <ol> <li>Detect the non-xattr filesystem</li> <li>Set <code>UV_PROJECT_ENVIRONMENT=$HOME/.uvenvs/&lt;repo-name&gt;</code></li> <li>Create the virtual environment on your internal APFS disk</li> <li>Create a symlink: <code>.venv -&gt; $HOME/.uvenvs/&lt;repo-name&gt;</code></li> <li>Strip extended attributes before syncing dependencies</li> </ol> <p>You can manually configure this behavior:</p> <pre><code># For any repository on exFAT/NTFS/FAT32\nexport UV_PROJECT_ENVIRONMENT=\"$HOME/.uvenvs/$(basename $(pwd))\"\n./scripts/setup-dev-env.sh\n\n# The .venv symlink will be created automatically\n</code></pre> <p>Prevention:</p> <p>Always run development commands with the environment variables set:</p> <pre><code>export UV_LINK_MODE=copy\nexport COPYFILE_DISABLE=1\n</code></pre> <p>Or add these to your <code>~/.bashrc</code> or <code>~/.zshrc</code>:</p> <pre><code># Prevent macOS resource fork issues\nexport UV_LINK_MODE=copy\nexport COPYFILE_DISABLE=1\n</code></pre> <p>For repositories on external drives, set:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\nexport UV_PROJECT_ENVIRONMENT=\"$HOME/.uvenvs/$(basename $(pwd))\"\n</code></pre>"},{"location":"how-to/troubleshooting/#guard-rails-issues","title":"Guard-Rails Issues","text":""},{"location":"how-to/troubleshooting/#guard-rails-fails-immediately","title":"Guard-rails fails immediately","text":"<p>Symptom: <code>hephaestus guard-rails</code> fails without running checks</p> <p>Diagnostic:</p> <pre><code># Run with verbose output\nhephaestus guard-rails -v\n\n# Check individual components\npytest\nruff check .\nmypy src tests\n</code></pre> <p>Common causes:</p> <ul> <li>Syntax errors in code</li> <li>Missing dependencies</li> <li>Corrupted cache files</li> </ul> <p>Solutions:</p> <pre><code># Clean caches\nhephaestus cleanup --deep-clean\n\n# Reinstall dependencies\npip install --force-reinstall -e \".[dev,qa]\"\n\n# Fix syntax errors shown in output\n</code></pre>"},{"location":"how-to/troubleshooting/#pip-audit-failed-in-guard-rails","title":"\"pip-audit failed\" in guard-rails","text":"<p>Symptom: <code>pip-audit --strict</code> fails</p> <p>Causes:</p> <ul> <li>SSL certificate issues (common in containers)</li> <li>Known vulnerabilities in dependencies</li> <li>Network connectivity issues</li> </ul> <p>Solutions:</p> <p>This is often non-blocking and expected in containerized environments:</p> <pre><code># Run pip-audit separately to see details\npip-audit --strict --ignore-vuln GHSA-4xh5-x5gv-qwph\n\n# If SSL issues, this is expected in containers\n# Guard-rails will continue with other checks\n\n# For actual vulnerabilities, update dependencies\npip install --upgrade &lt;package&gt;\n</code></pre>"},{"location":"how-to/troubleshooting/#tests-fail-during-guard-rails","title":"Tests fail during guard-rails","text":"<p>Symptom: pytest fails with errors</p> <p>Diagnostic:</p> <pre><code># Run tests with verbose output\npytest -v\n\n# Run specific failing test\npytest tests/test_file.py::test_name -v\n\n# Check test dependencies\npytest --version\npython --version\n</code></pre> <p>Solutions:</p> <pre><code># Check for tool drift\nhephaestus guard-rails --drift\n\n# Sync dependencies\nuv sync --extra dev --extra qa\n\n# Clean and retry\nhephaestus cleanup --deep-clean\npytest\n</code></pre>"},{"location":"how-to/troubleshooting/#type-checking-fails","title":"Type checking fails","text":"<p>Symptom: <code>mypy src tests</code> shows errors</p> <p>Diagnostic:</p> <pre><code># Run mypy with verbose output\nmypy src tests --show-error-codes\n\n# Check specific file\nmypy src/hephaestus/file.py\n</code></pre> <p>Solutions:</p> <pre><code># Install type stubs\npip install types-PyYAML types-requests\n\n# Check mypy configuration\ncat pyproject.toml | grep -A 10 \"\\[tool.mypy\\]\"\n\n# Fix reported type errors in code\n</code></pre>"},{"location":"how-to/troubleshooting/#cleanup-issues","title":"Cleanup Issues","text":""},{"location":"how-to/troubleshooting/#refusing-to-clean-dangerous-path","title":"\"Refusing to clean dangerous path\"","text":"<p>Symptom: Cleanup refuses to proceed</p> <p>Cause: Safety feature protecting system paths</p> <p>This is expected behavior! Cleanup protects these paths:</p> <ul> <li><code>/</code>, <code>/home</code>, <code>/usr</code>, <code>/etc</code>, <code>/var</code></li> <li><code>/bin</code>, <code>/sbin</code>, <code>/lib</code>, <code>/opt</code></li> <li><code>/boot</code>, <code>/root</code>, <code>/sys</code>, <code>/proc</code>, <code>/dev</code></li> </ul> <p>Solutions:</p> <pre><code># Use a safe project directory\ncd /path/to/your/project\nhephaestus cleanup\n\n# Or specify safe root explicitly\nhephaestus cleanup --root /home/user/myproject\n</code></pre>"},{"location":"how-to/troubleshooting/#cleanup-asks-for-confirmation-repeatedly","title":"Cleanup asks for confirmation repeatedly","text":"<p>Symptom: Cleanup prompts \"Type CONFIRM to proceed\"</p> <p>Cause: Trying to clean paths outside detected root</p> <p>Solutions:</p> <pre><code># Clean from git repository root (auto-detected)\ncd /path/to/repo\nhephaestus cleanup\n\n# Auto-confirm (skip prompts)\nhephaestus cleanup --yes\n\n# See preview first\nhephaestus cleanup --dry-run\n</code></pre>"},{"location":"how-to/troubleshooting/#files-not-being-deleted","title":"Files not being deleted","text":"<p>Symptom: Cleanup runs but files remain</p> <p>Diagnostic:</p> <pre><code># Use dry-run to see what would be deleted\nhephaestus cleanup --dry-run\n\n# Check if files are in excluded paths\nhephaestus cleanup --deep-clean\n</code></pre> <p>Possible causes:</p> <ul> <li>Files are in <code>.git/</code> (excluded by default)</li> <li>Files are in <code>.venv/site-packages</code> (protected)</li> <li>Permission errors</li> </ul> <p>Solutions:</p> <pre><code># Include git directory (dangerous!)\nhephaestus cleanup --include-git\n\n# Check file permissions\nls -la /path/to/file\n\n# Run with verbose output to see skip reasons\n# (Future enhancement)\n</code></pre>"},{"location":"how-to/troubleshooting/#drift-detection-issues","title":"Drift Detection Issues","text":""},{"location":"how-to/troubleshooting/#tool-version-drift-detected","title":"\"Tool version drift detected\"","text":"<p>Symptom: <code>hephaestus guard-rails --drift</code> shows mismatches</p> <p>This is informational, not an error!</p> <p>Solution:</p> <pre><code># Follow the remediation commands shown\nuv sync --extra dev --extra qa\n\n# Or update individual tools\npip install --upgrade ruff==X.Y.Z\n\n# Verify fix\nhephaestus guard-rails --drift\n</code></pre>"},{"location":"how-to/troubleshooting/#tool-not-installed","title":"\"Tool not installed\"","text":"<p>Symptom: Drift detection shows missing tools</p> <p>Solution:</p> <pre><code># Install all dev tools\npip install -e \".[dev,qa]\"\n\n# Verify installation\nwhich ruff mypy pytest\n</code></pre>"},{"location":"how-to/troubleshooting/#release-issues","title":"Release Issues","text":""},{"location":"how-to/troubleshooting/#failed-to-download-release","title":"\"Failed to download release\"","text":"<p>Symptom: <code>hephaestus release install</code> fails</p> <p>Diagnostic:</p> <pre><code># Check network connectivity\ncurl -I https://api.github.com\n\n# Check if release exists\ngh release view v0.2.0 --repo IAmJonoBo/Hephaestus\n\n# Try with verbose output\nhephaestus release install --repository IAmJonoBo/Hephaestus --tag v0.2.0 -v\n</code></pre> <p>Solutions:</p> <pre><code># Check GitHub API rate limits\ncurl https://api.github.com/rate_limit\n\n# If rate limited, wait or authenticate\nexport GITHUB_TOKEN=your_token\n\n# Try different tag/version\nhephaestus release install --repository IAmJonoBo/Hephaestus --tag v0.1.0\n</code></pre>"},{"location":"how-to/troubleshooting/#checksum-verification-failed","title":"\"Checksum verification failed\"","text":"<p>Symptom: Release install fails checksum validation</p> <p>Cause: Corrupted download or tampered file</p> <p>Solutions:</p> <pre><code># Try downloading again\nhephaestus release install --repository IAmJonoBo/Hephaestus --tag v0.2.0\n\n# Check release assets are intact\ngh release view v0.2.0 --repo IAmJonoBo/Hephaestus --json assets\n\n# Skip checksum (not recommended, only for testing)\nhephaestus release install --no-verify-checksum\n</code></pre>"},{"location":"how-to/troubleshooting/#analytics-issues","title":"Analytics Issues","text":""},{"location":"how-to/troubleshooting/#no-analytics-data-found","title":"\"No analytics data found\"","text":"<p>Symptom: <code>hephaestus tools refactor rankings</code> shows error</p> <p>Cause: Analytics sources not configured</p> <p>Solution:</p> <p>Configure in <code>pyproject.toml</code>:</p> <pre><code>[tool.hephaestus.analytics]\nchurn_file = \"analytics/churn.json\"\ncoverage_file = \"coverage.xml\"\nembeddings_file = \"analytics/embeddings.json\"\n</code></pre> <p>Or use external config:</p> <pre><code>hephaestus tools refactor rankings --config /path/to/config.yaml\n</code></pre>"},{"location":"how-to/troubleshooting/#invalid-analytics-format","title":"\"Invalid analytics format\"","text":"<p>Symptom: Rankings fail with parsing errors</p> <p>Cause: Analytics files in wrong format</p> <p>Solution:</p> <p>Ensure analytics files match expected format:</p> <pre><code>// churn.json\n{\n  \"modules\": [\n    {\"path\": \"src/module.py\", \"churn\": 100}\n  ]\n}\n\n// embeddings.json\n{\n  \"embeddings\": [\n    {\"path\": \"src/module.py\", \"embedding\": [0.1, 0.2, ...]}\n  ]\n}\n</code></pre> <p>Coverage file should be standard <code>coverage.xml</code> format from pytest-cov.</p>"},{"location":"how-to/troubleshooting/#schema-export-issues","title":"Schema Export Issues","text":""},{"location":"how-to/troubleshooting/#schema-export-fails","title":"\"Schema export fails\"","text":"<p>Symptom: <code>hephaestus schema</code> shows errors</p> <p>Diagnostic:</p> <pre><code># Run with verbose output\nhephaestus schema -v\n\n# Check if all commands are registered\nhephaestus --help\n</code></pre> <p>Solution:</p> <pre><code># Reinstall package\npip install --force-reinstall -e .\n\n# Verify schema structure\nhephaestus schema | python -m json.tool\n</code></pre>"},{"location":"how-to/troubleshooting/#environment-issues","title":"Environment Issues","text":""},{"location":"how-to/troubleshooting/#works-on-my-machine","title":"\"Works on my machine\"","text":"<p>Symptom: Tests pass locally but fail in CI, or vice versa</p> <p>Diagnostic:</p> <pre><code># Compare environments\npython --version\npip list\n\n# Check for tool drift\nhephaestus guard-rails --drift\n\n# Run tests with randomization\npytest --random-order\n</code></pre> <p>Solutions:</p> <pre><code># Sync to exact versions\nuv sync --extra dev --extra qa\n\n# Clean all caches\nhephaestus cleanup --deep-clean\nrm -rf .pytest_cache .mypy_cache .ruff_cache\n\n# Verify Python version matches CI\n# CI uses Python 3.12 and 3.13\n</code></pre>"},{"location":"how-to/troubleshooting/#virtual-environment-conflicts","title":"Virtual environment conflicts","text":"<p>Symptom: Strange import errors or version conflicts</p> <p>Solution:</p> <pre><code># Delete and recreate venv\ndeactivate  # if activated\nrm -rf .venv\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e \".[dev,qa]\"\n</code></pre>"},{"location":"how-to/troubleshooting/#cache-corruption","title":"Cache corruption","text":"<p>Symptom: Inexplicable errors that persist</p> <p>Solution:</p> <pre><code># Clean all caches\nhephaestus cleanup --deep-clean\n\n# Clean Python bytecode\nfind . -type d -name __pycache__ -exec rm -rf {} +\nfind . -type f -name \"*.pyc\" -delete\n\n# Clean tool caches\nrm -rf .pytest_cache .mypy_cache .ruff_cache\n\n# Rebuild\npip install --force-reinstall -e \".[dev,qa]\"\n</code></pre>"},{"location":"how-to/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"how-to/troubleshooting/#guard-rails-is-slow","title":"Guard-rails is slow","text":"<p>Expected behavior: Guard-rails runs many checks and may take 1-5 minutes.</p> <p>To speed up:</p> <pre><code># Skip formatting (saves time)\nhephaestus guard-rails --no-format\n\n# Run individual checks\npytest  # Just tests\nruff check .  # Just linting\n</code></pre>"},{"location":"how-to/troubleshooting/#tests-are-slow","title":"Tests are slow","text":"<p>Solution:</p> <pre><code># Run in parallel (if you have pytest-xdist)\npytest -n auto\n\n# Run only fast tests\npytest -m \"not slow\"\n\n# Skip integration tests\npytest -m \"not integration\"\n</code></pre>"},{"location":"how-to/troubleshooting/#cicd-issues","title":"CI/CD Issues","text":""},{"location":"how-to/troubleshooting/#ci-fails-but-local-passes","title":"CI fails but local passes","text":"<p>Diagnostic:</p> <ol> <li>Check CI logs for specific error</li> <li>Compare Python versions</li> <li>Check for network-dependent tests</li> <li>Check for timing-dependent tests</li> </ol> <p>Solutions:</p> <pre><code># Replicate CI environment locally\npython3.12 -m venv .venv-ci\nsource .venv-ci/bin/activate\npip install -e \".[dev,qa]\"\npytest\n\n# Check for test order dependencies\npytest --random-order --random-order-seed=12345\n\n# Check for timing issues\npytest -v  # Look for flaky tests\n</code></pre>"},{"location":"how-to/troubleshooting/#coverage-drops-in-ci","title":"Coverage drops in CI","text":"<p>Cause: Tests not running or new uncovered code</p> <p>Solution:</p> <pre><code># Check which tests ran\npytest --collect-only\n\n# Generate coverage report locally\npytest --cov=src/hephaestus --cov-report=html\nopen htmlcov/index.html\n\n# Add tests for uncovered code\n</code></pre>"},{"location":"how-to/troubleshooting/#getting-more-help","title":"Getting More Help","text":""},{"location":"how-to/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code># Set log level\nexport HEPHAESTUS_LOG_LEVEL=DEBUG\n\n# Use JSON logging for parsing\nexport HEPHAESTUS_LOG_FORMAT=json\n\n# Run command\nhephaestus guard-rails\n</code></pre>"},{"location":"how-to/troubleshooting/#collect-diagnostic-information","title":"Collect Diagnostic Information","text":"<p>When reporting issues, include:</p> <pre><code># Version information\nhephaestus --version\npython --version\npip --version\n\n# Environment information\npip list\nhephaestus guard-rails --drift\n\n# Error output\nhephaestus guard-rails 2&gt;&amp;1 | tee error.log\n</code></pre>"},{"location":"how-to/troubleshooting/#check-known-issues","title":"Check Known Issues","text":"<ul> <li>Review GitHub Issues</li> <li>Check CHANGELOG.md for recent changes</li> <li>Review Next_Steps.md for known limitations</li> </ul>"},{"location":"how-to/troubleshooting/#report-a-bug","title":"Report a Bug","text":"<p>If you've found a bug:</p> <ol> <li>Check if it's already reported</li> <li>Collect diagnostic information</li> <li>Create a minimal reproducible example</li> <li>Open a GitHub issue with:</li> <li>Description of the problem</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Environment details</li> <li>Error messages/logs</li> </ol>"},{"location":"how-to/troubleshooting/#security-issues","title":"Security Issues","text":"<p>For security vulnerabilities, do not open a public issue. Instead:</p> <ul> <li>Follow SECURITY.md disclosure process</li> <li>Email: opensource@hephaestus.dev</li> <li>Include details and impact assessment</li> </ul>"},{"location":"how-to/troubleshooting/#quick-reference","title":"Quick Reference","text":""},{"location":"how-to/troubleshooting/#diagnostic-commands","title":"Diagnostic Commands","text":"<pre><code># Check everything\nhephaestus guard-rails\nhephaestus guard-rails --drift\n\n# Individual checks\npytest                                          # Tests\nruff check .                                    # Linting\nruff format --check .                           # Formatting\nmypy src tests                                  # Type checking\npython3 scripts/lint_nested_decorators.py       # Architecture\npip-audit --strict                              # Security\n</code></pre>"},{"location":"how-to/troubleshooting/#reset-commands","title":"Reset Commands","text":"<pre><code># Clean workspace\nhephaestus cleanup --deep-clean\n\n# Reset virtual environment\ndeactivate\nrm -rf .venv\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e \".[dev,qa]\"\n\n# Clear all caches\nrm -rf .pytest_cache .mypy_cache .ruff_cache __pycache__\n</code></pre>"},{"location":"how-to/troubleshooting/#common-fixes","title":"Common Fixes","text":"<pre><code># Fix imports\npip install -e \".[dev,qa]\"\n\n# Fix drift\nuv sync --extra dev --extra qa\n\n# Fix permissions\nchmod +x scripts/*.sh\n\n# Fix line endings (if Windows)\ndos2unix scripts/*.sh\n</code></pre>"},{"location":"how-to/troubleshooting/#related-documentation","title":"Related Documentation","text":"<ul> <li>Quality Gates Guide</li> <li>Operating Safely Guide</li> <li>Testing Guide</li> <li>Release Process Guide</li> <li>Contributing Guide</li> </ul> <p>Still stuck? Open a GitHub Discussion or issue!</p>"},{"location":"reference/api/","title":"REST API Reference (ADR-0004)","text":"<p>Status: Phase 1 (Foundation) - OpenAPI specification only</p>"},{"location":"reference/api/#overview","title":"Overview","text":"<p>Hephaestus provides a REST API for remote invocation of quality gates, cleanup operations, and analytics. This enables integration with CI/CD systems, dashboards, and AI agents.</p>"},{"location":"reference/api/#base-url","title":"Base URL","text":"<pre><code>http://localhost:8000/api/v1\n</code></pre>"},{"location":"reference/api/#authentication","title":"Authentication","text":"<p>All endpoints require API key authentication:</p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  http://localhost:8000/api/v1/quality/guard-rails\n</code></pre>"},{"location":"reference/api/#endpoints","title":"Endpoints","text":""},{"location":"reference/api/#quality-gates","title":"Quality Gates","text":""},{"location":"reference/api/#post-qualityguard-rails","title":"POST /quality/guard-rails","text":"<p>Run comprehensive quality pipeline.</p> <p>Request Body:</p> <pre><code>{\n  \"no_format\": false,\n  \"workspace\": \"/path/to/project\",\n  \"drift_check\": true\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"gates\": [\n    {\n      \"name\": \"lint\",\n      \"passed\": true,\n      \"message\": \"Linting passed\",\n      \"duration\": 5.2,\n      \"metadata\": {}\n    }\n  ],\n  \"duration\": 45.3,\n  \"task_id\": \"task-abc123\"\n}\n</code></pre>"},{"location":"reference/api/#cleanup","title":"Cleanup","text":""},{"location":"reference/api/#post-cleanup","title":"POST /cleanup","text":"<p>Clean workspace artifacts.</p> <p>Request Body:</p> <pre><code>{\n  \"root\": \"/path/to/project\",\n  \"deep_clean\": false,\n  \"dry_run\": false\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"files_deleted\": 142,\n  \"size_freed\": 15728640,\n  \"manifest\": {}\n}\n</code></pre>"},{"location":"reference/api/#analytics","title":"Analytics","text":""},{"location":"reference/api/#get-analyticsrankings","title":"GET /analytics/rankings","text":"<p>Get refactoring rankings.</p> <p>Query Parameters:</p> <ul> <li><code>strategy</code>: Ranking strategy (risk_weighted, coverage_first, churn_based, composite)</li> <li><code>limit</code>: Max results (1-100, default: 20)</li> </ul> <p>Response:</p> <pre><code>{\n  \"rankings\": [\n    {\n      \"path\": \"src/module.py\",\n      \"score\": 0.85,\n      \"metrics\": {\n        \"churn\": 15,\n        \"coverage\": 0.45,\n        \"complexity\": 25\n      }\n    }\n  ],\n  \"strategy\": \"composite\"\n}\n</code></pre>"},{"location":"reference/api/#tasks","title":"Tasks","text":""},{"location":"reference/api/#get-taskstask_id","title":"GET /tasks/{task_id}","text":"<p>Get async task status.</p> <p>Response:</p> <pre><code>{\n  \"task_id\": \"task-abc123\",\n  \"status\": \"running\",\n  \"progress\": 0.65,\n  \"result\": null,\n  \"error\": null\n}\n</code></pre>"},{"location":"reference/api/#openapi-specification","title":"OpenAPI Specification","text":"<p>Full OpenAPI 3.0 specification available at:</p> <p>docs/api/openapi.yaml</p>"},{"location":"reference/api/#phase-1-implementation-status","title":"Phase 1 Implementation Status","text":"<p>The current Phase 1 release includes:</p> <ul> <li>\u2705 OpenAPI specification (available)</li> <li>\u2705 API module structure (available)</li> <li>\ud83d\udea7 FastAPI implementation (in progress, not yet available)</li> <li>\ud83d\udea7 Authentication (planned for future phase)</li> <li>\ud83d\udea7 Async task management (planned for future phase)</li> <li>\ud83d\udea7 gRPC support (planned for future phase)</li> </ul>"},{"location":"reference/api/#future-phases","title":"Future Phases","text":"<ul> <li>Phase 1 (v0.4.0): REST API core endpoints, authentication</li> <li>Phase 2 (v0.5.0): Async task management, progress streaming</li> <li>Phase 3 (v0.6.0): gRPC service, streaming RPCs</li> <li>Phase 4 (v0.7.0): Production-ready with rate limiting, versioning</li> </ul>"},{"location":"reference/api/#client-examples","title":"Client Examples","text":""},{"location":"reference/api/#python","title":"Python","text":"<pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/quality/guard-rails\",\n    headers={\"Authorization\": \"Bearer YOUR_API_KEY\"},\n    json={\"no_format\": False, \"drift_check\": True}\n)\n\nresult = response.json()\nprint(f\"Success: {result['success']}\")\n</code></pre>"},{"location":"reference/api/#curl","title":"cURL","text":"<pre><code>curl -X POST http://localhost:8000/api/v1/quality/guard-rails \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"no_format\": false, \"drift_check\": true}'\n</code></pre>"},{"location":"reference/api/#related-documentation","title":"Related Documentation","text":"<ul> <li>ADR-0004: REST/gRPC API</li> <li>AI Agent Integration</li> <li>Architecture Overview</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>This reference documents the top-level <code>hephaestus</code> commands and their most important options. Run <code>uv run hephaestus --help</code> for the canonical source of truth and subcommand details.</p>"},{"location":"reference/cli/#global-usage","title":"Global Usage","text":"<pre><code>uv run hephaestus [OPTIONS] COMMAND [ARGS]...\n</code></pre> <ul> <li><code>--log-format [text|json]</code>: Emit human-readable or JSON logs for automation pipelines.</li> <li><code>--log-level [CRITICAL|ERROR|WARNING|INFO|DEBUG]</code>: Control verbosity for toolkit logs.</li> <li><code>--run-id TEXT</code>: Attach a correlation identifier to every structured log event.</li> <li><code>--install-completion</code>, <code>--show-completion</code>: Manage shell completions.</li> <li><code>--help</code>: Display help text for any command.</li> </ul>"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#version","title":"<code>version</code>","text":"<p>Print the installed toolkit version.</p>"},{"location":"reference/cli/#schema","title":"<code>schema</code>","text":"<p>Export command schemas for AI agent integration.</p> Option Description <code>--output PATH</code> Write schemas to JSON file instead of stdout. <code>--format [json]</code> Output format for schemas (default: <code>json</code>). <p>Generates machine-readable schemas describing all CLI commands, their parameters, examples, and expected outputs. See AI Agent Integration Guide for usage patterns.</p>"},{"location":"reference/cli/#cleanup","title":"<code>cleanup</code>","text":"<p>Scrub development cruft (macOS metadata, caches, build artefacts). Key options:</p> Option Description <code>--root PATH</code> Override the detected project root. <code>--deep-clean</code> Enable all cleanup behaviours (equivalent to toggling every flag). <code>--include-git</code> Remove files inside <code>.git</code> directories. <code>--python-cache</code> Delete <code>__pycache__</code> directories and compiled bytecode. <code>--extra-path PATH</code> Include additional directories to clean."},{"location":"reference/cli/#plan","title":"<code>plan</code>","text":"<p>Render the refactoring execution plan as a Rich table to share rollout status.</p>"},{"location":"reference/cli/#guard-rails","title":"<code>guard-rails</code>","text":"<p>Run the full guard-rail pipeline: cleanup, lint, format, typecheck, test, and audit.</p> Option Description <code>--no-format</code> Skip the formatting step (useful during code review). <code>--drift</code> Check for tool version drift and show remediation commands. <p>Standard pipeline:</p> <ol> <li>Deep clean workspace</li> <li>Lint with ruff</li> <li>Format with ruff (unless <code>--no-format</code>)</li> <li>Lint YAML files with yamllint</li> <li>Type check with mypy</li> <li>Run tests with pytest</li> <li>Security audit with pip-audit</li> </ol> <p>Drift detection mode (<code>--drift</code>):</p> <ul> <li>Compares installed tool versions against <code>pyproject.toml</code></li> <li>Reports missing or outdated tools</li> <li>Generates remediation commands (manual or via <code>uv sync</code>)</li> <li>Exits with code 1 if drift is detected</li> </ul>"},{"location":"reference/cli/#tools-refactor-hotspots","title":"<code>tools refactor hotspots</code>","text":"<p>List the highest churn modules. Options include:</p> <ul> <li><code>--limit INTEGER</code>: Number of hotspots to display.</li> <li><code>--config PATH</code>: Load alternate configuration.</li> </ul>"},{"location":"reference/cli/#tools-refactor-opportunities","title":"<code>tools refactor opportunities</code>","text":"<p>Summarise advisory refactor opportunities with estimated effort.</p>"},{"location":"reference/cli/#tools-refactor-rankings","title":"<code>tools refactor rankings</code>","text":"<p>Rank modules by refactoring priority using analytics data. Requires analytics sources to be configured.</p> Option Values Description <code>--strategy</code> <code>risk_weighted</code>, <code>coverage_first</code>, <code>churn_based</code>, <code>composite</code> Ranking algorithm to apply (default: <code>risk_weighted</code>). <code>--limit</code> INTEGER Maximum number of ranked modules to display (default: 20). <code>--config</code> PATH Load alternate configuration. <p>Strategies:</p> <ul> <li><code>risk_weighted</code>: Balances coverage gaps, uncovered lines, and churn (recommended).</li> <li><code>coverage_first</code>: Prioritizes modules with the largest coverage gaps.</li> <li><code>churn_based</code>: Focuses on high-change-frequency modules.</li> <li><code>composite</code>: Balanced approach with bonus for modules with embeddings.</li> </ul>"},{"location":"reference/cli/#tools-qa-profile-name","title":"<code>tools qa profile NAME</code>","text":"<p>Display thresholds and switches for a specific QA profile (e.g., <code>quick</code>, <code>full</code>).</p>"},{"location":"reference/cli/#tools-qa-coverage","title":"<code>tools qa coverage</code>","text":"<p>Highlight uncovered lines and risk scores. Accepts <code>--config PATH</code> to override defaults.</p>"},{"location":"reference/cli/#release-install","title":"<code>release install</code>","text":"<p>Download and install a wheelhouse archive. Important options:</p> Option Description <code>--repository OWNER/REPO</code> Source repository for releases (default: <code>IAmJonoBo/Hephaestus</code>). <code>--tag TAG</code> Release tag to download (defaults to latest). <code>--asset-pattern GLOB</code> Glob pattern used to locate the wheelhouse asset. <code>--destination PATH</code> Directory for downloaded archives (defaults to the platform cache). <code>--manifest-pattern GLOB</code> Glob used to locate the checksum manifest (defaults to <code>*wheelhouse*.sha256</code>). <code>--token TEXT</code> GitHub token for private releases (falls back to <code>GITHUB_TOKEN</code>). <code>--timeout FLOAT</code> Network timeout in seconds for API and download calls. <code>--max-retries INTEGER</code> Maximum retry attempts for API and download calls. <code>--python PATH</code> Python executable used to invoke <code>pip install</code>. <code>--pip-arg ARG</code> Additional arguments forwarded to pip (repeatable). <code>--no-upgrade</code> Do not pass <code>--upgrade</code> to pip. <code>--overwrite</code> Replace existing files when downloading or extracting. <code>--cleanup</code> Remove the extracted wheelhouse after installation completes. <code>--remove-archive</code> Delete the downloaded archive after successful install. <code>--allow-unsigned</code> Skip checksum verification (not recommended)."},{"location":"reference/cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>HEPHAESTUS_RELEASE_REPOSITORY</code> Default repository override for release downloads. <code>HEPHAESTUS_RELEASE_ASSET_PATTERN</code> Default asset glob for wheelhouse selection. <code>HEPHAESTUS_RELEASE_MANIFEST_PATTERN</code> Default checksum manifest glob for verification. <code>HEPHAESTUS_RELEASE_CACHE</code> Override the destination directory for downloaded wheelhouses. <code>GITHUB_TOKEN</code> Bearer token used for authenticated release downloads."},{"location":"reference/cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Command succeeded.</li> <li>Non-zero: An error occurred. For example, <code>cleanup</code> raises exit code 1 when cleanup errors are   encountered, and <code>release install</code> re-raises failures from the download or pip install steps.</li> </ul>"},{"location":"reference/refactoring-toolkit/","title":"Refactoring Toolkit Map","text":"<p>Hephaestus ships advisory tooling under the <code>hephaestus-toolkit/refactoring/</code> directory. Use this reference to understand the major components when wiring the toolkit into another repository or CI pipeline.</p>"},{"location":"reference/refactoring-toolkit/#directory-walkthrough","title":"Directory Walkthrough","text":"Path Purpose <code>config/refactor.config.yaml</code> Baseline configuration toggling hotspot scanning, codemods, characterization, etc. <code>docs/PLAN.md</code> Step-by-step rollout plan for introducing the toolkit safely. <code>docs/PLAYBOOK.md</code> Operational playbook capturing intent, actors, and implementation guidance. <code>docs/README.md</code> Overview of the toolkit assets shipped in this folder. <code>ci/workflow.partial.yml</code> GitHub Actions fragment for embedding toolkit checks into existing pipelines. <code>scripts/scan_hotspots.py</code> Entry point for churn and hotspot analysis. <code>scripts/</code> (other modules) Helpers for codemods, verification, and advisory reporting."},{"location":"reference/refactoring-toolkit/#usage-patterns","title":"Usage Patterns","text":"<ul> <li>Start with <code>docs/PLAN.md</code> to scope an adoption rollout, then tailor <code>refactor.config.yaml</code> to your   repository structure and risk thresholds.</li> <li>Drop <code>ci/workflow.partial.yml</code> into your CI pipeline or import sections of it to run hotspot scans   and characterization tests as advisory checks during pull requests.</li> <li>Extend the scripts in <code>scripts/</code> to codify additional refactoring heuristics or to integrate with   internal tooling.</li> </ul>"},{"location":"reference/refactoring-toolkit/#related-documentation","title":"Related Documentation","text":"<ul> <li><code>docs/explanation/architecture.md</code> for a conceptual overview of   how the toolkit aligns with the core package.</li> <li><code>docs/how-to/install-wheelhouse.md</code> for instructions on   distributing the packaged tooling.</li> <li><code>docs/tutorials/getting-started.md</code> for the first-run workflow.</li> </ul>"},{"location":"reference/telemetry-events/","title":"Telemetry Events Reference","text":"<p>This document describes all structured telemetry events emitted by Hephaestus. Events are used for observability, debugging, and operational metrics collection.</p>"},{"location":"reference/telemetry-events/#event-architecture","title":"Event Architecture","text":"<p>Hephaestus uses a structured telemetry system with:</p> <ul> <li>Event Registry: Central registry of all defined events with validation</li> <li>Required Fields: Fields that must be present in every event emission</li> <li>Optional Fields: Fields that may be included for additional context</li> <li>Validation: Automatic validation of event payloads against schemas</li> <li>Correlation: Run IDs and operation IDs for distributed tracing</li> </ul>"},{"location":"reference/telemetry-events/#event-categories","title":"Event Categories","text":""},{"location":"reference/telemetry-events/#cli-events","title":"CLI Events","text":"<p>Events emitted by CLI command handlers.</p>"},{"location":"reference/telemetry-events/#clicleanupstart","title":"<code>cli.cleanup.start</code>","text":"<p>Description: Cleanup CLI invocation started.</p> <p>Required Fields:</p> <ul> <li><code>include_git</code> (bool): Whether to clean .git directories</li> <li><code>include_poetry_env</code> (bool): Whether to clean Poetry environments</li> <li><code>python_cache</code> (bool): Whether to clean Python cache</li> <li><code>build_artifacts</code> (bool): Whether to clean build artifacts</li> <li><code>node_modules</code> (bool): Whether to clean node_modules</li> <li><code>deep_clean</code> (bool): Whether deep clean mode is enabled</li> <li><code>extra_paths</code> (list): Additional paths to clean</li> <li><code>dry_run</code> (bool): Whether this is a dry run</li> </ul> <p>Optional Fields:</p> <ul> <li><code>root</code> (Path): Project root directory</li> <li><code>audit_manifest</code> (Path): Path to audit manifest</li> </ul> <p>Example:</p> <pre><code>{\n  \"event\": \"cli.cleanup.start\",\n  \"include_git\": false,\n  \"include_poetry_env\": false,\n  \"python_cache\": true,\n  \"build_artifacts\": true,\n  \"node_modules\": false,\n  \"deep_clean\": false,\n  \"extra_paths\": [],\n  \"dry_run\": false,\n  \"root\": \"/project\"\n}\n</code></pre>"},{"location":"reference/telemetry-events/#clicleanupcomplete","title":"<code>cli.cleanup.complete</code>","text":"<p>Description: Cleanup CLI invocation completed successfully.</p> <p>Required Fields:</p> <ul> <li><code>removed</code> (int): Number of paths removed</li> <li><code>skipped</code> (int): Number of paths skipped</li> <li><code>errors</code> (int): Number of errors encountered</li> </ul> <p>Optional Fields:</p> <ul> <li><code>audit_manifest</code> (Path): Path where audit manifest was written</li> </ul>"},{"location":"reference/telemetry-events/#clicleanupfailed","title":"<code>cli.cleanup.failed</code>","text":"<p>Description: Cleanup CLI invocation aborted with errors.</p> <p>Required Fields:</p> <ul> <li><code>errors</code> (int): Number of errors that caused failure</li> </ul>"},{"location":"reference/telemetry-events/#cliguard-railsstart","title":"<code>cli.guard-rails.start</code>","text":"<p>Description: Guard-rails pipeline started.</p> <p>Required Fields:</p> <ul> <li><code>skip_format</code> (bool): Whether formatting step is skipped</li> </ul>"},{"location":"reference/telemetry-events/#cliguard-railscomplete","title":"<code>cli.guard-rails.complete</code>","text":"<p>Description: Guard-rails pipeline completed successfully.</p> <p>Required Fields:</p> <ul> <li><code>skip_format</code> (bool): Whether formatting step was skipped</li> </ul>"},{"location":"reference/telemetry-events/#cliguard-railsfailed","title":"<code>cli.guard-rails.failed</code>","text":"<p>Description: Guard-rails pipeline failed.</p> <p>Required Fields:</p> <ul> <li><code>step</code> (str): Which step failed (e.g., \"ruff check\", \"mypy\", \"pytest\")</li> <li><code>returncode</code> (int): Exit code from failed step</li> </ul> <p>Optional Fields:</p> <ul> <li><code>level</code> (str): Log level for the failure</li> </ul>"},{"location":"reference/telemetry-events/#cliguard-railsdrift","title":"<code>cli.guard-rails.drift</code>","text":"<p>Description: Tool version drift detected.</p> <p>Required Fields:</p> <ul> <li><code>drifted_tools</code> (list[str]): Names of tools with version drift</li> </ul> <p>Example:</p> <pre><code>{\n  \"event\": \"cli.guard-rails.drift\",\n  \"drifted_tools\": [\"ruff\", \"mypy\"]\n}\n</code></pre>"},{"location":"reference/telemetry-events/#cliguard-railsdriftok","title":"<code>cli.guard-rails.drift.ok</code>","text":"<p>Description: No tool version drift detected.</p>"},{"location":"reference/telemetry-events/#clireleaseinstallstart","title":"<code>cli.release.install.start</code>","text":"<p>Description: Release installation command invoked.</p> <p>Required Fields:</p> <ul> <li><code>repository</code> (str): GitHub repository (owner/repo)</li> <li><code>tag</code> (str): Release tag to install</li> <li><code>destination</code> (Path): Download destination</li> <li><code>allow_unsigned</code> (bool): Whether unsigned releases are allowed</li> <li><code>asset_pattern</code> (str): Pattern for matching assets</li> <li><code>manifest_pattern</code> (str): Pattern for checksum manifests</li> <li><code>sigstore_pattern</code> (str): Pattern for Sigstore bundles</li> <li><code>require_sigstore</code> (bool): Whether Sigstore verification is required</li> <li><code>timeout</code> (float): Network timeout in seconds</li> <li><code>max_retries</code> (int): Maximum retry attempts</li> </ul> <p>Optional Fields:</p> <ul> <li><code>sigstore_identity</code> (str): Expected Sigstore identity pattern</li> </ul>"},{"location":"reference/telemetry-events/#clireleaseinstallcomplete","title":"<code>cli.release.install.complete</code>","text":"<p>Description: Release installation command completed.</p> <p>Required Fields:</p> <ul> <li><code>repository</code> (str): GitHub repository</li> <li><code>tag</code> (str): Release tag installed</li> <li><code>asset</code> (str): Asset name installed</li> <li><code>allow_unsigned</code> (bool): Whether unsigned was allowed</li> </ul>"},{"location":"reference/telemetry-events/#clireleaseinstallarchive-removed","title":"<code>cli.release.install.archive-removed</code>","text":"<p>Description: Temporary release archive removed after installation.</p> <p>Required Fields:</p> <ul> <li><code>archive</code> (Path): Path to removed archive</li> </ul>"},{"location":"reference/telemetry-events/#cleanup-engine-events","title":"Cleanup Engine Events","text":"<p>Events emitted by the cleanup engine during workspace cleaning.</p>"},{"location":"reference/telemetry-events/#cleanuprunstart","title":"<code>cleanup.run.start</code>","text":"<p>Description: Cleanup engine starting sweep across search roots.</p> <p>Required Fields:</p> <ul> <li><code>search_roots</code> (list[Path]): Directories to search</li> <li><code>include_git</code> (bool): Clean .git directories</li> <li><code>include_poetry_env</code> (bool): Clean Poetry environments</li> <li><code>python_cache</code> (bool): Clean Python cache</li> <li><code>build_artifacts</code> (bool): Clean build artifacts</li> <li><code>node_modules</code> (bool): Clean node_modules</li> <li><code>extra_paths</code> (list[Path]): Additional paths</li> <li><code>dry_run</code> (bool): Dry run mode</li> </ul>"},{"location":"reference/telemetry-events/#cleanupruncomplete","title":"<code>cleanup.run.complete</code>","text":"<p>Description: Cleanup engine completed sweep.</p> <p>Required Fields:</p> <ul> <li><code>removed</code> (int): Paths removed</li> <li><code>skipped</code> (int): Paths skipped</li> <li><code>errors</code> (int): Errors encountered</li> <li><code>dry_run</code> (bool): Was dry run</li> </ul> <p>Optional Fields:</p> <ul> <li><code>audit_manifest</code> (Path): Audit manifest location</li> </ul>"},{"location":"reference/telemetry-events/#cleanuppathskipped","title":"<code>cleanup.path.skipped</code>","text":"<p>Description: Cleanup skipped a root path.</p> <p>Required Fields:</p> <ul> <li><code>path</code> (Path): Path that was skipped</li> <li><code>reason</code> (str): Why it was skipped</li> </ul>"},{"location":"reference/telemetry-events/#cleanuppatherror","title":"<code>cleanup.path.error</code>","text":"<p>Description: Cleanup encountered an error while removing a path.</p> <p>Required Fields:</p> <ul> <li><code>path</code> (Path): Path that caused error</li> <li><code>reason</code> (str): Error description</li> </ul>"},{"location":"reference/telemetry-events/#cleanuppathpreview","title":"<code>cleanup.path.preview</code>","text":"<p>Description: Cleanup previewed removing a path (dry run).</p> <p>Required Fields:</p> <ul> <li><code>path</code> (Path): Path to be removed</li> <li><code>dry_run</code> (bool): Always true for preview</li> </ul>"},{"location":"reference/telemetry-events/#cleanuppathremoved","title":"<code>cleanup.path.removed</code>","text":"<p>Description: Cleanup removed a path.</p> <p>Required Fields:</p> <ul> <li><code>path</code> (Path): Path that was removed</li> <li><code>dry_run</code> (bool): Was this a dry run</li> </ul>"},{"location":"reference/telemetry-events/#release-pipeline-events","title":"Release Pipeline Events","text":"<p>Events emitted during release asset download and installation.</p>"},{"location":"reference/telemetry-events/#releasemetadatafetch","title":"<code>release.metadata.fetch</code>","text":"<p>Description: Fetching release metadata from GitHub.</p>"},{"location":"reference/telemetry-events/#releaseassetselected","title":"<code>release.asset.selected</code>","text":"<p>Description: Release asset selected for download.</p> <p>Required Fields:</p> <ul> <li><code>asset</code> (str): Asset name</li> <li><code>size</code> (int): Asset size in bytes</li> </ul>"},{"location":"reference/telemetry-events/#releaseassetsanitised","title":"<code>release.asset.sanitised</code>","text":"<p>Description: Release asset name sanitised before download.</p> <p>Required Fields:</p> <ul> <li><code>original_name</code> (str): Original asset name from GitHub</li> <li><code>sanitised_name</code> (str): Sanitised filename for filesystem</li> </ul> <p>Example:</p> <pre><code>{\n  \"event\": \"release.asset.sanitised\",\n  \"original_name\": \"../../../etc/passwd\",\n  \"sanitised_name\": \"passwd\"\n}\n</code></pre>"},{"location":"reference/telemetry-events/#releasemanifestlocate","title":"<code>release.manifest.locate</code>","text":"<p>Description: Locating checksum manifest for release asset.</p> <p>Required Fields:</p> <ul> <li><code>pattern</code> (str): Glob pattern used to find manifest</li> </ul>"},{"location":"reference/telemetry-events/#releasemanifestdownload","title":"<code>release.manifest.download</code>","text":"<p>Description: Downloading checksum manifest for release asset.</p> <p>Required Fields:</p> <ul> <li><code>manifest</code> (str): Manifest filename</li> <li><code>destination</code> (Path): Download location</li> </ul>"},{"location":"reference/telemetry-events/#releasemanifestverified","title":"<code>release.manifest.verified</code>","text":"<p>Description: Checksum manifest verified against downloaded asset.</p> <p>Required Fields:</p> <ul> <li><code>asset</code> (str): Asset filename</li> <li><code>digest</code> (str): SHA-256 digest that was verified</li> </ul>"},{"location":"reference/telemetry-events/#releasemanifestskipped","title":"<code>release.manifest.skipped</code>","text":"<p>Description: Checksum verification intentionally skipped.</p> <p>Required Fields:</p> <ul> <li><code>asset</code> (str): Asset for which verification was skipped</li> </ul>"},{"location":"reference/telemetry-events/#releasedownloadstart","title":"<code>release.download.start</code>","text":"<p>Description: Starting download of release asset.</p> <p>Required Fields:</p> <ul> <li><code>asset</code> (str): Asset to download</li> <li><code>destination</code> (Path): Download location</li> </ul> <p>Optional Fields:</p> <ul> <li><code>overwrite</code> (bool): Whether existing file will be overwritten</li> </ul>"},{"location":"reference/telemetry-events/#releasedownloadcomplete","title":"<code>release.download.complete</code>","text":"<p>Description: Release asset downloaded successfully.</p> <p>Required Fields:</p> <ul> <li><code>asset</code> (str): Downloaded asset</li> <li><code>destination</code> (Path): Final location</li> </ul>"},{"location":"reference/telemetry-events/#releasenetworkretry","title":"<code>release.network.retry</code>","text":"<p>Description: Network retry triggered while fetching release metadata.</p> <p>Required Fields:</p> <ul> <li><code>url</code> (str): URL being fetched</li> <li><code>attempt</code> (int): Current attempt number</li> <li><code>max_retries</code> (int): Maximum attempts allowed</li> </ul> <p>Optional Fields:</p> <ul> <li><code>reason</code> (str): Reason for retry</li> <li><code>backoff_seconds</code> (float): Backoff delay</li> <li><code>description</code> (str): Additional context</li> </ul>"},{"location":"reference/telemetry-events/#releasehttpretry","title":"<code>release.http.retry</code>","text":"<p>Description: HTTP retry triggered during asset download.</p> <p>Required Fields:</p> <ul> <li><code>url</code> (str): URL being downloaded</li> <li><code>attempt</code> (int): Current attempt</li> <li><code>max_retries</code> (int): Maximum attempts</li> </ul> <p>Optional Fields:</p> <ul> <li><code>http_status</code> (int): HTTP status code</li> <li><code>backoff_seconds</code> (float): Backoff delay</li> <li><code>description</code> (str): Additional context</li> </ul>"},{"location":"reference/telemetry-events/#releasesigstorelocate","title":"<code>release.sigstore.locate</code>","text":"<p>Description: Locating Sigstore bundle for attestation verification.</p> <p>Required Fields:</p> <ul> <li><code>pattern</code> (str): Glob pattern for bundle</li> </ul>"},{"location":"reference/telemetry-events/#releasesigstoredownload","title":"<code>release.sigstore.download</code>","text":"<p>Description: Downloading Sigstore bundle for attestation verification.</p> <p>Required Fields:</p> <ul> <li><code>bundle</code> (str): Bundle filename</li> <li><code>destination</code> (Path): Download location</li> </ul>"},{"location":"reference/telemetry-events/#releasesigstoremissing","title":"<code>release.sigstore.missing</code>","text":"<p>Description: Sigstore bundle missing from release.</p> <p>Required Fields:</p> <ul> <li><code>pattern</code> (str): Pattern that didn't match any bundles</li> </ul>"},{"location":"reference/telemetry-events/#releasesigstoreverified","title":"<code>release.sigstore.verified</code>","text":"<p>Description: Sigstore attestation verified successfully.</p> <p>Required Fields:</p> <ul> <li><code>subject</code> (str): Certificate subject</li> <li><code>issuer</code> (str): Certificate issuer</li> <li><code>identities</code> (tuple[str]): Verified identities</li> </ul> <p>Example:</p> <pre><code>{\n  \"event\": \"release.sigstore.verified\",\n  \"subject\": \"https://github.com/user/repo/.github/workflows/release.yml@refs/heads/main\",\n  \"issuer\": \"https://token.actions.githubusercontent.com\",\n  \"identities\": [\"https://github.com/user/repo\"]\n}\n</code></pre>"},{"location":"reference/telemetry-events/#releaseextractstart","title":"<code>release.extract.start</code>","text":"<p>Description: Extracting downloaded release archive.</p> <p>Required Fields:</p> <ul> <li><code>destination</code> (Path): Extraction destination</li> </ul> <p>Optional Fields:</p> <ul> <li><code>overwrite</code> (bool): Whether to overwrite existing files</li> </ul>"},{"location":"reference/telemetry-events/#releaseextractcomplete","title":"<code>release.extract.complete</code>","text":"<p>Description: Extraction of release archive completed.</p> <p>Required Fields:</p> <ul> <li><code>destination</code> (Path): Where archive was extracted</li> </ul>"},{"location":"reference/telemetry-events/#releaseinstallstart","title":"<code>release.install.start</code>","text":"<p>Description: Starting installation of wheels from directory.</p> <p>Required Fields:</p> <ul> <li><code>wheels</code> (int): Number of wheel files found</li> <li><code>directory</code> (Path): Directory containing wheels</li> <li><code>upgrade</code> (bool): Whether to upgrade existing packages</li> </ul> <p>Optional Fields:</p> <ul> <li><code>python_executable</code> (str): Python interpreter being used</li> </ul>"},{"location":"reference/telemetry-events/#releaseinstallinvoke","title":"<code>release.install.invoke</code>","text":"<p>Description: Invoking pip install command.</p> <p>Required Fields:</p> <ul> <li><code>command</code> (list[str]): Full pip command being executed</li> </ul>"},{"location":"reference/telemetry-events/#releaseinstallcomplete","title":"<code>release.install.complete</code>","text":"<p>Description: Completed installation of wheels from directory.</p> <p>Required Fields:</p> <ul> <li><code>wheels</code> (int): Number of wheels installed</li> <li><code>directory</code> (Path): Source directory</li> </ul>"},{"location":"reference/telemetry-events/#using-telemetry-events","title":"Using Telemetry Events","text":""},{"location":"reference/telemetry-events/#emitting-events","title":"Emitting Events","text":"<p>Events are emitted using the <code>telemetry.emit_event()</code> function:</p> <pre><code>from hephaestus import telemetry\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ntelemetry.emit_event(\n    logger,\n    telemetry.CLEANUP_PATH_REMOVED,\n    message=\"Removed Python cache\",\n    path=\"/project/__pycache__\",\n    dry_run=False,\n)\n</code></pre>"},{"location":"reference/telemetry-events/#event-validation","title":"Event Validation","text":"<p>All events are automatically validated against their schema:</p> <pre><code># This will raise ValueError if required fields are missing\ntelemetry.emit_event(\n    logger,\n    telemetry.RELEASE_ASSET_SELECTED,\n    # Missing required field \"size\" - will raise ValueError\n    asset=\"wheelhouse.tar.gz\",\n)\n</code></pre>"},{"location":"reference/telemetry-events/#operation-context","title":"Operation Context","text":"<p>Use operation contexts to correlate related events:</p> <pre><code>from hephaestus import telemetry\n\noperation_id = telemetry.generate_operation_id()\n\nwith telemetry.operation_context(\n    \"release.download\",\n    operation_id=operation_id,\n    repository=\"owner/repo\",\n    tag=\"v1.0.0\",\n):\n    # All events emitted here will include operation metadata\n    telemetry.emit_event(logger, telemetry.RELEASE_DOWNLOAD_START, ...)\n    # ... download logic ...\n    telemetry.emit_event(logger, telemetry.RELEASE_DOWNLOAD_COMPLETE, ...)\n</code></pre>"},{"location":"reference/telemetry-events/#log-formats","title":"Log Formats","text":"<p>Events can be output in text or JSON format:</p> <p>Text format (human-readable):</p> <pre><code>INFO hephaestus.release: Downloading release asset | event=release.download.start asset=wheelhouse.tar.gz destination=/cache/wheelhouse.tar.gz\n</code></pre> <p>JSON format (machine-parseable):</p> <pre><code>{\n  \"timestamp\": \"2025-01-11T12:34:56.789Z\",\n  \"level\": \"INFO\",\n  \"logger\": \"hephaestus.release\",\n  \"message\": \"Downloading release asset\",\n  \"event\": \"release.download.start\",\n  \"payload\": {\n    \"asset\": \"wheelhouse.tar.gz\",\n    \"destination\": \"/cache/wheelhouse.tar.gz\",\n    \"operation\": \"release.download\",\n    \"operation_id\": \"op-abc123\"\n  }\n}\n</code></pre>"},{"location":"reference/telemetry-events/#event-registry-api","title":"Event Registry API","text":""},{"location":"reference/telemetry-events/#registering-custom-events","title":"Registering Custom Events","text":"<p>While not typically needed, you can register custom events:</p> <pre><code>from hephaestus.telemetry import TelemetryEvent, registry\n\nMY_CUSTOM_EVENT = registry.register(\n    TelemetryEvent(\n        name=\"my.custom.event\",\n        description=\"Description of what this event represents\",\n        required_fields=(\"field1\", \"field2\"),\n        optional_fields=(\"field3\",),\n    )\n)\n</code></pre>"},{"location":"reference/telemetry-events/#querying-the-registry","title":"Querying the Registry","text":"<pre><code>from hephaestus import telemetry\n\n# Get a specific event\nevent = telemetry.registry.get(\"cli.cleanup.start\")\n\n# List all registered events\nfor event in telemetry.registry.all_events():\n    print(f\"{event.name}: {event.description}\")\n</code></pre>"},{"location":"reference/telemetry-events/#best-practices","title":"Best Practices","text":""},{"location":"reference/telemetry-events/#1-always-use-defined-events","title":"1. Always Use Defined Events","text":"<p>Don't emit arbitrary log events - use the defined telemetry events:</p> <pre><code># \u274c Bad: Arbitrary log message\nlogger.info(\"Cleaning up build artifacts\")\n\n# \u2705 Good: Structured telemetry event\ntelemetry.emit_event(\n    logger,\n    telemetry.CLEANUP_PATH_REMOVED,\n    message=\"Cleaning up build artifacts\",\n    path=build_dir,\n    dry_run=False,\n)\n</code></pre>"},{"location":"reference/telemetry-events/#2-include-context-in-operation-blocks","title":"2. Include Context in Operation Blocks","text":"<p>Use operation contexts for multi-step workflows:</p> <pre><code># \u2705 Good: All events correlated with operation ID\nwith telemetry.operation_context(\"cli.guard-rails\", operation_id=op_id):\n    emit_event(logger, telemetry.CLI_GUARD_RAILS_START, ...)\n    # ... pipeline steps ...\n    emit_event(logger, telemetry.CLI_GUARD_RAILS_COMPLETE, ...)\n</code></pre>"},{"location":"reference/telemetry-events/#3-handle-required-vs-optional-fields","title":"3. Handle Required vs Optional Fields","text":"<p>Be explicit about which fields are required:</p> <pre><code># \u2705 Good: All required fields present\ntelemetry.emit_event(\n    logger,\n    telemetry.RELEASE_NETWORK_RETRY,\n    url=\"https://api.github.com/repos/...\",\n    attempt=2,\n    max_retries=3,\n    # Optional fields can be omitted or included\n    reason=\"Connection timeout\",\n    backoff_seconds=1.0,\n)\n</code></pre>"},{"location":"reference/telemetry-events/#4-use-meaningful-messages","title":"4. Use Meaningful Messages","text":"<p>Provide human-readable messages alongside structured data:</p> <pre><code>telemetry.emit_event(\n    logger,\n    telemetry.CLEANUP_PATH_ERROR,\n    message=f\"Failed to remove {path}: Permission denied\",  # \u2705 Good\n    path=path,\n    reason=\"Permission denied\",\n)\n</code></pre>"},{"location":"reference/telemetry-events/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/telemetry-events/#event-validation-errors","title":"Event Validation Errors","text":"<p>If you see <code>ValueError: Event 'xxx' missing required fields...</code>:</p> <ol> <li>Check the event definition for required fields</li> <li>Ensure all required fields are passed to <code>emit_event()</code></li> <li>Verify field types match expectations</li> </ol>"},{"location":"reference/telemetry-events/#missing-events-in-logs","title":"Missing Events in Logs","text":"<p>If events aren't appearing:</p> <ol> <li>Check log level - events emit at INFO level by default</li> <li>Verify logging is configured: <code>configure_logging()</code></li> <li>Ensure you're using <code>emit_event()</code> not plain <code>logger.info()</code></li> </ol>"},{"location":"reference/telemetry-events/#json-parsing-errors","title":"JSON Parsing Errors","text":"<p>If JSON logs are malformed:</p> <ol> <li>Verify log format is set to \"json\"</li> <li>Check for custom log handlers that may interfere</li> <li>Ensure all payload values are JSON-serializable</li> </ol>"},{"location":"reference/telemetry-events/#see-also","title":"See Also","text":"<ul> <li>Structured Logging</li> <li>Quality Gates</li> <li>Architecture Overview</li> <li>Telemetry Source Code</li> </ul>"},{"location":"tutorials/getting-started/","title":"Tutorial: Getting Started with Hephaestus","text":"<p>This tutorial walks through the minimum steps required to install the toolkit, explore the CLI, and ship your first refactoring workflow using the bundled wheelhouse distribution.</p>"},{"location":"tutorials/getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of this tutorial, you'll know how to:</p> <ul> <li>Install and verify Hephaestus</li> <li>Run comprehensive quality checks with a single command</li> <li>Clean build artifacts safely</li> <li>Check for tool version drift</li> <li>Get data-driven refactoring recommendations</li> <li>Integrate Hephaestus with your development workflow</li> </ul>"},{"location":"tutorials/getting-started/#1-prepare-your-environment","title":"1. Prepare Your Environment","text":""},{"location":"tutorials/getting-started/#install-prerequisites","title":"Install Prerequisites","text":"<ol> <li>Install uv (recommended package manager):</li> </ol> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Or use pip: <code>pip install uv</code></p> <ol> <li>Python 3.12+ is required:</li> </ol> <pre><code>python3 --version  # Should show 3.12 or higher\n</code></pre>"},{"location":"tutorials/getting-started/#get-hephaestus","title":"Get Hephaestus","text":"<p>Choose one of these installation methods:</p>"},{"location":"tutorials/getting-started/#method-a-clone-from-source-for-development","title":"Method A: Clone from Source (for development)","text":"<pre><code>git clone https://github.com/IAmJonoBo/Hephaestus.git\ncd Hephaestus\nuv sync --extra dev --extra qa\n</code></pre>"},{"location":"tutorials/getting-started/#method-b-install-wheelhouse-for-usage","title":"Method B: Install Wheelhouse (for usage)","text":"<pre><code># Install latest stable release\nhephaestus release install --repository IAmJonoBo/Hephaestus\n\n# Or install specific version\nhephaestus release install --repository IAmJonoBo/Hephaestus --tag v0.2.0\n</code></pre>"},{"location":"tutorials/getting-started/#method-c-direct-pip-install-from-source","title":"Method C: Direct pip install (from source)","text":"<pre><code>pip install -e \".[dev,qa]\"\n</code></pre>"},{"location":"tutorials/getting-started/#verify-installation","title":"Verify Installation","text":"<p>Check that Hephaestus is properly installed:</p> <pre><code># Check version\nhephaestus --version\n\n# View available commands\nhephaestus --help\n\n# Verify your environment matches expected tool versions\nhephaestus guard-rails --drift\n</code></pre> <p>If drift is detected, run the suggested remediation command:</p> <pre><code>uv sync --extra dev --extra qa\n</code></pre>"},{"location":"tutorials/getting-started/#2-explore-the-cli","title":"2. Explore the CLI","text":""},{"location":"tutorials/getting-started/#view-available-commands","title":"View Available Commands","text":"<p>List the top-level commands and review built-in help:</p> <pre><code>hephaestus --help\n</code></pre> <p>You'll see these main command groups:</p> <ul> <li>cleanup: Scrub development cruft (build artifacts, caches)</li> <li>guard-rails: Run comprehensive quality pipeline</li> <li>plan: Generate refactoring plans</li> <li>tools: Access refactoring toolkit and QA utilities</li> <li>release: Install wheelhouse distributions</li> <li>schema: Export command schemas for AI integration</li> </ul>"},{"location":"tutorials/getting-started/#try-key-commands","title":"Try Key Commands","text":"<p>Check code quality (most important command):</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>This runs the full quality pipeline:</p> <ol> <li>Deep cleanup of build artifacts</li> <li>Lint code with ruff</li> <li>Auto-format code</li> <li>Type-check with mypy</li> <li>Run tests with coverage</li> <li>Audit dependencies for security issues</li> </ol> <p>Get refactoring recommendations:</p> <pre><code># View hotspots (frequently changed, low coverage areas)\nhephaestus tools refactor hotspots --limit 5\n\n# Get prioritized rankings (requires analytics data)\nhephaestus tools refactor rankings --strategy risk_weighted --limit 10\n\n# Quick QA profile\nhephaestus tools qa profile quick\n</code></pre> <p>Generate a refactoring plan:</p> <pre><code>hephaestus plan\n</code></pre> <p>Export command schemas for AI agents:</p> <pre><code>hephaestus schema --output schemas.json\n</code></pre>"},{"location":"tutorials/getting-started/#3-clean-up-your-workspace","title":"3. Clean Up Your Workspace","text":"<p>Before you start editing, remove local cruft so rollouts stay reproducible.</p>"},{"location":"tutorials/getting-started/#basic-cleanup","title":"Basic Cleanup","text":"<pre><code># Clean from current directory (or git root if detected)\nhephaestus cleanup\n</code></pre> <p>This removes:</p> <ul> <li>Build artifacts (<code>dist/</code>, <code>build/</code>, <code>*.egg-info</code>)</li> <li>Python caches (<code>__pycache__</code>, <code>.pyc</code> files)</li> <li>Test caches (<code>.pytest_cache</code>)</li> <li>macOS metadata (<code>.DS_Store</code>)</li> </ul>"},{"location":"tutorials/getting-started/#deep-clean","title":"Deep Clean","text":"<p>For a more thorough cleanup including virtual environments and coverage reports:</p> <pre><code>hephaestus cleanup --deep-clean\n</code></pre>"},{"location":"tutorials/getting-started/#preview-before-deleting","title":"Preview Before Deleting","text":"<p>Always review what will be deleted:</p> <pre><code># Dry-run mode (shows preview without deleting)\nhephaestus cleanup --dry-run\n\n# Or use interactive mode (default)\n# You'll see a preview table and can confirm before proceeding\nhephaestus cleanup\n</code></pre>"},{"location":"tutorials/getting-started/#safety-features","title":"Safety Features","text":"<p>Hephaestus cleanup includes multiple safety rails:</p> <ul> <li>Automatic Preview: Shows what will be deleted before proceeding</li> <li>Dangerous Path Protection: Refuses to clean <code>/</code>, <code>/home</code>, <code>/usr</code>, etc.</li> <li>Virtual Environment Protection: Preserves <code>.venv/site-packages</code> during build cleanup</li> <li>Typed Confirmation: Requires typing \"CONFIRM\" for out-of-root targets</li> <li>Audit Manifests: Optionally generates JSON manifests of deleted files</li> </ul>"},{"location":"tutorials/getting-started/#automate-with-pre-commit-hooks","title":"Automate with Pre-commit Hooks","text":"<p>Install pre-commit hooks to automate cleanup and quality checks:</p> <pre><code>pre-commit install\n</code></pre> <p>This runs cleanup and quality gates automatically before each commit.</p>"},{"location":"tutorials/getting-started/#4-run-the-refactoring-toolkit","title":"4. Run the Refactoring Toolkit","text":"<p>The toolkit ships advisory scripts you can customize for your repository.</p>"},{"location":"tutorials/getting-started/#scan-for-hotspots","title":"Scan for Hotspots","text":"<p>Hotspots are areas of code that change frequently and have low test coverage:</p> <pre><code># Run the hotspot scanner\npython hephaestus-toolkit/refactoring/scripts/scan_hotspots.py --limit 10\n</code></pre> <p>This analyzes your codebase and identifies:</p> <ul> <li>High-churn files (changed frequently)</li> <li>Low-coverage modules</li> <li>Complex functions needing refactoring</li> </ul>"},{"location":"tutorials/getting-started/#get-prioritized-rankings","title":"Get Prioritized Rankings","text":"<p>If you have analytics data configured, use the ranking command:</p> <pre><code># Risk-weighted rankings (default strategy)\nhephaestus tools refactor rankings\n\n# Focus on coverage gaps\nhephaestus tools refactor rankings --strategy coverage_first --limit 10\n\n# Focus on high-churn files\nhephaestus tools refactor rankings --strategy churn_based\n\n# Composite approach with embedding bonus\nhephaestus tools refactor rankings --strategy composite\n</code></pre>"},{"location":"tutorials/getting-started/#configure-analytics-data-sources","title":"Configure Analytics Data Sources","text":"<p>To use rankings, configure data sources in <code>pyproject.toml</code>:</p> <pre><code>[tool.hephaestus.analytics]\nchurn_file = \"analytics/churn.json\"\ncoverage_file = \"coverage.xml\"\nembeddings_file = \"analytics/embeddings.json\"\n</code></pre> <p>Or use a separate config file:</p> <pre><code>hephaestus tools refactor rankings --config path/to/config.yaml\n</code></pre> <p>Review the generated report and copy any candidate issues into your backlog.</p>"},{"location":"tutorials/getting-started/#5-validate-changes-with-quality-gates","title":"5. Validate Changes with Quality Gates","text":"<p>As you prototype a refactor, continuously validate your changes.</p>"},{"location":"tutorials/getting-started/#run-comprehensive-quality-checks","title":"Run Comprehensive Quality Checks","text":"<p>The guard-rails command is your one-stop validation:</p> <pre><code>hephaestus guard-rails\n</code></pre> <p>This runs all quality gates in order:</p> <ol> <li>Cleanup: Removes build artifacts</li> <li>Lint: Checks code style and errors (ruff)</li> <li>Format: Auto-formats code (ruff format)</li> <li>Type Check: Validates type annotations (mypy)</li> <li>Test: Runs pytest with coverage reporting</li> <li>Security Audit: Scans for vulnerabilities (pip-audit)</li> </ol>"},{"location":"tutorials/getting-started/#skip-formatting","title":"Skip Formatting","text":"<p>If you want to review changes before auto-formatting:</p> <pre><code>hephaestus guard-rails --no-format\n</code></pre>"},{"location":"tutorials/getting-started/#run-individual-quality-gates","title":"Run Individual Quality Gates","text":"<p>You can also run specific checks:</p> <pre><code># Tests with coverage\npytest\n\n# Linting\nruff check .\n\n# Type checking\nmypy src tests\n\n# Security audit\npip-audit --strict --ignore-vuln GHSA-4xh5-x5gv-qwph\n\n# Architecture check (nested decorators)\npython3 scripts/lint_nested_decorators.py src/hephaestus\n</code></pre>"},{"location":"tutorials/getting-started/#coverage-threshold","title":"Coverage Threshold","text":"<p>Aim to keep total coverage above 85% (the default gate enforced by CI):</p> <pre><code># Check coverage\nhephaestus tools qa coverage\n\n# Run tests with coverage report\npytest --cov=src/hephaestus --cov-report=term-missing\n</code></pre>"},{"location":"tutorials/getting-started/#validate-all-gates-at-once","title":"Validate All Gates at Once","text":"<p>Use the comprehensive validation script:</p> <pre><code>python3 scripts/validate_quality_gates.py\n</code></pre> <p>This provides categorized reporting of all quality standards.</p>"},{"location":"tutorials/getting-started/#6-package-and-share","title":"6. Package and Share","text":"<p>When you're ready to share the toolkit with another repository:</p>"},{"location":"tutorials/getting-started/#build-a-wheelhouse","title":"Build a Wheelhouse","text":"<ol> <li>Build the distribution:</li> </ol> <pre><code># Using uv (recommended)\nuv build\n\n# Or using standard tools\npython3 -m build\n</code></pre> <ol> <li>Create a wheelhouse archive:</li> </ol> <pre><code>tar -czf hephaestus-wheelhouse.tar.gz dist/\n</code></pre> <ol> <li>Calculate checksums for verification:</li> </ol> <pre><code>sha256sum dist/*.whl dist/*.tar.gz &gt; SHA256SUMS\n</code></pre>"},{"location":"tutorials/getting-started/#share-with-others","title":"Share with Others","text":""},{"location":"tutorials/getting-started/#option-a-github-release","title":"Option A: GitHub Release","text":"<ol> <li>Upload the archive as a GitHub Release asset</li> <li>Include the SHA256SUMS file</li> <li>Users can install with:</li> </ol> <pre><code>hephaestus release install --repository IAmJonoBo/Hephaestus --tag v0.2.0\n</code></pre>"},{"location":"tutorials/getting-started/#option-b-direct-distribution","title":"Option B: Direct Distribution","text":"<ol> <li>Pass the archive directly to collaborators</li> <li>They can extract and install:</li> </ol> <pre><code>tar -xzf hephaestus-wheelhouse.tar.gz\npip install dist/*.whl\n</code></pre>"},{"location":"tutorials/getting-started/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Always include SHA-256 checksums</li> <li>Consider using Sigstore for attestation</li> <li>Verify checksums before installation:</li> </ul> <pre><code>hephaestus release install --verify-checksum\n</code></pre>"},{"location":"tutorials/getting-started/#next-steps","title":"Next Steps","text":""},{"location":"tutorials/getting-started/#learn-more","title":"Learn More","text":"<ul> <li>Operating Safely Guide: Understand safety features and best practices</li> <li>Quality Gates Guide: Deep dive into quality validation</li> <li>AI Agent Integration: Integrate Hephaestus with AI assistants</li> <li>Architecture Overview: Understand internal modules and design</li> <li>CLI Reference: Complete command and option details</li> </ul>"},{"location":"tutorials/getting-started/#common-workflows","title":"Common Workflows","text":"<p>Daily Development:</p> <pre><code># Check environment\nhephaestus guard-rails --drift\n\n# Make changes\n# ... code ...\n\n# Validate before commit\nhephaestus guard-rails\ngit commit -am \"Your changes\"\n</code></pre> <p>Preparing a Pull Request:</p> <pre><code>hephaestus cleanup --deep-clean\nhephaestus guard-rails\ngit push\n</code></pre> <p>Responding to CI Failures:</p> <pre><code># Check for drift\nhephaestus guard-rails --drift\n\n# Sync if needed\nuv sync --extra dev --extra qa\n\n# Validate\nhephaestus guard-rails\n</code></pre>"},{"location":"tutorials/getting-started/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Run guard-rails early and often - Catch issues before they compound</li> <li>Use drift detection - Prevent environment inconsistencies</li> <li>Preview before cleanup - Always review what will be deleted</li> <li>Configure analytics - Get the most value from rankings</li> <li>Install pre-commit hooks - Automate quality checks</li> <li>Read safety guides - Understand protections before using cleanup</li> <li>Export schemas for AI - Enable AI assistant integration</li> </ol>"},{"location":"tutorials/getting-started/#get-help","title":"Get Help","text":"<ul> <li>Documentation: Browse the <code>docs/</code> directory</li> <li>GitHub Issues: Report bugs or request features</li> <li>Security Reports: See SECURITY.md</li> <li>Discussions: Ask questions on GitHub Discussions</li> </ul>"},{"location":"tutorials/getting-started/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Hephaestus provides a comprehensive quality pipeline in a single command \u2705 Safety features protect against accidental data loss \u2705 AI-native design enables seamless integration with assistants \u2705 Data-driven recommendations help prioritize refactoring work \u2705 Frontier-level quality standards are automatically enforced</p> <p>You're now ready to use Hephaestus to maintain high-quality codebases! \ud83d\udd28</p>"}]}